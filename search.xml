<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>光线追踪器Ray Tracer：入门篇</title>
      <link href="/2019/05/08/RayTracer-Basis/"/>
      <url>/2019/05/08/RayTracer-Basis/</url>
      
        <content type="html"><![CDATA[<p>光线追踪技术是计算机图形学的一类全局光照算法，目前的影视行业大多都采用光线追踪做离线渲染。本章开始构建一个光线追踪离线渲染器（路径追踪），深入理解光线追踪的技术原理。主要参考资料为Peter Shirley的《Ray Tracing in One Weekend》。数学库沿用之前自己写的3D数学库，这方面的东西不再赘述。相关的完全代码在<a href="https://github.com/ZeusYang/Ray-Tracer" target="_blank" rel="noopener">这里</a>。</p><p><div align="left"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/header2.png" height="400"></div></p><a id="more"></a><ul><li>光线追踪纵览</li><li>实现光线追踪渲染器</li><li>程序结果</li></ul><h1 id="一、光线追踪纵览"><a href="#一、光线追踪纵览" class="headerlink" title="一、光线追踪纵览"></a>一、光线追踪纵览</h1><p>&emsp;&emsp;光线追踪 (Ray Tracing) 算法是一种基于真实光路模拟的计算机三维图形渲染算法，相比其它大部分渲染算法，光线追踪算法可以提供更为真实的光影效果。此算法由 Appel 在 1968 年初步提出，1980 年由Whitted 改良为递归算法并提出全局光照模型。直到今天，光线追踪算法仍是图形学的热点，大量的改进在不断涌现。基于对自然界光路的研究, 光线追踪采取逆向计算光路来还原真实颜色。追踪的过程中涵盖了光的反射、折射、吸收等特性 (精确计算)， 并辅以其它重要渲染思想 (进一步模拟)。 其中包含了重要方法，诸如冯氏光照模型 (Phong Shading)、辐射度(Radiosity)、光子映射 (Photon Mapping)、蒙特卡罗方法 (Monte Carlo) 等等。鉴于光线追踪算法对场景仿真程度之高，其被普遍认为是计算机图形学的核心内容， 以及游戏设计、电影特效等相关领域的未来方向。 近年来由于硬件系统的迅速改良， 基于分布式、GPU， 甚至实时渲染的光线追踪显卡也纷纷出现（本人就是入手了一块实时光追显卡rtx2070）。</p><p>&emsp;&emsp;光线追踪算法是一种非常自然的技术，相比于光栅化的方法，它更加简单、暴力、真实。与光栅化根据物体计算所在的像素的方式不同，光线路径追踪的方法是一个相反的过程，它在于用眼睛去看世界而不是世界如何到达眼中。如下图所示，从视点出发向屏幕上每一个像素发出一条光线View Ray，追踪此光路并计算其逆向光线的方向，映射到对应的像素上。通过计算光路上颜色衰减和叠加，即可基本确定每一个像素的颜色。</p><p><img src="https://img-my.csdn.net/uploads/201211/13/1352736355_8683.png" alt="img"></p><center> 图1 光线追踪示意图 </center><p>&emsp;&emsp;可以看到光线追踪是一个递归的过程。发射一束光线到场景，求出光线和几何图形间最近的交点，如果该交点的材质是反射性或折射性的，可以在该交点向反射方向或折射方向继续追踪，如此递归下去，直到设定的最大递归深度或者射线追踪到光源处（或者背景色），如此便计算处一个像素的着色值。</p><p>&emsp;&emsp;基本的光线追踪tracing()递归算法如下所示：</p><p>&emsp;&emsp;<strong>Algorithm 1: 光线追踪递归算法</strong></p><p>&emsp;&emsp;<strong>Input: 射线ray</strong></p><p>&emsp;&emsp;<strong>Output: 反向光颜色</strong></p><p>&emsp;&emsp;<strong>Function tracing():</strong></p><p>&emsp;&emsp;<strong>if no intersection with any object then</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>return background color</strong><br>&emsp;&emsp;<strong>else</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>obj $\leftarrow$  find nearest object from the ray;</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>reflect ray $\leftarrow$getReflectRay(obj);</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>refract ray $\leftarrow$ getRefractRay(obj);</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>main color $\leftarrow$ the radiance of obj;</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>reflect color $\leftarrow$ tracing(reflect ray);</strong><br>&emsp;&emsp;&emsp;&emsp;<strong>refract color $\leftarrow$ tracing(refract ray);</strong></p><p>&emsp;&emsp;&emsp;&emsp;<strong>return mix(main color, reflect color, refract color);</strong></p><h1 id="二、实现光线追踪渲染器"><a href="#二、实现光线追踪渲染器" class="headerlink" title="二、实现光线追踪渲染器"></a>二、实现光线追踪渲染器</h1><p>&emsp;&emsp;采用C++语言不借助第三方图形渲染API实现一个简易的光线追踪器，为了将最后的结果显示出来，我才用<a href="https://github.com/nothings/stb" target="_blank" rel="noopener">stb_image</a>将计算得到的像素矩阵保存为png图片。本篇实现的光线追踪只包含求交运行、计算光线反射和折射向量、反走样、景深等较为初级的方面，而实现的材质包含磨砂材质、玻璃材质和金属材质。</p><h2 id="1、摄像机"><a href="#1、摄像机" class="headerlink" title="1、摄像机"></a>1、摄像机</h2><p>&emsp;&emsp;与光栅化的空间变换过程相反，光线追踪大部分操作都是在世界空间中进行，因而需要将屏幕空间的像素坐标变换到世界空间中，并相应地发射出一条射线。在这里我们不再构建矩阵，直接求解出摄像机的三个坐标轴，然后根据视锥体的视域fov和屏幕的宽高比aspect得到每个像素发射出来的射线。</p><p>&emsp;&emsp;首先我们创建一个射线类$Ray$，射线通常用一个射线原点$m_origin$和射线方向$m_direction$表示，射线上的每个点则表示为$p(t)=m_origin+t*m_direction$，射线上每一个独立的点都有一个自己唯一的$t$值。因而创建的$Ray$类如下所示，其中$pointAt$函数根据给定的$t$值返回相应的射线上的点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vector3D m_origin;</span><br><span class="line">    Vector3D m_direction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor.</span></span><br><span class="line">    Ray() = <span class="keyword">default</span>;</span><br><span class="line">    ~Ray() = <span class="keyword">default</span>;</span><br><span class="line">    Ray(<span class="keyword">const</span> Vector3D &amp;org, <span class="keyword">const</span> Vector3D &amp;dir)</span><br><span class="line">        :m_origin(org), m_direction(dir) &#123;</span><br><span class="line">        m_direction.normalize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter.</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">getOrigin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_origin; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getDirection</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_direction; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p(t) = origin + t*dir;</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">pointAt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;t)</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_origin + m_direction * t; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们实现的基于cpu的光线追踪核心渲染流程是对给定分辨率的像素矩阵，逐行逐列地遍历每个像素坐标，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *RayTracing::render()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>;row &lt; m_height;++ row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;col &lt; m_width;++ col)</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因而对于每个给定的像素坐标$(x,y)$，我们需要获取这个像素坐标对应的发射出去的射线，首先我们把值域为$[0,m_width]$和$[0,m_height]$的像素坐标映射到$[0,1]$，正如如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> u = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(col) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_width);</span><br><span class="line"><span class="keyword">float</span> v = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(row) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_height);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们根据$u$和$v$获取射线方向向量，这涉及到两个方面，一个摄像机的坐标系统，另一个是关于视锥的大小设置。摄像机的坐标轴决定了当前的朝向，视锥的大小设定决定了当前视域的大小。为此，我把摄像机与视锥合并一起，坐标系类型依然是右手坐标系。创建的摄像机类如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector3D m_pos;</span><br><span class="line">    Vector3D m_target;</span><br><span class="line">    Vector3D m_lowerLeftCorner;</span><br><span class="line">    Vector3D m_horizontal;</span><br><span class="line">    Vector3D m_vertical;</span><br><span class="line">    <span class="keyword">float</span> m_fovy, m_aspect;</span><br><span class="line">    Vector3D m_axisX, m_axisY, m_axisZ;</span><br><span class="line"></span><br><span class="line">    Camera(<span class="keyword">const</span> Vector3D &amp;cameraPos, <span class="keyword">const</span> Vector3D &amp;target,<span class="keyword">float</span> vfov,</span><br><span class="line">        <span class="keyword">float</span> aspect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter.</span></span><br><span class="line">    <span class="function">Ray <span class="title">getRay</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;s, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getPosition</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_pos; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getTarget</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_target; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getAxisX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_axisX; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getAxisY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_axisY; &#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getAxisZ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_axisZ; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;pos)</span> </span>&#123; m_pos = pos; update(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;_tar)</span> </span>&#123; m_target = _tar; update(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFovy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;fov)</span> </span>&#123; m_fovy = fov; update(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAspect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;asp)</span> </span>&#123; m_aspect = asp; update(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中$m_pos$即摄像机的世界坐标位置，$m_target$即目标位置，而$m_lowerLeftCorner$表示视锥近平面的左下角位置，$m_horizontal$表示近平面在摄像机坐标系下水平方向的跨度，$m_vertical$则是近平面在摄像机坐标系下垂直方向的跨度。$m_fovy$和$m_aspect$分别是视锥的垂直视域和屏幕的宽高比。初始时我们传入摄像机坐标、目标点以及垂直视域和视口宽高比，然后我们根据这些计算摄像机的三个坐标轴，以及近平面的位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Camera::update()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector3D <span class="title">worldUp</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    <span class="comment">// frustum.</span></span><br><span class="line">    <span class="keyword">float</span> theta = radians(m_fovy);</span><br><span class="line">    <span class="keyword">float</span> half_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">tan</span>(theta * <span class="number">0.5f</span>));</span><br><span class="line">    <span class="keyword">float</span> half_width = m_aspect * half_height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera coordinate system.</span></span><br><span class="line">    m_axisZ = m_pos - m_target;</span><br><span class="line">    m_axisZ.normalize();</span><br><span class="line">    m_axisX = worldUp.crossProduct(m_axisZ);</span><br><span class="line">    m_axisX.normalize();</span><br><span class="line">    m_axisY = m_axisZ.crossProduct(m_axisX);</span><br><span class="line">    m_axisY.normalize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// view port.</span></span><br><span class="line">    m_lowerLeftCorner = m_pos - m_axisX * half_width - m_axisY * half_height - m_axisZ;</span><br><span class="line">    m_horizontal = m_axisX * <span class="number">2.0f</span> * half_width;</span><br><span class="line">    m_vertical = m_axisY * <span class="number">2.0f</span> * half_height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们对于给定在$[0,1]$的$u$和$v$，就可以计算出一条对应的射线向量了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ray Camera::getRay(<span class="keyword">const</span> <span class="keyword">float</span> &amp;s, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ray(m_pos , m_lowerLeftCorner + m_horizontal * s + m_vertical * t - m_pos );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = m_config.m_height - <span class="number">1</span>; row &gt;= <span class="number">0</span>; --row)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; m_config.m_width; ++col)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> u = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(col + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_width);</span><br><span class="line">        <span class="keyword">float</span> v = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(row + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_height);</span><br><span class="line">        Ray ray = camera.getRay(u, v);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、物体求交"><a href="#2、物体求交" class="headerlink" title="2、物体求交"></a>2、物体求交</h2><p>&emsp;&emsp;射线发射出去之后要与物体进行求交运行，对于这类能够被射线碰撞到的物体我们把它抽象为$Hitable$，并用一个虚函数$Hit$作为所有的碰撞求交的接口，创建$Hitable$虚类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HitRecord</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> <span class="keyword">m_t</span>;</span><br><span class="line">    Vector3D m_position;</span><br><span class="line">    Vector3D m_normal;</span><br><span class="line">    Material *m_material;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hitable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Hitable() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Hitable() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到我们还创建了一个$HitRecord$结构体，它包含一次射线碰撞求交的结果记录，其中$m_t$是射线方程的参数$t$，$m_position$是交点的位置，$m_normal$是交点的法向量，而$m_material$则是交点所在物体的材质，求交之后我们需要根据这些记录来计算物体的折射、反射。</p><p>&emsp;&emsp;$Hitable$中的$hit$接口以一条射线$ray$作为输入参数，以一个$Hitable$的引用$ret$作为求交的结果记录，函数返回布尔值以表示是否发生了射线碰撞。此外，值得一提的是我们还输入了两个参数，分别是$t_min$和$t_max$，这个是我们自己对射线线段长度做的一个限制，可以分别去掉太近和太远的物体。</p><p>&emsp;&emsp;然后我们需要向场景中添加物体，光线追踪器的一个”Hello, world!”是球体。我们知道，一个球体的数学表达式为如下所示：</p><script type="math/tex; mode=display">(x-cx)^2+(y-cy)^2+(z-cz)^2=R^2 \tag {1}</script><p>&emsp;&emsp;其中$c=(cx,cy,cz)$是球体的球心，$R$为球体半径。我们现在要求的就是，对于射线上的一点$P(t)=S+tV$，使得$(x,y,z)=P(t)=S+tV$带入公式$(1)$成立，公式$(1)$可以写成点乘的形式如下：</p><script type="math/tex; mode=display">(P-c)\cdot (P-c) = R^2 \tag {2}</script><p>&emsp;&emsp;将$P=P(t)=S+tV$带入公式$(2)$可得：</p><script type="math/tex; mode=display">(V\cdot V)t^2+2(V\cdot(S-c))t+(S-c)\cdot(S-c)-R^2=0 \tag {3}</script><p>&emsp;&emsp;可以看到公式$(3)$中只有$t$未知，它是一个一元二次方程。对于任意的一元二次方程$at^2+bt+c=0$，其解有如下形式：</p><script type="math/tex; mode=display">t=\frac{-b\pm \sqrt{b^2-4ac}}{2a} \tag {4}</script><p>&emsp;&emsp;其中根号内的$D=b^2-4ac$称为根的判别式，它可以反应多项式根的数量。若$D&gt;0$则有两个实数根，若$D=0$则只有一个实数根，若$D&lt;0$则没有实数根。我们首先可以根据判别式判断是否存在交点，然后再求出具体的交点坐标。下面的$Hit$函数，我们首先求出多项式方程的常数项$a$、$b$和$c$，然后求判别式，最后再有解的情况下求取交点。注意，在有两个交点的情况下，我们首先取较近的点，不符合再取较远的那个点。只有一个交点的情况下（如下图2所示），我们不当作射线发生了碰撞（擦边而过）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sphere</span> :</span> <span class="keyword">public</span> Hitable</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">float</span> m_radius;</span><br><span class="line">       Vector3D m_center;</span><br><span class="line">       Material *m_material;</span><br><span class="line"></span><br><span class="line">       Sphere(<span class="keyword">const</span> Vector3D &amp;cen, <span class="keyword">const</span> <span class="keyword">float</span> r, Material *mat)</span><br><span class="line">           :m_center(cen), m_radius(r), m_material(mat) &#123;&#125;</span><br><span class="line">       ~Sphere() &#123; <span class="keyword">if</span> (m_material)<span class="keyword">delete</span> m_material; m_material = <span class="literal">nullptr</span>; &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret)</span> <span class="keyword">const</span></span>;</span><br><span class="line">   &#125;;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Sphere::hit(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret) <span class="keyword">const</span></span><br><span class="line">   &#123;</span><br><span class="line">       Vector3D oc = ray.getOrigin() - m_center;</span><br><span class="line">       <span class="keyword">float</span> a = ray.getDirection().dotProduct(ray.getDirection());</span><br><span class="line">       <span class="keyword">float</span> b = oc.dotProduct(ray.getDirection());</span><br><span class="line">       <span class="keyword">float</span> c = oc.dotProduct(oc) - m_radius * m_radius;</span><br><span class="line">       <span class="comment">// discriminant</span></span><br><span class="line">       <span class="keyword">float</span> discriminant = b * b - a * c;</span><br><span class="line">       <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">float</span> temp = (-b - <span class="built_in">sqrt</span>(b * b - a * c)) / a;</span><br><span class="line">           <span class="keyword">if</span> (temp &gt; t_min &amp;&amp; temp &lt; t_max)</span><br><span class="line">           &#123;</span><br><span class="line">               ret.<span class="keyword">m_t</span> = temp;</span><br><span class="line">               ret.m_position = ray.pointAt(ret.<span class="keyword">m_t</span>);</span><br><span class="line">               ret.m_normal = (ret.m_position - m_center) / m_radius;</span><br><span class="line">               ret.m_material = m_material;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = (-b + <span class="built_in">sqrt</span>(b * b - a * c)) / a;</span><br><span class="line">           <span class="keyword">if</span> (temp &gt; t_min &amp;&amp; temp &lt; t_max)</span><br><span class="line">           &#123;</span><br><span class="line">               ret.<span class="keyword">m_t</span> = temp;</span><br><span class="line">               ret.m_position = ray.pointAt(ret.<span class="keyword">m_t</span>);</span><br><span class="line">               ret.m_normal = (ret.m_position - m_center) / m_radius;</span><br><span class="line">               ret.m_material = m_material;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/sphere1.png" alt="sphere1"></p><center> 图2 射线与球体的相交情况 </center><p>&emsp;&emsp;当场景中有多个物体时，当前的做法是在每次求交时遍历所有的物体，我们需要一个$HitableList$来存储这些物体。我们令$HitableList$继承自$Hitable$，这样$HitableList$就表现得好像只有一个很大的物体一样，并在实现$hit$函数中对场景得所有物体遍历调用他们的$Hit$方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HitableList</span> :</span> <span class="keyword">public</span> Hitable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Hitable*&gt; m_list;</span><br><span class="line"></span><br><span class="line">    HitableList() = <span class="keyword">default</span>;</span><br><span class="line">    ~HitableList() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addHitable</span><span class="params">(Hitable *target)</span> </span>&#123; m_list.push_back(target); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHitable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m_list.size(); ++x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_list[x];</span><br><span class="line">            m_list[x] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> HitableList::hit(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_min, <span class="keyword">const</span> <span class="keyword">float</span> &amp;t_max, HitRecord &amp;ret) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    HitRecord tempRec;</span><br><span class="line">    <span class="keyword">bool</span> hitAny = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">double</span> closestSoFar = t_max;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m_list.size(); ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_list[x]-&gt;hit(ray, t_min, closestSoFar, tempRec))</span><br><span class="line">        &#123;</span><br><span class="line">            hitAny = <span class="literal">true</span>;</span><br><span class="line">            closestSoFar = tempRec.<span class="keyword">m_t</span>;</span><br><span class="line">            ret = tempRec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hitAny;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此外，值得一提的是，在$HitableList$的$hit$函数中我们需要做一个类似于深度测试的步骤，我们从摄像机发射的射线只能跟最靠近摄像机的那个交点做反射、折射，一条射线发射出去可能会与多个物体相交，我们必须取最近的交点。这个距离我们用射线方程中的$t$来描述，显然$t$越大则交点越远，因此用$closestSoFar$来记录当前获取的交点的最小$t$，以此作为$t$的上限，这样最终求出来的必然就是最近的交点。</p><h2 id="3、物体材质"><a href="#3、物体材质" class="headerlink" title="3、物体材质"></a>3、物体材质</h2><p>&emsp;&emsp;现在我们的一个问题就是求出交点之后，光线在交点上做什么样的反射和折射？这取决于物体的材质。若物体的材质是透明的玻璃，那么光线一般做折射；而若物体是光滑的镜面，则光线做完美的反射。针对不同物体的材质，光线的散射情况各不相同，为此我们创建一个虚类$Material$，并把光线散射的这一过程抽象为$sactter$函数接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Material() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Material() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Vector3D &amp;attenuation, Ray &amp;scattered)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，$scatter$函数接收入射射线$Ray$以及求交获得的$HitRecord$，计算散射光线的向量，返回的结果表示是否发生了散射。其中的$attenuation$本质上是物体自身的反射颜色，之所以叫$attenuation$是因为光线照射到物体上，物体一般会吸收光线中的大部分颜色，然后仅反射自身颜色的部分，这个过程使得光线在反射过程中不断衰减。</p><h3 id="3-1-Lambertian反射材质"><a href="#3-1-Lambertian反射材质" class="headerlink" title="3.1 Lambertian反射材质"></a>3.1 Lambertian反射材质</h3><p>&emsp;&emsp;首先我们要实现的是Lambertian反射的材质，Lambertian反射也叫理想散射。Lambertian表面是指在一个固定的照明分布下从所有的视场方向上观测都具有相同亮度的表面，Lambertian表面不吸收任何入射光。Lambertian反射也叫散光反射，不管照明分布如何，Lambertian表面在所有的表面方向上接收并发散所有的入射照明，结果是每一个方向上都能看到相同数量的能量。这是一种理想情况，现实中不存在完全漫反射，但Lambertian可以用来近似的模拟一些粗糙表面的效果，比如纸张。</p><p><img src="https://images2015.cnblogs.com/blog/305017/201511/305017-20151106030028617-1366640843.jpg" alt="img"></p><center> 图3 Lambertian反射 </center><p>&emsp;&emsp;为了实现Lambertian表面的均匀反射现象，我们令射线碰撞到表面之后，在交点的半球方向上随机地反射，只要随机性够均匀，我们就能模拟出理想散射的情况。为此，我们取一个正切于交点$P$表面的单位球体，在这个球体内随机取一个点$S$，则反射的向量就为$S-P$。这个正切于交点$P$表面的单位球体不难求得，设交点$P$的单位法向量为$N$，那么该正切球体的球心为$P+N$。我们首先在球心为原点的单位球内随机求得一个方向向量，然后将这个方向向量加上正切球体的球心即可得出反射的方向向量。（$drand48$是生成$[0,1)$之间的均匀随机数函数，一般linux下才有这个内建函数，windows下没有，所以我们就自己写了。）</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/lambertian.png" alt="lambertian"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rndm 0x100000000LL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rndc 0xB16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rnda 0x5DEECE66DLL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> seed = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">drand48</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        seed = (rnda * seed + rndc) &amp; <span class="number">0xFFFFFFFFFFFF</span>LL;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> x = seed &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span>  ((<span class="keyword">double</span>)x / (<span class="keyword">double</span>)rndm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">===============================================================</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Vector3D randomInUnitSphere()</span><br><span class="line">&#123;</span><br><span class="line">Vector3D pos;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">pos = Vector3D(drand48(), drand48(), drand48()) * <span class="number">2.0f</span> - Vector3D(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (pos.getSquaredLength() &gt;= <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============================================================</span><br><span class="line">    class Lambertian : <span class="keyword">public</span> Material</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Vector3D m_albedo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Lambertian(<span class="keyword">const</span> Vector3D &amp;a) : m_albedo(a) &#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Lambertian() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span></span></span><br><span class="line"><span class="function"><span class="params">            Vector3D &amp;attenuation, Ray &amp;scattered)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> Lambertian::scatter(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span><br><span class="line">        Vector3D &amp;attenuation, Ray &amp;scattered) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3D target = rec.m_position + rec.m_normal + Vector3D::randomInUnitSphere();</span><br><span class="line">        scattered = Ray(rec.m_position, target - rec.m_position);</span><br><span class="line">        attenuation = m_albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中的$m_albedo$为物体自身的反射颜色。</p><h3 id="3-2-金属镜面反射材质"><a href="#3-2-金属镜面反射材质" class="headerlink" title="3.2 金属镜面反射材质"></a>3.2 金属镜面反射材质</h3><p>&emsp;&emsp;金属的表面比较光滑，因而不会呈现出光线随机散射的情况。对于一个完美镜面的材质来说，入射光线和反射光线遵循反射定律，即光射到镜面上时，反射线跟入射线和法线在同一平面内，反射线和入射线分居法线两侧，并且与界面法线的夹角（分别叫做入射角和反射角）相等。反射角等于入射角。</p><p>&emsp;&emsp;求反射向量如下图4所示，比较简单，不再赘述。</p><p><img src="https://images0.cnblogs.com/blog/64257/201302/21171359-ff856efefd9b4ffdab25f0fc75d0f4e3.jpg" alt="img"></p><center> 图4 反射向量 </center><script type="math/tex; mode=display">R = I-2(N\cdot I)N \tag {5}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Vector3D <span class="title">reflect</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;ray, <span class="keyword">const</span> Vector3D &amp;normal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ray - normal * (ray.dotProduct(normal)) * <span class="number">2.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于一个完美镜面的金属材质来说，我们只需求出反射向量，然后按照这个反射向量递归下去就行了。但是有些金属并没有那么光滑，它的高光反射并没有那么锐利，为此我们对求出的反射向量做一定的扰动，使反射向量在一定的波瓣内随机，这个波瓣有多大由用户决定（波瓣越大则金属越粗糙）。废话不多说直接上图就明白了。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/metal.png" alt="metal"></p><p>&emsp;&emsp;我们在反射向量的终点上取一个给定半径的球体，在这个球体内随机选一个点作为新的反射向量的终点即可。这个半径的大小我们用$m_fuzz$变量存储，交给用户决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Metal</span> :</span> <span class="keyword">public</span> Material</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> m_fuzz;</span><br><span class="line">    Vector3D m_albedo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Metal(<span class="keyword">const</span> Vector3D &amp;a, <span class="keyword">const</span> <span class="keyword">float</span> &amp;f) : m_albedo(a), m_fuzz(f) &#123; <span class="keyword">if</span> (f &gt; <span class="number">1.0f</span>)m_fuzz = <span class="number">1.0f</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Metal() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Vector3D &amp;attenuation, Ray &amp;scattered)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Metal::scatter(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span><br><span class="line">    Vector3D &amp;attenuation, Ray &amp;scattered) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3D reflectedDir = Vector3D::reflect(in.getDirection(), rec.m_normal);</span><br><span class="line">    scattered = Ray(rec.m_position, reflectedDir + Vector3D::randomInUnitSphere() * m_fuzz);</span><br><span class="line">    attenuation = m_albedo;</span><br><span class="line">    <span class="keyword">return</span> (scattered.getDirection().dotProduct(rec.m_normal) &gt; <span class="number">0.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-透明玻璃折射材质"><a href="#3-3-透明玻璃折射材质" class="headerlink" title="3.3 透明玻璃折射材质"></a>3.3 透明玻璃折射材质</h3><p>&emsp;&emsp;对于水、玻璃和钻石等等物体的材质，光线照射到它们的表面时，它会把光线分成折射（也叫透射）光线和反射光线两部分。我们实现的材质采用随机的策略， 就是在折射和反射两个部分中随机选取一种。首先我们要根据入射向量、法线以及入射介质系数和折射介质系数计算折射方向向量，相比反射向量，推导计算的过程稍微有点复杂。折射表面有折射系数属性，根据Snell定律，如图5所示，入射角$\theta _L$和折射角$\theta _T$之间的关系有：</p><script type="math/tex; mode=display">\eta _Lsin\theta _L=\eta _rsin\theta _r \tag {6}</script><p><img src="https://img2018.cnblogs.com/blog/1226925/201901/1226925-20190115225200863-1896909595.png" alt="img"></p><center> 图5 折射向量的计算 </center><p>&emsp;&emsp;其中，$\eta _L$时光线离开的介质的折射系数，$\eta _r$是光线进入的介质的折射系数。空气的折射系数通常定位$1.00$，折射系数越大，则在两种不同介质之间光线弯曲效果越明显。$N$和$L$都是单位方向向量。折射向量$T$可为与法向量平行的向量$-Ncos\theta_T$和垂直的向量$-Gsin\theta _T$，$G$是上图所示的单位向量。而$perp_NL$与$G$向量平行，且$||perp_NL=sin\theta_L||$，故有：</p><script type="math/tex; mode=display">G=\frac{perp_NL}{sin\theta_L}=\frac{L-(N\cdot L)N}{sin\theta_L} \tag {7}</script><p>&emsp;&emsp;折射向量$T$可以表示为：</p><script type="math/tex; mode=display">T=-Ncos\theta_T-Gsin\theta_T\\=-Ncos\theta_T-\frac{sin\theta_T}{sin\theta_L}[L-(N\cdot L)N] \tag {8}</script><p>&emsp;&emsp;利用公式$(6)$，我们可以将上式中的正弦商替换为$\eta _L/\eta _T$，可得：</p><script type="math/tex; mode=display">T=-Ncos\theta_T-\frac{\eta _L}{\eta _T}[L-(N\cdot L)N] \tag {9}</script><p>&emsp;&emsp;注意到公式$(9)$中的$cos\theta_T$未知，用$\sqrt{1-sin^2\theta_T}$替换$cos\theta_T$，再用$(\eta_L/\eta_r)sin\theta_L$代替$sin\theta_T$，可得：</p><script type="math/tex; mode=display">T=-N\sqrt{1-\frac{\eta^2_L}{\eta^2_T}sin^2\theta_L}-\frac{\eta_L}{\eta_T}[L-(N\cdot L)N] \tag {10}</script><p>&emsp;&emsp;最后再用$1-cos^2\theta_L=1-(N\cdot L)^2$代替$sin^2\theta_L$，得到最终的表达式为：</p><script type="math/tex; mode=display">T=(\frac{\eta_L}{\eta_T}N\cdot L-\sqrt{1-\frac{\eta^2_L}{\eta^2_T}[1-(N\cdot L)^2]}\ )N-\frac{\eta_L}{\eta_T}L \tag {11}</script><p>&emsp;&emsp;如果$\eta_L&gt;\eta_T$，则上式平方根里的数值可能为负，这种情况发生在当光线从一个大折射率的介质进入一个小折射率的介质时，此时光线与表面之间的入射角较大。特别的，若仅当$sin\theta_L\leq \eta_r/\eta_L$时，公式$(11)$有效，如果平方根里的数值为负，则会出现所谓的全内反射现象，也就是光线不被折射，仅在介质内部反射。<strong>此外，需要注意的是，我们在程序实现中的入射向量与图5中$L$是相反的，所以需要将公式中的$(11)$的入射向量取反，如下所示：</strong></p><script type="math/tex; mode=display">T=\frac{\eta_L}{\eta_T}(L-(N\cdot L)N)-N\sqrt{1-\frac{\eta^2_L}{\eta^2_T}[1-(N\cdot L)^2]}\  \tag {12}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">refract</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;ray, <span class="keyword">const</span> Vector3D &amp;normal,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span> niOvernt, Vector3D &amp;refracted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3D uv = ray;</span><br><span class="line">    uv.normalize();</span><br><span class="line">    <span class="keyword">float</span> dt = uv.dotProduct(normal);</span><br><span class="line">    <span class="keyword">float</span> discriminant = <span class="number">1.0f</span> - niOvernt * niOvernt * (<span class="number">1.0f</span> - dt * dt);</span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        refracted = (uv - normal * dt) * niOvernt - normal * <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后创建一个$Dielectric$类，它有一个私有变量$refIdx$，它表面该物体的材质折射系数。在实现玻璃材质物体的散射函数$scatter$时，我们需要判断当前射线是从外部折射到内部还是从内部折射到外部，这可以通过计算入射向量与法向量的夹角余弦值来判断（通常法向量朝外），然后相应地将法向量的方向扭正。<strong>这里用$ni-over-nt$变量来记录$\frac{\eta_L}{\eta_T}$，我们知道空气的折射系数为$1.00$，所以从外面折射入物体内部时其取值等于$1.0/refIdx$，从内部折射到外部时取值为$refIdx$。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dielectric</span> :</span> <span class="keyword">public</span> Material</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> refIdx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Dielectric(<span class="keyword">float</span> ri) : refIdx(ri) &#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Dielectric() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span></span></span><br><span class="line"><span class="function"><span class="params">            Vector3D &amp;attenuation, Ray &amp;scattered)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> Dielectric::scatter(<span class="keyword">const</span> Ray &amp;in, <span class="keyword">const</span> HitRecord &amp;rec,</span><br><span class="line">        Vector3D &amp;attenuation, Ray &amp;scattered) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3D outward_normal;</span><br><span class="line">        Vector3D reflected = Vector3D::reflect(in.getDirection(), rec.m_normal);</span><br><span class="line">        <span class="keyword">float</span> ni_over_nt;</span><br><span class="line">        attenuation = Vector3D(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        Vector3D refracted;</span><br><span class="line">        <span class="keyword">float</span> reflect_prob;</span><br><span class="line">        <span class="keyword">float</span> cosine;</span><br><span class="line">        <span class="comment">// from inside to outside.</span></span><br><span class="line">        <span class="keyword">if</span> (in.getDirection().dotProduct(rec.m_normal) &gt; <span class="number">0.0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outward_normal = -rec.m_normal;</span><br><span class="line">            ni_over_nt = refIdx;</span><br><span class="line">            cosine = refIdx * in.getDirection().dotProduct(rec.m_normal) / in.getDirection().getLength();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// from outside to inside.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            outward_normal = rec.m_normal;</span><br><span class="line">            ni_over_nt = <span class="number">1.0</span> / refIdx;</span><br><span class="line">            cosine = -in.getDirection().dotProduct(rec.m_normal) / in.getDirection().getLength();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Vector3D::refract(in.getDirection(), outward_normal, ni_over_nt, refracted))</span><br><span class="line">        &#123;</span><br><span class="line">            reflect_prob = schlick(cosine, refIdx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            scattered = Ray(rec.m_position, reflected);</span><br><span class="line">            reflect_prob = <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (drand48() &lt; reflect_prob)</span><br><span class="line">            scattered = Ray(rec.m_position, reflected);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            scattered = Ray(rec.m_position, refracted);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里还要引入一个菲涅尔反射现象（仅对电介质和非金属表面有定义）。生活中，当我们以垂直的视角观察时，任何物体或者材质表面都有一个基础反射率(Base Reflectivity)，但是如果以一定的角度往平面上看的时候<a href="http://filmicgames.com/archives/557" target="_blank" rel="noopener">所有</a>反光都会变得明显起来。你可以自己尝试一下，用垂直的视角观察你自己的木制桌面，此时一定只有最基本的反射性。但是如果你从近乎与法线成90度的角度观察的话反光就会变得明显的多。如果从理想的90度的视角观察，所有的平面理论上来说都能完全的反射光线。这种现象因菲涅尔而闻名，并体现在了菲涅尔方程之中。菲涅尔方程是一个相当复杂的方程式，不过幸运的是菲涅尔方程可以用Fresnel-Schlick近似法求得近似解：</p><script type="math/tex; mode=display">F_{schlick(h,v,F_0)}=F_0+(1-F_0)(1-(h\cdot v))^5 \tag {13}</script><p>&emsp;&emsp;这里的$F_0$y由物体的折射系数得到，$h$是入射向量的负向量（因为我们定义的入射向量方向朝向交点），$v$则是交点处的法向量$v$，我们实现一个$schlick$函数如下：</p><pre><code>    float schlick(float cosine, float ref_idx) const    {        float r0 = (1.0f - ref_idx) / (1.0f + ref_idx);        r0 = r0 * r0;        return r0 + (1.0f - r0) * pow((1.0f - cosine), 5.0f);    }  </code></pre><p>&emsp;&emsp;我们还定义了一个reflect_prob变量，它介于0~1之间。我们根据reflect_prob与介于$[0,1)$的随机数做比较确定选择反射还是折射，这个还是很合理的，为什么呢？因为我们做了100次采样！那么我们可以理直气壮的说，我们的透明电介质真正做到了反射和折射的混合（除了全反射现象），而且这样符合光线照射透明电介质时，它会分裂为反射光线和折射光线的物理现象。（在程序中，教程作者在从内部折射到外部的时候将$cosine$值还乘上了个$refIdx$，这个操作没明白作者的意图，不乘上$refIdx$好像也没有发现渲染结果有明显的错误）。</p><p>&emsp;&emsp;最后，我们实现的玻璃球球内图像是颠倒的，这属于正常现象，原因如下图所示。光线经过两次折射最终导致了图像的颠倒。</p><p><img src="https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190103133145435-1573495559.png" alt="img"></p><h2 id="4、抗锯齿"><a href="#4、抗锯齿" class="headerlink" title="4、抗锯齿"></a>4、抗锯齿</h2><p>&emsp;&emsp;为了减少光线追踪方法的噪声点和锯齿，我们需要做一些抗锯齿处理。方法就是在计算一个像素坐标的像素值时，发射很多条射线，射线的取值范围在一个像素之内，然后将所有光线获取的像素值累加起来，最后除以总的采样数。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> samples = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = m_config.m_height - <span class="number">1</span>; row &gt;= <span class="number">0</span>; --row)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; m_config.m_width; ++col)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector4D color;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sps = <span class="number">0</span>; sps &lt; samples; ++sps)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> u = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(col + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_width);</span><br><span class="line">            <span class="keyword">float</span> v = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(row + drand48()) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_config.m_height);</span><br><span class="line">            Ray ray = camera.getRay(u, v);</span><br><span class="line">            color += tracing(ray, world, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        color /= <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(samples);</span><br><span class="line">        color.w = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="comment">// gamma correction.</span></span><br><span class="line">        color = Vector4D(<span class="built_in">sqrt</span>(color.x), <span class="built_in">sqrt</span>(color.y), <span class="built_in">sqrt</span>(color.z), color.w);</span><br><span class="line">        drawPixel(col, row, color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里还提到了gamma矫正，关于gamma矫正请看<a href="[https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/](https://learnopengl-cn.github.io/05 Advanced Lighting/02 Gamma Correction/">这里</a>)。我们对计算得到的像素做了一个简单的gamma矫正，gamma矫正系数取为$2.0$。不进行gamma矫正的话，渲染出来的图片明显偏暗。</p><h2 id="5、景深"><a href="#5、景深" class="headerlink" title="5、景深"></a>5、景深</h2><p>&emsp;&emsp;关于现实生活中摄像机的景深原理，我不再详细说明。在光线追踪中实现景深并不复杂。实现的方法：首先是射线的出发点视点，我们的眼睛（或者相机）不再是一个点而是眼睛所在的周围圆盘上的随机点，因为实际的相机是有摄像镜头的，摄像镜头是一个大光圈（很大一个镜片），并不是针孔类的东东，所以，我们要模拟镜头，就要随机采针孔周围的光圈点。</p><p><img src="https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190105005517891-2107468507.png" alt="img"></p><p>&emsp;&emsp;此外还有一个焦距的问题，我们一开始假设成像平面在摄像机坐标系的$z=-1$上，为了实现摄像机的景深效果，现在我们要引入现实摄像机的焦距概念。简单的说焦距是焦点到<a href="https://baike.baidu.com/item/面镜/1341446" target="_blank" rel="noopener">面镜</a>的中心点之间的距离。因此我们提供了一个焦距的参数给用户调整，以确定所需的景深效果。通常情况下焦距$focusDist$等于$length(target-cameraPos)$。这个时候我们将成像平面挪到了摄像机坐标系的$z=-focusDist$上，相应地需要调整计算成像平面的$halfHeight$（在前面的基础上再乘上个$focusDist$）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Camera::Camera(<span class="keyword">const</span> Vector3D &amp;cameraPos, <span class="keyword">const</span> Vector3D &amp;target,</span><br><span class="line">    <span class="keyword">float</span> vfov, <span class="keyword">float</span> aspect, <span class="keyword">float</span> aperture, <span class="keyword">float</span> focus_dist)</span><br><span class="line">&#123;</span><br><span class="line">    m_pos = cameraPos;</span><br><span class="line">    m_target = target;</span><br><span class="line">    m_fovy = vfov;</span><br><span class="line">    m_aspect = aspect;</span><br><span class="line">    m_lensRadius = aperture * <span class="number">0.5f</span>;</span><br><span class="line">    m_focusDist = focus_dist;</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Camera::update()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector3D <span class="title">worldUp</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    <span class="comment">// frustum.</span></span><br><span class="line">    <span class="keyword">float</span> theta = radians(m_fovy);</span><br><span class="line">    <span class="keyword">float</span> half_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">tan</span>(theta * <span class="number">0.5f</span>)) * m_focusDist;</span><br><span class="line">    <span class="keyword">float</span> half_width = m_aspect * half_height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera coordinate system.</span></span><br><span class="line">    m_axisZ = m_pos - m_target;</span><br><span class="line">    m_axisZ.normalize();</span><br><span class="line">    m_axisX = worldUp.crossProduct(m_axisZ);</span><br><span class="line">    m_axisX.normalize();</span><br><span class="line">    m_axisY = m_axisZ.crossProduct(m_axisX);</span><br><span class="line">    m_axisY.normalize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// view port.</span></span><br><span class="line">    m_lowerLeftCorner = m_pos - m_axisX * half_width</span><br><span class="line">        - m_axisY * half_height - m_axisZ * m_focusDist;</span><br><span class="line">    m_horizontal = m_axisX * <span class="number">2.0f</span> * half_width;</span><br><span class="line">    m_vertical = m_axisY * <span class="number">2.0f</span> * half_height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、程序结果"><a href="#三、程序结果" class="headerlink" title="三、程序结果"></a>三、程序结果</h1><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret1.png" alt="ret1"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret2.png" alt="ret2"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret3.png" alt="ret3"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret4.png" alt="ret4"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret5.png" alt="ret5"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret6.png" alt="ret6"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.9/blog/RayTracer-Basis/ret7.png" alt="ret7"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="https://www.cnblogs.com/jerrycg/p/4941359.html" target="_blank" rel="noopener">https://www.cnblogs.com/jerrycg/p/4941359.html</a></p><p>$[2]$ <a href="https://blog.csdn.net/baishuo8/article/details/81476422" target="_blank" rel="noopener">https://blog.csdn.net/baishuo8/article/details/81476422</a></p><p>$[3]$ <a href="https://blog.csdn.net/silangquan/article/details/8176855" target="_blank" rel="noopener">https://blog.csdn.net/silangquan/article/details/8176855</a></p><p>$[4]$ Peter Shirley. <a href="https://www.amazon.com/Ray-Tracing-Weekend-Minibooks-Book-ebook/dp/B01B5AODD8/ref=sr_1_1?ie=UTF8&amp;qid=1547695669&amp;sr=8-1&amp;keywords=Peter+Shirley" target="_blank" rel="noopener">Ray Tracing in One Weekend</a>. Amazon Digital Services LLC, January 26, 2016.</p><p>$[5]$ <a href="https://learnopengl-cn.github.io/07 PBR/01 Theory/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/07%20PBR/01%20Theory/</a></p><p>$[6]$ <a href="https://www.cnblogs.com/lv-anchoret/p/10223222.html" target="_blank" rel="noopener">https://www.cnblogs.com/lv-anchoret/p/10223222.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Ray Tracer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Ray Tracer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软渲染器Soft Renderer：光照着色篇（完结）</title>
      <link href="/2019/05/05/SoftRenderer-Shading/"/>
      <url>/2019/05/05/SoftRenderer-Shading/</url>
      
        <content type="html"><![CDATA[<p>在前面的博客我们已经实现了基本的三维渲染管线流程，这一章主要是在此基础上进行润色，不借助任何库实现obj模型导入、Bulin-Phong光照模型、摄像机漫游（第一人称摄像机、第三人称摄像机）。<strong>注意：初学者慎入</strong></p><p><div align="left"> <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/header.gif" height="400"></div></p><a id="more"></a><ul><li>obj模型导入</li><li>Blinn-Phong光照着色</li><li>虚拟场景漫游</li><li>程序结果</li><li>结语</li></ul><h1 id="一、obj模型导入"><a href="#一、obj模型导入" class="headerlink" title="一、obj模型导入"></a>一、obj模型导入</h1><p>&emsp;&emsp;obj模型文件（这里不是指c++编译得到的.o中间文件）是一种格式简单、清晰的模型文件，这种模型的格式非常容易解析。目前有一个非常流行的开源的模型导入库<a href="https://github.com/assimp/assimp" target="_blank" rel="noopener">Assimp</a>，封装了各种各样模型文件的加载，省去很多麻烦。而我因为一方面为了尽量避免引入第三方库，另一方面obj模型的导入不难，所以自己实现了一个obj加载类$ObjModel$。实现obj模型加载并不难，只需简单了解一下obj文件的格式即可。</p><p>&emsp;&emsp;obj文件格式有类数据，一类一行，分别以v、vt、vn和f开头。用记事本打开一个简单的obj文件，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/obj.png" alt="obj"></p><p>&emsp;&emsp;以v（即vertex的缩写）开头的一行分别为模型顶点的$x$、$y$、$z$坐标，以vt（即vertex texcoord的缩写）开头的一行分别为纹理坐标的$u$、$v$值，以vn（即vertex normal的缩写）开头的一行分别是法向量的$x$、$y$、$z$值。而f（即face的缩写）格式为v/vt/vn，其中对应的是各自的索引值，一个v/vt/vn描述了一个三角形顶点的顶点坐标、纹理坐标、法线向量，通常以f的一行有三列v/vt/vn，组成一个三角形面片。所以我们读取的时候按照这些开头标记读取即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjModel</span> :</span> <span class="keyword">public</span> Mesh</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vector3D minPoint, maxPoint;        <span class="comment">// Bounding box.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor.</span></span><br><span class="line">    ObjModel(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path);</span><br><span class="line">    <span class="keyword">virtual</span> ~ObjModel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Size setting.</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">setSizeToVector</span><span class="params">(<span class="keyword">float</span> sx, <span class="keyword">float</span> sy, <span class="keyword">float</span> sz)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">setSizeToMatrix</span><span class="params">(<span class="keyword">float</span> sx, <span class="keyword">float</span> sy, <span class="keyword">float</span> sz)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Obj file loader.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadObjFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ObjModel::loadObjFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// obj loader.</span></span><br><span class="line">    ifstream in;</span><br><span class="line">    in.open(path, ifstream::in);</span><br><span class="line">    <span class="keyword">if</span>(in.fail())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Fail to load obj-&gt;"</span> &lt;&lt; path &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    minPoint = Vector3D(+<span class="number">10000000000</span>,+<span class="number">10000000000</span>,+<span class="number">10000000000</span>);</span><br><span class="line">    maxPoint = Vector3D(<span class="number">-10000000000</span>,<span class="number">-10000000000</span>,<span class="number">-10000000000</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vector3D&gt; vertices;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vector3D&gt; normals;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vector2D&gt; texcoords;</span><br><span class="line">    <span class="keyword">while</span>(!in.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        getline(in, line);</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(line.c_str())</span></span>;</span><br><span class="line">        <span class="keyword">char</span> trash;</span><br><span class="line">        <span class="comment">//vertex</span></span><br><span class="line">        <span class="keyword">if</span>(!line.compare(<span class="number">0</span>, <span class="number">2</span>, <span class="string">"v "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            iss &gt;&gt; trash;</span><br><span class="line">            Vector3D vertex;</span><br><span class="line">            iss &gt;&gt; vertex.x;</span><br><span class="line">            iss &gt;&gt; vertex.y;</span><br><span class="line">            iss &gt;&gt; vertex.z;</span><br><span class="line">            vertices.push_back(vertex);</span><br><span class="line">            <span class="keyword">if</span>(minPoint.x &gt; vertex.x)minPoint.x = vertex.x;</span><br><span class="line">            <span class="keyword">if</span>(minPoint.y &gt; vertex.y)minPoint.y = vertex.y;</span><br><span class="line">            <span class="keyword">if</span>(minPoint.z &gt; vertex.z)minPoint.z = vertex.z;</span><br><span class="line">            <span class="keyword">if</span>(maxPoint.x &lt; vertex.x)maxPoint.x = vertex.x;</span><br><span class="line">            <span class="keyword">if</span>(maxPoint.y &lt; vertex.y)maxPoint.y = vertex.y;</span><br><span class="line">            <span class="keyword">if</span>(maxPoint.z &lt; vertex.z)maxPoint.z = vertex.z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// normal</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!line.compare(<span class="number">0</span>, <span class="number">3</span>, <span class="string">"vn "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            iss &gt;&gt; trash &gt;&gt; trash;</span><br><span class="line">            Vector3D normal;</span><br><span class="line">            iss &gt;&gt; normal.x;</span><br><span class="line">            iss &gt;&gt; normal.y;</span><br><span class="line">            iss &gt;&gt; normal.z;</span><br><span class="line">            normal.normalize();</span><br><span class="line">            normals.push_back(normal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// texcoord</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!line.compare(<span class="number">0</span>, <span class="number">3</span>, <span class="string">"vt "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            iss &gt;&gt; trash &gt;&gt; trash;</span><br><span class="line">            Vector2D texcoord;</span><br><span class="line">            iss &gt;&gt; texcoord.x;</span><br><span class="line">            iss &gt;&gt; texcoord.y;</span><br><span class="line">            texcoords.push_back(texcoord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// face</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!line.compare(<span class="number">0</span>, <span class="number">2</span>, <span class="string">"f "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            iss &gt;&gt; trash;</span><br><span class="line">            <span class="keyword">int</span> index[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">while</span>(iss &gt;&gt; index[<span class="number">0</span>] &gt;&gt; trash &gt;&gt; index[<span class="number">1</span>] &gt;&gt; trash &gt;&gt; index[<span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                Vertex data;</span><br><span class="line">                data.position = vertices[index[<span class="number">0</span>] - <span class="number">1</span>];</span><br><span class="line">                data.texcoord = texcoords[index[<span class="number">1</span>] - <span class="number">1</span>];</span><br><span class="line">                data.normal = normals[index[<span class="number">2</span>] - <span class="number">1</span>];</span><br><span class="line">                data.color = Vector4D(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">                m_indices.push_back(m_vertices.size());</span><br><span class="line">                m_vertices.push_back(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到这里继承了父类$Mesh$，这样读进来就作为一个网格类，能够传进渲染管线中渲染。测试读取了几个模型文件，效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/loader0.gif" alt="loader0"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/loader1.gif" alt="loader1"></p><h1 id="二、Blin-Phong光照着色"><a href="#二、Blin-Phong光照着色" class="headerlink" title="二、Blin-Phong光照着色"></a>二、Blin-Phong光照着色</h1><p>&emsp;&emsp;之前我们的着色器一直都是直接传输数据，没有做一些着色器计算，这里我们给渲染出来的模型加上光照着色。采用的光照模型是Blinn-Phong光照模型，并实现了两种着色器方法，分别是Gouraud着色、Phong着色。注意别混淆了光照模型和着色模型，光照模型是一种理论模型，着色模型则是具体的实现方式。Gouraud着色和Phong着色都是采用Blinn-Phong光照模型，差别在于两者在何处实现光照计算。</p><p>&emsp;&emsp;网上的LearnOpenGL教程很详细地介绍了Phong光照模型以及Blinn-Phong光照（Phong和Blinnn的差别只在于高光计算的一小部分），我就不再说太多这些方面的东西了，想具体了解的朋友请看<a href="[https://learnopengl-cn.github.io/02%20Lighting/02%20Basic%20Lighting/](https://learnopengl-cn.github.io/02 Lighting/02 Basic Lighting/">这里</a>)和<a href="[https://learnopengl-cn.github.io/05%20Advanced%20Lighting/01%20Advanced%20Lighting/](https://learnopengl-cn.github.io/05 Advanced Lighting/01 Advanced Lighting/">这里</a>)。概括起来，Phong光照模型包含环境光、漫反射光和镜面高光，其计算方式如下：</p><script type="math/tex; mode=display">I=K_aI_a+k_dI_ecos\alpha+k_sI_scos^n\lambda \tag {1}</script><p>&emsp;&emsp;其中的$k_a$、$k_d$和$k_s$分别为物体的环境光颜色、漫反射颜色和镜面高光颜色数，$n$是物体的高光读，而$I_a$、$I_e$和$I_s$是光源的环境光颜色、漫反射照亮的颜色和镜面反射的颜色。针对物体材质和光照的种类，我们创建一个$Material$和虚类$Light$，并把光照的计算过程抽象为一个函数$lighting$：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Material() = <span class="keyword">default</span>;</span><br><span class="line">    ~Material() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">double</span> m_shininess;</span><br><span class="line">    Vector3D m_ambient;</span><br><span class="line">    Vector3D m_diffuse;</span><br><span class="line">    Vector3D m_specular;</span><br><span class="line">    Vector3D m_reflect;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMaterial</span><span class="params">(Vector3D _amb, Vector3D _diff, Vector3D _spec, <span class="keyword">double</span> _shin)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_shininess = _shin;</span><br><span class="line">        m_ambient = _amb;</span><br><span class="line">        m_diffuse = _diff;</span><br><span class="line">        m_specular = _spec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Light() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Light() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">lighting</span><span class="params">(<span class="keyword">const</span> Material &amp;material,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;position,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;normal,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;eyeDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; ambient,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; diffuse,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; specular)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据光源的种类不同，通常有平行光、点光源和聚束光三类（关于这类光，请看LearnOpenGL的<a href="[https://learnopengl-cn.github.io/02%20Lighting/05%20Light%20casters/](https://learnopengl-cn.github.io/02 Lighting/05 Light casters/">这篇</a>)）。平行光的特点就是光线束都是平行的，因而只需记录平行光的方向即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectionalLight</span> :</span> <span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector3D m_ambient;</span><br><span class="line">    Vector3D m_diffuse;</span><br><span class="line">    Vector3D m_specular;</span><br><span class="line">    Vector3D m_direction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">lighting</span><span class="params">(<span class="keyword">const</span> Material &amp;material,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;position,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;normal,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;eyeDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; ambient,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; diffuse,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; specular)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDirectionalLight</span><span class="params">(Vector3D _amb, Vector3D _diff, Vector3D _spec,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Vector3D _dir)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ambient = _amb;</span><br><span class="line">        m_diffuse = _diff;</span><br><span class="line">        m_specular = _spec;</span><br><span class="line">        m_direction = _dir;</span><br><span class="line">        m_direction.normalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DirectionalLight::lighting(<span class="keyword">const</span> Material &amp;material,</span><br><span class="line">                                <span class="keyword">const</span> Vector3D &amp;position,</span><br><span class="line">                                <span class="keyword">const</span> Vector3D &amp;normal,</span><br><span class="line">                                <span class="keyword">const</span> Vector3D &amp;eyeDir,</span><br><span class="line">                                Vector3D &amp;ambient,</span><br><span class="line">                                Vector3D &amp;diffuse,</span><br><span class="line">                                Vector3D &amp;specular) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> diff = max(normal.dotProduct(-<span class="keyword">this</span>-&gt;m_direction), <span class="number">0.0f</span>);</span><br><span class="line">    Vector3D halfwayDir = eyeDir + <span class="keyword">this</span>-&gt;m_direction;</span><br><span class="line">    halfwayDir.normalize();</span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(eyeDir.dotProduct(halfwayDir), <span class="number">0.0f</span>), material.m_shininess);</span><br><span class="line">    ambient = m_ambient;</span><br><span class="line">    diffuse = m_diffuse * diff;</span><br><span class="line">    specular = m_specular * spec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;点光源则需要记录光源的位置，用以计算光照的方向。与平行光还有一点不同的是，点光源通常有个照明区域范围，光照的强度随着距离的增加而削弱，且这类减弱不是线性的。因此我们还要衰减因子，把计算得到的光照颜色再乘上这个衰减因子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointLight</span> :</span> <span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector3D m_ambient;</span><br><span class="line">    Vector3D m_diffuse;</span><br><span class="line">    Vector3D m_specular;</span><br><span class="line">    Vector3D m_position;</span><br><span class="line">    Vector3D m_attenuation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">lighting</span><span class="params">(<span class="keyword">const</span> Material &amp;material,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;position,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;normal,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;eyeDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; ambient,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; diffuse,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; specular)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPointLight</span><span class="params">(Vector3D _amb, Vector3D _diff, Vector3D _spec,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Vector3D _pos, Vector3D _atte)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ambient = _amb;</span><br><span class="line">        m_diffuse = _diff;</span><br><span class="line">        m_specular = _spec;</span><br><span class="line">        m_position = _pos;</span><br><span class="line">        m_attenuation = _atte;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PointLight::lighting(<span class="keyword">const</span> Material &amp;material,</span><br><span class="line">                          <span class="keyword">const</span> Vector3D &amp;position,</span><br><span class="line">                          <span class="keyword">const</span> Vector3D &amp;normal,</span><br><span class="line">                          <span class="keyword">const</span> Vector3D &amp;eyeDir,</span><br><span class="line">                          Vector3D &amp;ambient,</span><br><span class="line">                          Vector3D &amp;diffuse,</span><br><span class="line">                          Vector3D &amp;specular) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    ambient = <span class="keyword">this</span>-&gt;m_ambient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    Vector3D lightDir = (<span class="keyword">this</span>-&gt;m_position - position);</span><br><span class="line">    lightDir.normalize();</span><br><span class="line">    <span class="keyword">float</span> diff = max(normal.dotProduct(lightDir), <span class="number">0.0f</span>);</span><br><span class="line">    diffuse = <span class="keyword">this</span>-&gt;m_diffuse * diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    Vector3D halfwayDir = eyeDir + lightDir;</span><br><span class="line">    halfwayDir.normalize();</span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(eyeDir.dotProduct(halfwayDir), <span class="number">0.0f</span>), material.m_shininess);</span><br><span class="line">    specular = <span class="keyword">this</span>-&gt;m_specular * spec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attenuation</span></span><br><span class="line">    <span class="keyword">float</span> distance    = (<span class="keyword">this</span>-&gt;m_position - position).getLength();</span><br><span class="line">    <span class="keyword">float</span> attenuation = <span class="number">1.0</span> / (m_attenuation.x +</span><br><span class="line">                               m_attenuation.y * distance +</span><br><span class="line">                               m_attenuation.z * (distance * distance));</span><br><span class="line">    ambient  *= attenuation;</span><br><span class="line">    diffuse   *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;聚束光是一种比较特殊的光源（例如手电筒光、舞台灯光），它的特点就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。我们采用一个光源位置、照明方向和切光角来描述一个聚光灯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpotLight</span> :</span> <span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cutoff, m_outcutoff;</span><br><span class="line">    Vector3D m_ambient;</span><br><span class="line">    Vector3D m_diffuse;</span><br><span class="line">    Vector3D m_specular;</span><br><span class="line">    Vector3D m_position;</span><br><span class="line">    Vector3D m_direction;</span><br><span class="line">    Vector3D m_attenuation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">lighting</span><span class="params">(<span class="keyword">const</span> Material &amp;material,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;position,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;normal,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Vector3D &amp;eyeDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; ambient,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; diffuse,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Vector3D&amp; specular)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSpotLight</span><span class="params">(Vector3D _amb, Vector3D _diff, Vector3D _spec,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">double</span> _cut, Vector3D _pos, Vector3D _dir, Vector3D _atte)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_cutoff = <span class="built_in">cos</span>(_cut * M_PI/<span class="number">180.0</span>);</span><br><span class="line">        m_outcutoff = <span class="built_in">cos</span>((_cut + <span class="number">10.0</span>) * M_PI/<span class="number">180.0</span>);</span><br><span class="line">        m_ambient = _amb;</span><br><span class="line">        m_diffuse = _diff;</span><br><span class="line">        m_specular = _spec;</span><br><span class="line">        m_position = _pos;</span><br><span class="line">        m_direction = _dir;</span><br><span class="line">        m_attenuation = _atte;</span><br><span class="line">        m_direction.normalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SpotLight::lighting(<span class="keyword">const</span> Material &amp;material,</span><br><span class="line">                         <span class="keyword">const</span> Vector3D &amp;position,</span><br><span class="line">                         <span class="keyword">const</span> Vector3D &amp;normal,</span><br><span class="line">                         <span class="keyword">const</span> Vector3D &amp;eyeDir,</span><br><span class="line">                         Vector3D &amp;ambient,</span><br><span class="line">                         Vector3D &amp;diffuse,</span><br><span class="line">                         Vector3D &amp;specular) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    ambient = <span class="keyword">this</span>-&gt;m_ambient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    Vector3D lightDir = <span class="keyword">this</span>-&gt;m_position - position;</span><br><span class="line">    lightDir.normalize();</span><br><span class="line">    <span class="keyword">float</span> diff = max(normal.dotProduct(lightDir), <span class="number">0.0f</span>);</span><br><span class="line">    diffuse = <span class="keyword">this</span>-&gt;m_diffuse * diff ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    Vector3D halfwayDir = eyeDir + lightDir;</span><br><span class="line">    halfwayDir.normalize();</span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(eyeDir.dotProduct(halfwayDir), <span class="number">0.0f</span>), material.m_shininess);</span><br><span class="line">    specular = <span class="keyword">this</span>-&gt;m_specular * spec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spotlight (soft edges)</span></span><br><span class="line">    <span class="keyword">float</span> theta = lightDir.dotProduct(-<span class="keyword">this</span>-&gt;m_direction);</span><br><span class="line">    <span class="keyword">float</span> epsilon = (<span class="keyword">this</span>-&gt;m_cutoff - <span class="keyword">this</span>-&gt;m_outcutoff);</span><br><span class="line">    <span class="keyword">float</span> intensity = (theta - <span class="keyword">this</span>-&gt;m_outcutoff) / epsilon;</span><br><span class="line">    <span class="keyword">if</span>(intensity &lt; <span class="number">0.0f</span>)intensity = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(intensity &gt; <span class="number">1.0f</span>)intensity = <span class="number">1.0f</span>;</span><br><span class="line">    diffuse  *= intensity;</span><br><span class="line">    specular *= intensity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attenuation</span></span><br><span class="line">    <span class="keyword">float</span> distance    = (<span class="keyword">this</span>-&gt;m_position - position).getLength();</span><br><span class="line">    <span class="keyword">float</span> attenuation = <span class="number">1.0</span> / (m_attenuation.x +</span><br><span class="line">                               m_attenuation.y * distance +</span><br><span class="line">                               m_attenuation.z * (distance * distance));</span><br><span class="line">    ambient  *= attenuation;</span><br><span class="line">    diffuse  *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们就需要把光照计算集成到着色器中，这里提供了两种方式：光照计算集成到顶点着色器，即Gouraud着色方法，逐顶点光照，然后靠线性插值得到每个像素的光照颜色；光照计算集成到片元着色器，即Phong着色法，逐像素光照，根据插值得到的法向量做相应的计算。显然前者计算量少了很多，但是后者更为真实。我们建立一个$Gouraud$着色类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GouraudShader</span> :</span> <span class="keyword">public</span> BaseShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Those are not created by shader.</span></span><br><span class="line">    <span class="keyword">const</span> Light     *m_light;       <span class="comment">// Light.(just only one)</span></span><br><span class="line">    <span class="keyword">const</span> Material  *m_material;    <span class="comment">// Mesh material.</span></span><br><span class="line">    <span class="keyword">const</span> Texture2D *m_unit;        <span class="comment">// Texture unit.</span></span><br><span class="line"></span><br><span class="line">    Vector3D  m_eyePos;             <span class="comment">// Observer's position.</span></span><br><span class="line">    Matrix4x4 m_modelMatrix;        <span class="comment">// Model matrix.</span></span><br><span class="line">    Matrix4x4 m_viewMatrix;         <span class="comment">// View matrix.</span></span><br><span class="line">    Matrix4x4 m_projectMatrix;      <span class="comment">// Projection matrix.</span></span><br><span class="line">    Matrix4x4 m_invModelMatrix;     <span class="comment">// Inverse of model matrix for normal.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor.</span></span><br><span class="line">    GouraudShader();</span><br><span class="line">    <span class="keyword">virtual</span> ~GouraudShader() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shader stage.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> VertexOut <span class="title">vertexShader</span><span class="params">(<span class="keyword">const</span> Vertex &amp;in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector4D <span class="title">fragmentShader</span><span class="params">(<span class="keyword">const</span> VertexOut &amp;in)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shader setting.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bindShaderUnit</span><span class="params">(Texture2D *unit)</span></span>&#123;m_unit = unit;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span></span></span><br><span class="line"><span class="function">    </span>&#123;m_modelMatrix = world;m_invModelMatrix = m_modelMatrix.getInverseTranspose();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span></span>&#123;m_viewMatrix = view;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span></span>&#123;m_projectMatrix = project;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setMaterial</span><span class="params">(<span class="keyword">const</span> Material *material)</span></span>&#123;m_material = material;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setLight</span><span class="params">(<span class="keyword">const</span> Light *light)</span></span>&#123;m_light = light;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEyePos</span><span class="params">(<span class="keyword">const</span> Vector3D eye)</span></span>&#123;m_eyePos = eye;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里提一下关于顶点法向量的变换矩阵。我们目前已经有顶点的model矩阵，但是顶点做变换之后的法向量却不能直接乘上model矩阵获得。我们知道顶点的切线与法线相互垂直，因而它们的点乘为$0$，即有：</p><script type="math/tex; mode=display">N\cdot T = N^T*T = 0 \tag {2}</script><p>&emsp;&emsp;顶点切线必然随着模型矩阵的变换而变换，即模型矩阵为$M$，因而变换后的切线$T’=M\cdot T$。我们记变换后的法向量为$N’$，其正确的法线变换为$Q$，则$N’=Q\cdot N$，那么变换后$N’$和$T’$应该依旧保持垂直关系，依旧有$N’\cdot T’=(Q\cdot N)\cdot (M\cdot T)=(Q\cdot N)^T\cdot (M\cdot T)=N^T\cdot (Q^T\cdot M)\cdot T$，与公式$(2)$对比，我们只要令$Q^T\cdot M = I$结果为单位矩阵，则有$N’\cdot T’=N\cdot T = 0$。从而可得法线的变换矩阵为：</p><script type="math/tex; mode=display">Q= (N^{-1})^T \tag {3}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">VertexOut GouraudShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut result;</span><br><span class="line">    result.posTrans = m_modelMatrix * in.position;</span><br><span class="line">    result.posH = m_projectMatrix * m_viewMatrix * result.posTrans;</span><br><span class="line">    result.color = in.color;</span><br><span class="line">    result.texcoord = in.texcoord;</span><br><span class="line">    result.normal = m_invModelMatrix * Vector4D(in.normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gouraud shading.</span></span><br><span class="line">    <span class="keyword">if</span>(m_unit)</span><br><span class="line">        result.color = m_unit-&gt;sample(result.texcoord);</span><br><span class="line">    Vector3D _amb, _diff, _spec;</span><br><span class="line">    <span class="keyword">if</span>(m_light)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3D eyeDir = m_eyePos - result.posTrans;</span><br><span class="line">        eyeDir.normalize();</span><br><span class="line">        m_light-&gt;lighting(*m_material,</span><br><span class="line">                          result.posTrans,</span><br><span class="line">                          result.normal,</span><br><span class="line">                          eyeDir,</span><br><span class="line">                          _amb,</span><br><span class="line">                          _diff,</span><br><span class="line">                          _spec);</span><br><span class="line"></span><br><span class="line">        result.color.x *= (_amb.x + _diff.x + _spec.x);</span><br><span class="line">        result.color.y *= (_amb.y + _diff.y + _spec.y);</span><br><span class="line">        result.color.z *= (_amb.z + _diff.z + _spec.z);</span><br><span class="line">        result.color.w = <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oneDivZ to correct lerp.</span></span><br><span class="line">    result.oneDivZ = <span class="number">1.0</span> / result.posH.w;</span><br><span class="line">    result.posTrans *= result.oneDivZ;</span><br><span class="line">    result.texcoord *= result.oneDivZ;</span><br><span class="line">    result.color *= result.oneDivZ;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4D GouraudShader::fragmentShader(<span class="keyword">const</span> VertexOut &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    Vector4D litColor = in.color;</span><br><span class="line">    <span class="keyword">return</span> litColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Phong着色方式则在$fragmentShader$中实现光照计算，原理简单，不再赘述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhongShader</span> :</span> <span class="keyword">public</span> BaseShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Those are not created by shader.</span></span><br><span class="line">    <span class="keyword">const</span> Light     *m_light;       <span class="comment">// Light.(just only one)</span></span><br><span class="line">    <span class="keyword">const</span> Material  *m_material;    <span class="comment">// Mesh material.</span></span><br><span class="line">    <span class="keyword">const</span> Texture2D *m_unit;        <span class="comment">// Texture unit.</span></span><br><span class="line"></span><br><span class="line">    Vector3D  m_eyePos;             <span class="comment">// Observer's position.</span></span><br><span class="line">    Matrix4x4 m_modelMatrix;        <span class="comment">// Model matrix.</span></span><br><span class="line">    Matrix4x4 m_viewMatrix;         <span class="comment">// View matrix.</span></span><br><span class="line">    Matrix4x4 m_projectMatrix;      <span class="comment">// Projection matrix.</span></span><br><span class="line">    Matrix4x4 m_invModelMatrix;     <span class="comment">// Inverse of model matrix for normal.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor</span></span><br><span class="line">    PhongShader();</span><br><span class="line">    <span class="keyword">virtual</span> ~PhongShader() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shader stage.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> VertexOut <span class="title">vertexShader</span><span class="params">(<span class="keyword">const</span> Vertex &amp;in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector4D <span class="title">fragmentShader</span><span class="params">(<span class="keyword">const</span> VertexOut &amp;in)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shader setting.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bindShaderUnit</span><span class="params">(Texture2D *unit)</span></span>&#123;m_unit = unit;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span></span></span><br><span class="line"><span class="function">    </span>&#123;m_modelMatrix = world;m_invModelMatrix = m_modelMatrix.getInverseTranspose();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span></span>&#123;m_viewMatrix = view;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span></span>&#123;m_projectMatrix = project;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setMaterial</span><span class="params">(<span class="keyword">const</span> Material *material)</span></span>&#123;m_material = material;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setLight</span><span class="params">(<span class="keyword">const</span> Light *light)</span></span>&#123;m_light = light;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEyePos</span><span class="params">(<span class="keyword">const</span> Vector3D eye)</span></span>&#123;m_eyePos = eye;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VertexOut PhongShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut result;</span><br><span class="line">    result.posTrans = m_modelMatrix * in.position;</span><br><span class="line">    result.posH = m_projectMatrix * m_viewMatrix * result.posTrans;</span><br><span class="line">    result.color = in.color;</span><br><span class="line">    result.texcoord = in.texcoord;</span><br><span class="line">    result.normal = m_invModelMatrix * Vector4D(in.normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oneDivZ to correct lerp.</span></span><br><span class="line">    result.oneDivZ = <span class="number">1.0</span> / result.posH.w;</span><br><span class="line">    result.posTrans *= result.oneDivZ;</span><br><span class="line">    result.texcoord *= result.oneDivZ;</span><br><span class="line">    result.color *= result.oneDivZ;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4D PhongShader::fragmentShader(<span class="keyword">const</span> VertexOut &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    Vector4D litColor = in.color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gouraud shading.</span></span><br><span class="line">    <span class="keyword">if</span>(m_unit)</span><br><span class="line">        litColor = m_unit-&gt;sample(in.texcoord);</span><br><span class="line">    Vector3D _amb, _diff, _spec;</span><br><span class="line">    <span class="keyword">if</span>(m_light)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3D eyeDir = m_eyePos - in.posTrans;</span><br><span class="line">        eyeDir.normalize();</span><br><span class="line">        m_light-&gt;lighting(*m_material,</span><br><span class="line">                          in.posTrans,</span><br><span class="line">                          in.normal,</span><br><span class="line">                          eyeDir,</span><br><span class="line">                          _amb,</span><br><span class="line">                          _diff,</span><br><span class="line">                          _spec);</span><br><span class="line"></span><br><span class="line">        litColor.x *= (_amb.x + _diff.x + _spec.x);</span><br><span class="line">        litColor.y *= (_amb.y + _diff.y + _spec.y);</span><br><span class="line">        litColor.z *= (_amb.z + _diff.z + _spec.z);</span><br><span class="line">        litColor.w = <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> litColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图分别为Phong着色方式的平行光、点光源、聚束光效果：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/directionalLight.gif" alt="directionalLight"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/pointLight.gif" alt="pointLight"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/spotlight.gif" alt="spotlight"></p><h1 id="三、虚拟场景漫游"><a href="#三、虚拟场景漫游" class="headerlink" title="三、虚拟场景漫游"></a>三、虚拟场景漫游</h1><p>&emsp;&emsp;虚拟场景漫游是一个三维程序必不可少的，我们比较常用的虚拟摄像机有两类：第一人称摄像机、第三人生摄像机。第三人称摄像机又称为半上帝视角，一般的rpg游戏都是采用的第三人称视角。摄像机一般都是相应键盘按键、鼠标移动、鼠标滚轮事件，为了方便描述，我们创建一个$Camera3D$虚类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera3D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Local axis.</span></span><br><span class="line">    <span class="comment">// Here LocalForward should (0,0,-1).</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Vector3D LocalForward;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Vector3D LocalUp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Vector3D LocalRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctor/dtor.</span></span><br><span class="line">    Camera3D() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Camera3D()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Matrix4x4 <span class="title">getViewMatrix</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">getPosition</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key/Mouse reaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onKeyPress</span><span class="params">(<span class="keyword">char</span> key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onWheelMove</span><span class="params">(<span class="keyword">double</span> delta)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMouseMove</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY, <span class="built_in">std</span>::<span class="built_in">string</span> button)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1、第一人称相机"><a href="#1、第一人称相机" class="headerlink" title="1、第一人称相机"></a>1、第一人称相机</h2><p>&emsp;&emsp;LearnOpenGl的<a href="[https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/](https://learnopengl-cn.github.io/01 Getting started/09 Camera/">这篇</a>)对第一人称相机的构建做了的很详细的描述。<strong>不同的是，我不再采用欧拉角来描述渲染，而是采用了四元数（关于四元数，请看知乎的<a href="https://www.zhihu.com/question/23005815/answer/33971127" target="_blank" rel="noopener">这篇</a>）。</strong>理解了四元数，采用欧拉角反而比较繁琐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FPSCamera</span> :</span> <span class="keyword">public</span> Camera3D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> m_dirty;       <span class="comment">// Should update or not.</span></span><br><span class="line">    Vector3D m_translation;     <span class="comment">// Camera's translation.</span></span><br><span class="line">    Quaternion m_rotation;      <span class="comment">// Camera's rotation.</span></span><br><span class="line">    Matrix4x4 m_viewMatrix;     <span class="comment">// View Matrix.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor</span></span><br><span class="line">    FPSCamera(Vector3D _pos);</span><br><span class="line">    <span class="keyword">virtual</span> ~FPSCamera() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">getPosition</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_translation;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Matrix4x4 <span class="title">getViewMatrix</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key/Mouse reaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onKeyPress</span><span class="params">(<span class="keyword">char</span> key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onWheelMove</span><span class="params">(<span class="keyword">double</span> delta)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMouseMove</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY, <span class="built_in">std</span>::<span class="built_in">string</span> button)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform camera's axis.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">translate</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;dt)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;axis, <span class="keyword">float</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTranslation</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotation</span><span class="params">(<span class="keyword">const</span> Quaternion &amp;r)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query for camera's axis.</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">forward</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">up</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">right</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FPSCamera::onKeyPress(<span class="keyword">char</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(key)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(forward() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(-forward() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(-right() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(+right() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Q'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(up() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">        <span class="keyword">this</span>-&gt;translate(-up() * <span class="number">0.2f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FPSCamera::onWheelMove(<span class="keyword">double</span> delta)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// nothing now.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FPSCamera::onMouseMove(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY, <span class="built_in">std</span>::<span class="built_in">string</span> button)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> speed = <span class="number">0.1f</span>;</span><br><span class="line">    deltaX *= speed;</span><br><span class="line">    deltaY *= speed;</span><br><span class="line">    <span class="keyword">this</span>-&gt;rotate(LocalUp, -deltaX);</span><br><span class="line">    <span class="keyword">this</span>-&gt;rotate(right(), -deltaY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、第三人称摄像机"><a href="#2、第三人称摄像机" class="headerlink" title="2、第三人称摄像机"></a>2、第三人称摄像机</h2><p>&emsp;&emsp;第三人称有一个固定的目标，这个目标通常就是玩家操控的物体。摄像机可以拉远拉近、围绕目标在$xz$平面旋转、绕$x$轴上下旋转，而且摄像机永远在玩家的上方（即俯视）。为此，我们用$distance$（摄像机到玩家的距离）、$pitch$（绕$x$轴的旋转角）、$yaw$（绕$y$轴的旋转角）来获取摄像机的位置，最后获取了摄像机的位置后我们就可以直接用$LookAt$矩阵获得视图矩阵。更多关于第三人称摄像机方面的细节请看youtube上的这个<a href="https://www.youtube.com/watch?v=PoxDDZmctnU&amp;list=PLRIWtICgwaX0u7Rf9zkZhLoLuZVfUksDP&amp;index=19" target="_blank" rel="noopener">视频</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TPSCamera</span> :</span> <span class="keyword">public</span> Camera3D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> m_dirty;               <span class="comment">// Should update or not.</span></span><br><span class="line">    Vector3D m_cameraPos;               <span class="comment">// Camera's position.</span></span><br><span class="line">    Transform3D m_player;               <span class="comment">// Player's transformation.</span></span><br><span class="line">    Matrix4x4 m_viewMatrix;             <span class="comment">// View matrix.</span></span><br><span class="line">    <span class="keyword">double</span> m_yaw, m_pitch, m_distance;  <span class="comment">// yaw, pitch and distance to player's space.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor/dtor.</span></span><br><span class="line">    TPSCamera(Vector3D target);</span><br><span class="line">    <span class="keyword">virtual</span> ~TPSCamera() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter.</span></span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getPlayerMatrix</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Matrix4x4 <span class="title">getViewMatrix</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector3D <span class="title">getPosition</span><span class="params">()</span> </span>&#123;update();<span class="keyword">return</span> m_cameraPos;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key/Mouse reaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onKeyPress</span><span class="params">(<span class="keyword">char</span> key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onWheelMove</span><span class="params">(<span class="keyword">double</span> delta)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMouseMove</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY, <span class="built_in">std</span>::<span class="built_in">string</span> button)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Update view matrix.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TPSCamera::onKeyPress(<span class="keyword">char</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> speed = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">switch</span>(key)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_player.translate(-m_player.forward() * <span class="number">0.1f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_player.translate(+m_player.forward() * <span class="number">0.1f</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_player.rotate(m_player.up(), +speed);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_player.rotate(m_player.up(), -speed);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TPSCamera::onWheelMove(<span class="keyword">double</span> delta)</span><br><span class="line">&#123;</span><br><span class="line">    m_dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">double</span> speed = <span class="number">0.01</span>;</span><br><span class="line">    m_distance += -speed * delta;</span><br><span class="line">    <span class="keyword">if</span>(m_distance &gt; <span class="number">35.0</span>)m_distance = <span class="number">35.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m_distance &lt; <span class="number">5.00</span>)m_distance = <span class="number">5.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TPSCamera::onMouseMove(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY, <span class="built_in">std</span>::<span class="built_in">string</span> button)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> speed = <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">if</span>(button == <span class="string">"RIGHT"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_pitch += speed * deltaY;</span><br><span class="line">        <span class="keyword">if</span>(m_pitch &lt; <span class="number">0.0</span>)m_pitch = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m_pitch &gt; <span class="number">89.9</span>)m_pitch = <span class="number">89.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(button == <span class="string">"LEFT"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_dirty = <span class="literal">true</span>;</span><br><span class="line">        m_yaw   += -speed * deltaX;</span><br><span class="line">        <span class="built_in">fmod</span>(m_yaw, <span class="number">360.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TPSCamera::update()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_dirty)</span><br><span class="line">    &#123;</span><br><span class="line">        m_dirty = <span class="literal">false</span>;</span><br><span class="line">        Vector3D target = m_player.translation();</span><br><span class="line">        <span class="keyword">float</span> height = m_distance * <span class="built_in">sin</span>(radians(m_pitch));</span><br><span class="line">        <span class="keyword">float</span> horizon = m_distance * <span class="built_in">cos</span>(radians(m_pitch));</span><br><span class="line">        Vector3D _playerRot = m_player.rotation().eulerAngle();</span><br><span class="line">        _playerRot.y = <span class="built_in">fmod</span>(_playerRot.y, <span class="number">360</span>);</span><br><span class="line">        m_cameraPos.y = target.y + height;</span><br><span class="line">        m_cameraPos.x = target.x + horizon * <span class="built_in">sin</span>(radians(m_yaw));</span><br><span class="line">        m_cameraPos.z = target.z + horizon * <span class="built_in">cos</span>(radians(m_yaw));</span><br><span class="line">        m_viewMatrix.setLookAt(m_cameraPos, m_player.translation(), LocalUp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、程序结果"><a href="#四、程序结果" class="headerlink" title="四、程序结果"></a>四、程序结果</h1><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/ret1.gif" alt="ret1"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/ret2.gif" alt="ret2"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/ret3.gif" alt="ret3"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.8/blog/SoftRenderer-Shading/ret4.gif" alt="ret4"></p><h1 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h1><p>&emsp;&emsp;软渲染器的搭建就此告一段落，不借助任何图形库从零开始搭建这么一个渲染管线的初衷是为了更加深入地了解当前三维渲染的整个流程，很多理论东西需要实践才能彻底地理解。这么几天关于搭建软渲染器的折腾让我收获不少，这为以后的图形学道路打下了深厚的基础。目前我实现的软渲染管线已经包含了一个传统固定管线的基本功能，我借助一些工具统计得软渲染管线的核心代码（不包括空行、注释）共2838行。不再打算加入更多的功能特性如透明融合、阴影等等，因为没必要了。相关的全部源代码已经提交到github上，请点<a href="https://github.com/ZeusYang/Soft-Renderer" target="_blank" rel="noopener">这里</a>。</p><p>&emsp;&emsp;由于本人的知识水平有限，若网友发现任何bug或者博文叙述错误，欢迎指正，感谢！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="https://learnopengl-cn.github.io/02 Lighting/02 Basic Lighting/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/02%20Lighting/02%20Basic%20Lighting/</a></p><p>$[2]$ <a href="https://learnopengl-cn.github.io/01 Getting started/09 Camera/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/</a></p><p>$[3]$ <a href="https://www.youtube.com/watch?v=PoxDDZmctnU&amp;list=PLRIWtICgwaX0u7Rf9zkZhLoLuZVfUksDP&amp;index=19" target="_blank" rel="noopener">https://www.youtube.com/watch?v=PoxDDZmctnU&amp;list=PLRIWtICgwaX0u7Rf9zkZhLoLuZVfUksDP&amp;index=19</a></p><p>$[4]$ <a href="https://github.com/ssloy/tinyrenderer/wiki" target="_blank" rel="noopener">https://github.com/ssloy/tinyrenderer/wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Soft Renderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Soft Renderer </tag>
            
            <tag> 3D pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软渲染器Soft Renderer：进击三维篇</title>
      <link href="/2019/05/02/SoftRenderer-3DPipeline/"/>
      <url>/2019/05/02/SoftRenderer-3DPipeline/</url>
      
        <content type="html"><![CDATA[<p>有了自己实现好的的3D数学库和一个基本的光栅化渲染框架，就可以开始向这个渲染框架填充内容了。本章内容主要关于3维渲染管线的实现、深度测试、背面剔除、几何裁剪、透视纹理映射，这些内容早已被渲染API集成。学习和实现这些算法，是为了彻底了解三维物体的整个渲染流程。<strong>注意：初学者慎入</strong></p><p><div align="left"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/header.gif" height="400"></div></p><a id="more"></a><ul><li>进入三维世界</li><li>裁剪、剔除优化</li><li>透视纹理映射、采样</li><li>程序结果</li></ul><h1 id="一、进入三维世界"><a href="#一、进入三维世界" class="headerlink" title="一、进入三维世界"></a>一、进入三维世界</h1><p>&emsp;&emsp;尽管二维的屏幕只能显示二维的像素，但是我们可以通过将三维的物体变换到二维的屏幕上，从而渲染出三维空间的一个投影面。这与我们人类的视觉系统类似，视网膜上最终获取的也只是三维空间某个角度下的投影。为了让三维物体正确地显示到屏幕上，我们需要借助一系列的坐标空间变换。</p><h2 id="1、坐标系统"><a href="#1、坐标系统" class="headerlink" title="1、坐标系统"></a>1、坐标系统</h2><p>&emsp;&emsp;在渲染管线中，三维物体的顶点在最终转换为屏幕坐标之前会被变换到多个坐标系统，这其中有几个过渡性的坐标系，使得整个变换流程逻辑清晰、便于理解。此外在某些特定情况下在这些特定的坐标系中，一些操作更加容易、方便和<strong>灵活</strong>。通常，渲染管线有$5$个不同的坐标系统，分别是局部空间、世界空间、视觉空间、裁剪空间和屏幕空间，以下是<a href="[https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#_1](https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/#_1">LearnOpenGL CN</a>)的原话：</p><p><img src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png" alt="coordinate_systems"></p><blockquote><ol><li><p>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</p></li><li><p>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</p></li><li><p>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</p></li><li><p>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</p></li><li><p>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段</p></li></ol></blockquote><p>&emsp;&emsp;通过以上的几个步骤，三维的物体坐标最终变换到了屏幕的坐标上，其中视图矩阵和投影矩阵的构建较为复杂一点，前面我的博文<a href="https://yangwc.com/2019/05/01/SoftRenderer-Math/" target="_blank" rel="noopener">软渲染器Soft Renderer：3D数学篇</a>已经推导过这两个矩阵，这里就不再赘述了。若想查看更多关于坐标系统的内容，请查看<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">LearnOpenGL CN</a>的这篇文章：<a href="[https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#_1](https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/#_1">坐标系统</a>)。坐标变换是一般发生在顶点着色器以及顶点着色器输出到光栅化这一阶段，视口变换在顶点着色器输出之后，不在着色器中进行（视口变换已经在前面的光栅化篇提到过了）。所以为了实现坐标变换，我们的着色器要存储$model$、$view$、$project$这三个矩阵，在$SimpleShader$中添加相关的成员变量及方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleShader</span> :</span> <span class="keyword">public</span> BaseShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Matrix4x4 m_modelMatrix;</span><br><span class="line">    Matrix4x4 m_viewMatrix;</span><br><span class="line">    Matrix4x4 m_projectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ......</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setModelMatrix(<span class="keyword">const</span> Matrix4x4 &amp;world)</span><br><span class="line">&#123;</span><br><span class="line">    m_modelMatrix = world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setViewMatrix(<span class="keyword">const</span> Matrix4x4 &amp;view)</span><br><span class="line">&#123;</span><br><span class="line">    m_viewMatrix = view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setProjectMatrix(<span class="keyword">const</span> Matrix4x4 &amp;project)</span><br><span class="line">&#123;</span><br><span class="line">    m_projectMatrix = project;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样外部要渲染时，应该向着色器输入这三个矩阵。然后在我们的顶点着色器中填入相关的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VertexOut SimpleShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut result;</span><br><span class="line">    result.posTrans = m_modelMatrix * in.position;</span><br><span class="line">    result.posH = m_projectMatrix * m_viewMatrix * result.posTrans;</span><br><span class="line">    result.color = in.color;</span><br><span class="line">    result.normal = in.normal;</span><br><span class="line">    result.texcoord = in.texcoord;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;$VertexOut$是前面文章定义的顶点着色器输出的类，它存储投影后的顶点$posH$、世界空间中的顶点$posTrans$、物体的颜色、顶点法线以及纹理坐标。<strong>接着在视口变换并送入光栅化部件之前执行透视除法，即直接将裁剪空间的顶点坐标除以它的第四个分量$w$即可</strong>。然后我们在外部的渲染循环中设置模型矩阵、视图矩阵已经投影矩阵，就能显示出三维的立体感了，以我们前一章画的三角形为例（gif录制的好像有bug，出现绿色它就给我录制成这个模糊的鬼样，实际上是非常清晰，不是渲染的锅）。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/triangle.gif" alt="triangle"></p><p>&emsp;&emsp;进入3D世界，怎么能少了3D渲染的”hello world!”——立方体呢？在$Mesh.h$手动创建一个立方体的网格数据，然后用立方体替换掉上面丑陋的三角形：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Mesh::asBox(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">double</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">    vertices.resize(<span class="number">24</span>);</span><br><span class="line">    indices.resize(<span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> halfW = width * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">float</span> halfH = height * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">float</span> halfD = depth * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="comment">//front</span></span><br><span class="line">    vertices[<span class="number">0</span>].position = Vector3D(halfW, halfH, halfD);</span><br><span class="line">    vertices[<span class="number">0</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].position = Vector3D(-halfW, halfH, halfD);</span><br><span class="line">    vertices[<span class="number">1</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].position = Vector3D(-halfW,-halfH, halfD);</span><br><span class="line">    vertices[<span class="number">2</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">3</span>].position = Vector3D(halfW, -halfH, halfD);</span><br><span class="line">    vertices[<span class="number">3</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">3</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">3</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    <span class="comment">//left</span></span><br><span class="line">    vertices[<span class="number">4</span>].position = Vector3D(-halfW, +halfH, halfD);</span><br><span class="line">    vertices[<span class="number">4</span>].normal = Vector3D(<span class="number">-1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">4</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">4</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">5</span>].position = Vector3D(-halfW, +halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">5</span>].normal = Vector3D(<span class="number">-1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">5</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">5</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">6</span>].position = Vector3D(-halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">6</span>].normal = Vector3D(<span class="number">-1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">6</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">6</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">7</span>].position = Vector3D(-halfW, -halfH, halfD);</span><br><span class="line">    vertices[<span class="number">7</span>].normal = Vector3D(<span class="number">-1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">7</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">7</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    <span class="comment">//back</span></span><br><span class="line">    vertices[<span class="number">8</span>].position = Vector3D(-halfW, +halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">8</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">-1.f</span>);</span><br><span class="line">    vertices[<span class="number">8</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">8</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">9</span>].position = Vector3D(+halfW, +halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">9</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">-1.f</span>);</span><br><span class="line">    vertices[<span class="number">9</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">9</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">10</span>].position = Vector3D(+halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">10</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">-1.f</span>);</span><br><span class="line">    vertices[<span class="number">10</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">10</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">11</span>].position = Vector3D(-halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">11</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">-1.f</span>);</span><br><span class="line">    vertices[<span class="number">11</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">11</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    <span class="comment">//right</span></span><br><span class="line">    vertices[<span class="number">12</span>].position = Vector3D(halfW, +halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">12</span>].normal = Vector3D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">12</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">12</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">13</span>].position = Vector3D(halfW, +halfH, +halfD);</span><br><span class="line">    vertices[<span class="number">13</span>].normal = Vector3D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">13</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">13</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">14</span>].position = Vector3D(halfW, -halfH, +halfD);</span><br><span class="line">    vertices[<span class="number">14</span>].normal = Vector3D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">14</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">14</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">15</span>].position = Vector3D(halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">15</span>].normal = Vector3D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">15</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">15</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    <span class="comment">//top</span></span><br><span class="line">    vertices[<span class="number">16</span>].position = Vector3D(+halfW, halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">16</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">16</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">16</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">17</span>].position = Vector3D(-halfW, halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">17</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">17</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">17</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">18</span>].position = Vector3D(-halfW, halfH, halfD);</span><br><span class="line">    vertices[<span class="number">18</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">18</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">18</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">19</span>].position = Vector3D(+halfW, halfH, halfD);</span><br><span class="line">    vertices[<span class="number">19</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">19</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">19</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    <span class="comment">//down</span></span><br><span class="line">    vertices[<span class="number">20</span>].position = Vector3D(+halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">20</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">-1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">20</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">20</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">21</span>].position = Vector3D(+halfW, -halfH, +halfD);</span><br><span class="line">    vertices[<span class="number">21</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">-1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">21</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">21</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">22</span>].position = Vector3D(-halfW, -halfH, +halfD);</span><br><span class="line">    vertices[<span class="number">22</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">-1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">22</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">22</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">23</span>].position = Vector3D(-halfW, -halfH, -halfD);</span><br><span class="line">    vertices[<span class="number">23</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">-1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">23</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">23</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//front</span></span><br><span class="line">    indices[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    indices[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    indices[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    indices[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    indices[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">    indices[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//left</span></span><br><span class="line">    indices[<span class="number">6</span>] = <span class="number">4</span>;</span><br><span class="line">    indices[<span class="number">7</span>] = <span class="number">5</span>;</span><br><span class="line">    indices[<span class="number">8</span>] = <span class="number">6</span>;</span><br><span class="line">    indices[<span class="number">9</span>] = <span class="number">4</span>;</span><br><span class="line">    indices[<span class="number">10</span>] = <span class="number">6</span>;</span><br><span class="line">    indices[<span class="number">11</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//back</span></span><br><span class="line">    indices[<span class="number">12</span>] = <span class="number">8</span>;</span><br><span class="line">    indices[<span class="number">13</span>] = <span class="number">9</span>;</span><br><span class="line">    indices[<span class="number">14</span>] = <span class="number">10</span>;</span><br><span class="line">    indices[<span class="number">15</span>] = <span class="number">8</span>;</span><br><span class="line">    indices[<span class="number">16</span>] = <span class="number">10</span>;</span><br><span class="line">    indices[<span class="number">17</span>] = <span class="number">11</span>;</span><br><span class="line">    <span class="comment">//right</span></span><br><span class="line">    indices[<span class="number">18</span>] = <span class="number">12</span>;</span><br><span class="line">    indices[<span class="number">19</span>] = <span class="number">13</span>;</span><br><span class="line">    indices[<span class="number">20</span>] = <span class="number">14</span>;</span><br><span class="line">    indices[<span class="number">21</span>] = <span class="number">12</span>;</span><br><span class="line">    indices[<span class="number">22</span>] = <span class="number">14</span>;</span><br><span class="line">    indices[<span class="number">23</span>] = <span class="number">15</span>;</span><br><span class="line">    <span class="comment">//top</span></span><br><span class="line">    indices[<span class="number">24</span>] = <span class="number">16</span>;</span><br><span class="line">    indices[<span class="number">25</span>] = <span class="number">17</span>;</span><br><span class="line">    indices[<span class="number">26</span>] = <span class="number">18</span>;</span><br><span class="line">    indices[<span class="number">27</span>] = <span class="number">16</span>;</span><br><span class="line">    indices[<span class="number">28</span>] = <span class="number">18</span>;</span><br><span class="line">    indices[<span class="number">29</span>] = <span class="number">19</span>;</span><br><span class="line">    <span class="comment">//down</span></span><br><span class="line">    indices[<span class="number">30</span>] = <span class="number">20</span>;</span><br><span class="line">    indices[<span class="number">31</span>] = <span class="number">21</span>;</span><br><span class="line">    indices[<span class="number">32</span>] = <span class="number">22</span>;</span><br><span class="line">    indices[<span class="number">33</span>] = <span class="number">20</span>;</span><br><span class="line">    indices[<span class="number">34</span>] = <span class="number">22</span>;</span><br><span class="line">    indices[<span class="number">35</span>] = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果我们就得到一个如下面所示的奇怪的立方体：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/cube0_s.png" alt="cube0_s"></p><p>&emsp;&emsp;下面是动图gif（<strong>再重复一遍，模糊不是渲染的锅</strong>）：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/cube0.gif" alt="cube0"></p><p>&emsp;&emsp;这的确有点像是一个立方体，但又有种说不出的奇怪。立方体的某些本应被遮挡住的面被绘制在了这个立方体其他面之上。出现这样结果的原因是因为我们的软渲染器是对一个一个三角形进行绘制的，而且计算像素时时直接覆盖而不管这个像素是否已经有其他值了，所以一个像素的值完全取决于最后赋予它的$RGBA$。除非渲染管线自动按照从远到近的顺序（这类算法有画家算法、空间分割BSP树算法）绘制三角形，否则直接覆盖的方法获取不了正确的像素值。正确渲染结果应该是像素的$RGBA$值为最靠近视点的片元值，一种常用的技术是借助第三维信息——深度来对每个相同位置的不同片元做深度的比较，并且取深度较低的那一个。</p><h2 id="2、深度测试"><a href="#2、深度测试" class="headerlink" title="2、深度测试"></a>2、深度测试</h2><p>&emsp;&emsp;为了获取正确的三维渲染结果，我们采用一种<strong>深度缓冲</strong>的技术。深度缓冲存储深度信息，它的分辨率应该与颜色缓冲一致，深度值存储在每个片段里面（作为片段的<strong>z</strong>值），当片段想要输出它的颜色时，我们将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为<strong>深度测试</strong>。在OpenGL和DirectX这些渲染API中，深度缓冲会自动执行而无需用户操作。在我们的软渲染器中，我们自己实现一个这样的深度测试，算法原理很简单，但是效果非常不错！</p><p>&emsp;&emsp;深度缓冲通常和颜色缓冲一起，作为帧缓冲的附件，我们在帧缓冲类中增加深度缓冲相关的变量、方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; m_depthBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearColorAndDepthBuffer</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getDepth</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;y)</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawDepth</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;y, <span class="keyword">const</span> <span class="keyword">double</span> &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameBuffer::clearColorAndDepthBuffer(<span class="keyword">const</span> Vector4D &amp;color)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// fill the color buffer and depth buffer.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> red = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.x);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> green = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.y);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> blue = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.z);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> alpha = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> row = <span class="number">0</span>;row &lt; m_height;++ row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> col = <span class="number">0</span>;col &lt; m_width;++ col)</span><br><span class="line">        &#123;</span><br><span class="line">            m_depthBuffer[row*m_width+col] = <span class="number">1.0f</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> FrameBuffer::getDepth(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;y) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m_width || y &lt; <span class="number">0</span> || y &gt;= m_height)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">return</span> m_depthBuffer[y*m_width+x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameBuffer::drawDepth(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;y, <span class="keyword">const</span> <span class="keyword">double</span> &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m_width || y &lt; <span class="number">0</span> || y &gt;= m_height)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index = y*m_width + x;</span><br><span class="line">    m_depthBuffer[index] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们对于每一个片元，我们获取深度缓冲中相应的数值并进行比较。在这之前，我们还要简单回顾一下在透视投影矩阵中深度值的非线性映射，在前面的<a href="https://yangwc.com/2019/05/01/SoftRenderer-Math/" target="_blank" rel="noopener">数学篇</a>中我们知道透视投影矩阵有如下形式：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{1}{aspect*tan(fovy/2)}&0&0&0\\0&\frac{1}{tan(fovy/2)}&0&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)</script><p>&emsp;&emsp;因而视图空间中的深度信息$z_e$和标准化设备空间中的深度信息$z_n$关系为：</p><script type="math/tex; mode=display">z_n=(-\frac{f+n}{f-n}z_e-\frac{2fn}{f-n})/{-z_e}=\frac{2fn}{z_e(f-n)}+\frac{f+n}{f-n} \tag {1}</script><p>&emsp;&emsp;可以看到$z_e$d到$z_n$是一种从$[-f, -n]$到$[-1,1]$的非线性映射。当$z_e$比较小的时候，公式$(1)$有很高的精度；当$z_e$比较大的时候，公式$(1)$应为取值精度降低。这个关系可以直观地从下图的函数曲线看出来：</p><p><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix07.png" alt="Comparison of depth precision"></p><p>&emsp;&emsp;可以看到，深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。$z_n$取值为$[-1,1]$，我们最后将其简单地映射到$[0,1]$，这一步我放在透视除法后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::perspectiveDivision(VertexOut &amp;target)</span><br><span class="line">&#123;</span><br><span class="line">    target.posH.x /= target.posH.w;</span><br><span class="line">    target.posH.y /= target.posH.w;</span><br><span class="line">    target.posH.z /= target.posH.w;</span><br><span class="line">    target.posH.w = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">// map from [-1,1] to [0,1]</span></span><br><span class="line">    target.posH.z = (target.posH.z+<span class="number">1.0f</span>) * <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在写入深度缓冲之前应该要清除上一帧的深度缓冲，全部置$1.0f$即可，我把这一步和清除颜色缓冲放一起了，即前面的帧缓冲类的$clearColorAndDepthBuffer$方法。在光栅化步骤，获取每个片元的屏幕位置，查找深度缓并比较，若小于当前深度缓冲中获取的值，则通过深度测试并写入深度缓冲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::scanLinePerRow(<span class="keyword">const</span> VertexOut &amp;left, <span class="keyword">const</span> VertexOut &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// scan the line from left to right.</span></span><br><span class="line">    VertexOut current;</span><br><span class="line">    <span class="keyword">int</span> length = right.posH.x - left.posH.x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// linear interpolation</span></span><br><span class="line">        <span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/length;</span><br><span class="line">        current = lerp(left, right, weight);</span><br><span class="line">        current.posH.x = left.posH.x + i;</span><br><span class="line">        current.posH.y = left.posH.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// depth testing.</span></span><br><span class="line">        <span class="keyword">double</span> depth = m_backBuffer-&gt;getDepth(current.posH.x, current.posH.y);</span><br><span class="line">        <span class="keyword">if</span>(current.posH.z &gt; depth)</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">// fail to pass the depth testing.</span></span><br><span class="line">        m_backBuffer-&gt;drawDepth(current.posH.x,current.posH.y,current.posH.z);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> w = <span class="number">1.0</span>/current.oneDivZ;</span><br><span class="line">        current.posTrans *= w;</span><br><span class="line">        current.color *= w;</span><br><span class="line">        current.texcoord *= w;</span><br><span class="line">        <span class="comment">// fragment shader</span></span><br><span class="line">        m_backBuffer-&gt;drawPixel(current.posH.x, current.posH.y,</span><br><span class="line">                                m_shader-&gt;fragmentShader(current));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就可以根据深度信息正确地渲染出三维的立体感了。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/cube1_s.png" alt="cube1_s"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/cube1.gif" alt="cube1"></p><h2 id="3、裁剪、剔除优化"><a href="#3、裁剪、剔除优化" class="headerlink" title="3、裁剪、剔除优化"></a>3、裁剪、剔除优化</h2><p>&emsp;&emsp;目前目前我们已经构建出三维的渲染管线，但是这还不够，因为图形渲染计算量很大，通常我们需要做一些优化。常见的嵌入在渲染管线中的优化算法有几何裁剪、背面剔除。</p><h3 id="几何裁剪"><a href="#几何裁剪" class="headerlink" title="几何裁剪"></a>几何裁剪</h3><p>&emsp;&emsp;注意在坐标系统的变换过程中，位于视锥体内的顶点坐标各分量都会被映射到$[-1,1]$的范围内，超出视锥体的顶点则被映射到超出$[-1,1]$的范围。我们在这个基础上的做相关的裁剪，注意在透视除法之前各分量实际上是处于$[-w,w]$的范围内的，这里的$w$就是该顶点坐标的第四个分量$w$。针对线框模式渲染和填充模式渲染，我们有两种不同的裁剪算法。</p><h4 id="Cohen-Sutherland线条裁剪算法"><a href="#Cohen-Sutherland线条裁剪算法" class="headerlink" title="Cohen-Sutherland线条裁剪算法"></a>Cohen-Sutherland线条裁剪算法</h4><p>&emsp;&emsp;一条线段在视口内的情况有如下所示的四种。其中端点完全在视口内和一端在视口内而另一端是在视口外的情况很好判断，但是线段完全在视口外就没那么简单了。可以看到线段$GH$的端点都在视口外部，但是线段的一部分却在视口的内部，这是如果直接根据两个端点是否在视口外做剔除的话会导致在边缘部分的线段直接消失，得到错误的结果。一种暴力的解法就是计算线段与视口窗口的交点，但是这并不高效。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/line0.png" alt="line0"></p><p>&emsp;&emsp;Cohen-Sutherland提出了一种基于编码的判断算法，通过简单的移位、与或逻辑运算就可以判断一条线段处于哪种情况。对于每一个端点$(x,y)$，我们定义一个outcode——$b_0b_1b_2b_3$，视口所处的范围用$x_{min}$、$x_{max}$、$y_{min}$、$y_{max}$表示。每个端点$(x,y)$的outcode的计算方法如下：</p><p>&emsp;&emsp;$b_0 = 1\ if \ y &gt; y_{max},\  0\  otherwiose$</p><p>&emsp;&emsp;$b_1 = 1\ if \ y &lt; y_{min},\  0\  otherwiose$</p><p>&emsp;&emsp;$b_2 = 1\ if \ x &gt; x_{min},\  0\  otherwiose$</p><p>&emsp;&emsp;$b_3 = 1\ if \ x &lt; x_{max},\  0\  otherwiose$</p><p>&emsp;&emsp;可以看出outcode将屏幕空间分成了$9$个部分：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/outcode.png" alt="outcode"></p><p>&emsp;&emsp;观察上面的$9$个区域，对于两个端点outcode1和outcode2，做如下的判断策略，其中的$OR$和$AND$是逻辑按位运算：</p><p>&emsp;&emsp;若$(outcode1\ OR\ outcode2)==0$，那么线段就完全在视口内部；</p><p>&emsp;&emsp;若$(outcode1\ AND\ outcode2)!=0$，那么线段就完全在视口外部；</p><p>&emsp;&emsp;若$(outcode1\ AND\ outcode2)==0$，那么线段就<strong>可能</strong>部分在视口外部，部分在内部，还需要做进一步的判断（这里我进一步判断用了包围盒，因为比较常见和简单，就不过多描述了）。</p><p>&emsp;&emsp;这里我的实现就是只裁剪掉肯定完全在视口外部的线段，若还想裁剪掉部分外视口外部的线段则需要进一步的求交运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Pipeline::lineCliping(<span class="keyword">const</span> VertexOut &amp;from, <span class="keyword">const</span> VertexOut &amp;to)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// return whether the line is totally outside or not.</span></span><br><span class="line">    <span class="keyword">float</span> vMin = -from.posH.w, vMax = from.posH.w;</span><br><span class="line">    <span class="keyword">float</span> x1 = from.posH.x, y1 = from.posH.y;</span><br><span class="line">    <span class="keyword">float</span> x2 = to.posH.x, y2 = to.posH.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> outcode1 = <span class="number">0</span>, outcode2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// outcode1 calculation.</span></span><br><span class="line">    tmp = (y1&gt;vMax)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">3</span>;</span><br><span class="line">    outcode1 |= tmp;</span><br><span class="line">    tmp = (y1&lt;vMin)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    outcode1 |= tmp;</span><br><span class="line">    tmp = (x1&gt;vMax)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    outcode1 |= tmp;</span><br><span class="line">    tmp = (x1&lt;vMin)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    outcode1 |= tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// outcode2 calculation.</span></span><br><span class="line">    tmp = (y2&gt;vMax)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">3</span>;</span><br><span class="line">    outcode2 |= tmp;</span><br><span class="line">    tmp = (y2&lt;vMin)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    outcode2 |= tmp;</span><br><span class="line">    tmp = (x2&gt;vMax)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    outcode2 |= tmp;</span><br><span class="line">    tmp = (x2&lt;vMin)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    outcode2 |= tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((outcode1 &amp; outcode2) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bounding box judge.</span></span><br><span class="line">    Vector2D minPoint,maxPoint;</span><br><span class="line">    minPoint.x = min(from.posH.x, to.posH.x);</span><br><span class="line">    minPoint.y = min(from.posH.y, to.posH.y);</span><br><span class="line">    maxPoint.x = max(from.posH.x, to.posH.x);</span><br><span class="line">    maxPoint.y = max(from.posH.y, to.posH.y);</span><br><span class="line">    <span class="keyword">if</span>(minPoint.x &gt; vMax || maxPoint.x &lt; vMin || minPoint.y &gt; vMax || maxPoint.y &lt; vMin)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三角形裁剪"><a href="#三角形裁剪" class="headerlink" title="三角形裁剪"></a>三角形裁剪</h4><p>&emsp;&emsp;判断三角形是否完全在外面也不能直接根据三个端点是否完全在视口外部来判断（我看有些软渲染的博主就用了这个错误的策略），因为还要考略以下的特殊情况。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/clip0.png" alt="clip0"></p><p>&emsp;&emsp;为此，我直接计算三角形的轴向包围盒，然后这个包围盒判断三角形是否完全是视口外部。更进一步的裁剪是将部分在视口内部的三角形做求交，然后重新分割成完全在视口内部的三角形，这里我没有做进一步的裁剪。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Pipeline::triangleCliping(<span class="keyword">const</span> VertexOut &amp;v1, <span class="keyword">const</span> VertexOut &amp;v2, <span class="keyword">const</span> VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// true:not clip;</span></span><br><span class="line">    <span class="comment">// false: clip.</span></span><br><span class="line">    <span class="keyword">float</span> vMin = -v1.posH.w;</span><br><span class="line">    <span class="keyword">float</span> vMax = +v1.posH.w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the triangle is too far to see it, just return false.</span></span><br><span class="line">    <span class="keyword">if</span>(v1.posH.z &gt; vMax &amp;&amp; v2.posH.z &gt; vMax &amp;&amp; v3.posH.z &gt; vMax)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the triangle is behind the camera, just return false.</span></span><br><span class="line">    <span class="keyword">if</span>(v1.posH.z &lt; vMin &amp;&amp; v2.posH.z &lt; vMin &amp;&amp; v3.posH.z &lt; vMin)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the bounding box and check if clip or not.</span></span><br><span class="line">    Vector2D minPoint,maxPoint;</span><br><span class="line">    minPoint.x = min(v1.posH.x, min(v2.posH.x, v3.posH.x));</span><br><span class="line">    minPoint.y = min(v1.posH.y, min(v2.posH.y, v3.posH.y));</span><br><span class="line">    maxPoint.x = max(v1.posH.x, max(v2.posH.x, v3.posH.x));</span><br><span class="line">    maxPoint.y = max(v1.posH.y, max(v2.posH.y, v3.posH.y));</span><br><span class="line">    <span class="keyword">if</span>(minPoint.x &gt; vMax || maxPoint.x &lt; vMin || minPoint.y &gt; vMax || maxPoint.y &lt; vMin)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们把几何裁剪放到渲染管线中，几何裁剪一般是在顶点着色器之后、光栅化之前。这里我把它放到了透视除法和视口变换之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::drawIndex(RenderMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// renderer pipeline.</span></span><br><span class="line">    <span class="keyword">bool</span> line1 = <span class="literal">false</span>, line2 = <span class="literal">false</span>, line3 = <span class="literal">false</span>;</span><br><span class="line">    m_mode = mode;</span><br><span class="line">    <span class="keyword">if</span>(m_indices.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m_indices.size();i += <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! assembly to triangle primitive.</span></span><br><span class="line">        Vertex p1,p2,p3;</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! vertex shader stage.</span></span><br><span class="line">        VertexOut v1,v2,v3;</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! geometry cliping.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m_mode == RenderMode::wire)</span><br><span class="line">            &#123;</span><br><span class="line">                line1 = lineCliping(v1,v2);</span><br><span class="line">                line2 = lineCliping(v2,v3);</span><br><span class="line">                line3 = lineCliping(v3,v1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m_mode == RenderMode::fill &amp;&amp; !triangleCliping(v1,v2,v3))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! perspective division.</span></span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! view port transformation.</span></span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! rasterization and fragment shader stage.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mode == RenderMode::wire)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!line1)</span><br><span class="line">                    bresenhamLineRasterization(v1,v2);</span><br><span class="line">                <span class="keyword">if</span>(!line2)</span><br><span class="line">                    bresenhamLineRasterization(v2,v3);</span><br><span class="line">                <span class="keyword">if</span>(!line3)</span><br><span class="line">                    bresenhamLineRasterization(v3,v1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mode == RenderMode::fill)</span><br><span class="line">            &#123;</span><br><span class="line">                edgeWalkingFillRasterization(v1,v2,v3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背面剔除"><a href="#背面剔除" class="headerlink" title="背面剔除"></a>背面剔除</h3><p>&emsp;&emsp;背面剔除网上的这篇<a href="https://blog.csdn.net/wangdingqiaoit/article/details/52267314" target="_blank" rel="noopener">博客</a>已经讲得非常详细了，原理也很简单，我就不过多描述。我们定义顶点逆时针的环绕顺序正面，然后通过三角形的三个顶点计算出法线，将顶点与视线做点乘并判断其符号即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Pipeline::backFaceCulling(<span class="keyword">const</span> Vector4D &amp;v1, <span class="keyword">const</span> Vector4D &amp;v2, <span class="keyword">const</span> Vector4D &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// back face culling.</span></span><br><span class="line">    <span class="keyword">if</span>(m_mode == RenderMode::wire)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    Vector4D tmp1 = v2 - v1;</span><br><span class="line">    Vector4D tmp2 = v3 - v1;</span><br><span class="line">    <span class="function">Vector3D <span class="title">edge1</span><span class="params">(tmp1.x, tmp1.y, tmp1.z)</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">edge2</span><span class="params">(tmp2.x, tmp2.y, tmp2.z)</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">viewRay</span><span class="params">(m_eyePos.x - v1.x,</span></span></span><br><span class="line"><span class="function"><span class="params">                     m_eyePos.y - v1.y,</span></span></span><br><span class="line"><span class="function"><span class="params">                     m_eyePos.z - v1.z)</span></span>;</span><br><span class="line">    Vector3D normal = edge1.crossProduct(edge2);</span><br><span class="line">    <span class="keyword">return</span> normal.dotProduct(viewRay) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后背面剔除应该放在渲染管线的顶点着色器输出之后，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::drawIndex(RenderMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// renderer pipeline.</span></span><br><span class="line">    <span class="keyword">bool</span> line1 = <span class="literal">false</span>, line2 = <span class="literal">false</span>, line3 = <span class="literal">false</span>;</span><br><span class="line">    m_mode = mode;</span><br><span class="line">    <span class="keyword">if</span>(m_indices.empty())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m_indices.size();i += <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! assembly to triangle primitive.</span></span><br><span class="line">        Vertex p1,p2,p3;</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! vertex shader stage.</span></span><br><span class="line">        VertexOut v1,v2,v3;</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! back face culling.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!backFaceCulling(v1.posTrans, v2.posTrans, v3.posTrans))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! geometry cliping.</span></span><br><span class="line">        &#123;</span><br><span class="line">......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! perspective division.</span></span><br><span class="line">        &#123;</span><br><span class="line">......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! view port transformation.</span></span><br><span class="line">        &#123;</span><br><span class="line">......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! rasterization and fragment shader stage.</span></span><br><span class="line">        &#123;</span><br><span class="line">......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、透视纹理映射、采样"><a href="#二、透视纹理映射、采样" class="headerlink" title="二、透视纹理映射、采样"></a>二、透视纹理映射、采样</h1><p>&emsp;&emsp;纹理映射是丰富三维物体细节的一个非常重要的方法，简单、廉价、快速，只需计算好的纹理坐标、纹理图片即可实现物体的多姿多彩。通常纹理图片的制作（除了过程式纹理的生成）由设计师完成，无需我们关心。而纹理坐标的计算则需要非常注意，送入渲染管线的纹理坐标只是逐顶点的纹理坐标，在光栅化阶段我们还要将纹理坐标做插值操作，最后根据插值后得到的纹理坐标对纹理图片采样获取片元的像素值。</p><h2 id="1、透视纹理映射"><a href="#1、透视纹理映射" class="headerlink" title="1、透视纹理映射"></a>1、透视纹理映射</h2><p>&emsp;&emsp;在光栅化阶段，我们是根据屏幕空间的$x$值和$y$值做线性插值操作获取片元的位置，而片元的纹理坐标如果也这么获得的话（这种方法叫做仿射纹理映射），将会导致严重的纹理扭曲。这是因为仿射纹理映射是基于这样的一个假设：物体空间的纹理坐标与屏幕空间的顶点坐标呈线性管线。</p><p>&emsp;&emsp;我们知道纹理坐标是定义在物体的顶点上面的，当我们根据屏幕空间的顶点坐标插值时，就默认了纹理坐标的变化与屏幕空间顶点坐标的变化是呈线性、均匀的关系的。但是问题在于：默认的屏幕空间上的线性关系，还原到世界空间中，就不是那么回事了，如下图所示。这张图是相机空间的一张俯视图。我们把一个多边形通过透视投影的方式变换到了投影平面上，图中红色的是世界空间中的多边形，蓝色的是变换到投影平面之后的多边形。可以看到，在投影平面上的蓝色线段被表示成若干个相等的单位步长线段。与此同时，投影面上单位步长的线段所对应的投影之前的红色线段的长度却不是相等的，从左到右所对应的长度依次递增。我们的纹理坐标是定义在红色的多边形上的，因此纹理坐标的增量应该是和红色线段的步长对应的。我们的线性插值却把纹理坐标增量根据蓝色线段的步长平均分配了。</p><p><img src="http://hi.csdn.net/attachment/201005/8/0_127332838023gG.gif" alt="img"></p><p>&emsp;&emsp;这就导致了仿射纹理映射的错误的结果，如下图所示，仿射纹理映射产生了严重的扭曲。</p><p><img src="http://hi.csdn.net/attachment/201005/8/0_127332853505pQ.gif" alt="img"></p><p>&emsp;&emsp;而如果你不信，大可以试一试，然后你就会得到和我下面这张图一样奇怪的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/affine.png" alt="affine"></p><p>&emsp;&emsp;那么如何进行矫正了？网上的这篇<a href="https://blog.csdn.net/popy007/article/details/5570803" target="_blank" rel="noopener">博客</a>已经非常详细地说明了相关的矫正方法，<strong>核心思想就是想办法让纹理坐标变得与屏幕空间的坐标线性相关，这一点可以看成纹理坐标的透视投影（与世界空间的顶点坐标投影到屏幕空间，从而通过插值获得其他的屏幕空间坐标进行光栅化有异曲同工之妙）</strong>。</p><p>&emsp;&emsp;纹理透视投影的详细过程请看这篇<a href="https://blog.csdn.net/popy007/article/details/5570803" target="_blank" rel="noopener">博客</a>，其中借助的关系就是纹理坐标与世界空间顶点坐标是相关的（我们定义纹理坐标就是逐个顶点定义的），然后世界空间顶点坐标（为了便于讨论，这里世界空间就是视图空间）通过投影矩阵变成屏幕空间顶点坐标。在世界空间中，顶点的$x$和$y$值与$z$值呈线性关系（因为我们定义基本图元是三角形，在三角形平面上，必然是线性的，否则就是非线性的曲面了），即存在$A$和$B$有：</p><script type="math/tex; mode=display">x_e = Az_e+B\\y_e = Az_e+B \tag {2}</script><p>&emsp;&emsp;$(x_e,y_e,z_e)$是视图空间的顶点坐标，即$(x’,y’)$是投影到近平面的顶点坐标。根据透视投影矩阵可知（其实就是相似三角形），$(x’,y’)$与视图空间的顶点坐标关系如下：</p><script type="math/tex; mode=display">\begin{cases}x'=-N\frac {x_e}{z_e}\ \to x_e= -\frac{x'z_e}{N} \\y'=-N\frac {y_e}{z_e}\ \to y_e= -\frac{y'z_e}{N} \end{cases} \tag {3}</script><p>&emsp;&emsp;将公式$(3)$带入公式$(2)$，则有：</p><script type="math/tex; mode=display">\begin{cases}x'=-N\frac{B}{z_e}-AN\\y'=-N\frac{B}{z_e}-AN\end{cases} \tag {4}</script><p>&emsp;&emsp;其中的$A$、$B$、$N$都是常量，把$\frac 1{z_e}$看成一个整体，则通过透视投影矩阵的变换之后$x’$、$y’$均与$\frac{1}{z_e}$成线性关系，这也就是透视投影的效果是近大远小的根本原因。然后注意到在三维空间中，纹理坐标$(s,t)$和$(x_e,y_e)$成线性关系。即有（这里只是定性分析，$A$和$B$具体多少我们不用关心）：</p><script type="math/tex; mode=display">\begin{cases}x_e=As+B\\x_e=At+B\\y_e=As+B\\y_e=At+B\end{cases} \tag {5}</script><p>&emsp;&emsp;把公式$(5)$带入$(3)$则有（以公式$(5)$的第一个为例，其他类似）：</p><script type="math/tex; mode=display">As+B=-\frac{x'z_e}{N}\ \to\ A\frac{s}{z_e}+B\frac{1}{z_e}=-\frac{x'}{N} \tag {6}</script><p>&emsp;&emsp;<strong>公式$(6)$彻底说明了纹理坐标与屏幕空间的顶点坐标的关系！$s$和$x’$并不是简单的线性关系，因为还出现了$\frac{1}{z_e}$这个项，如果$\frac{1}{z_e}$具体值已知，那么$\frac{s}{z_e}$就与 $x’$成线性关系！那么我们在线性插值之前给纹理坐标$s$乘上一个$\frac{1}{z_e}$，就可以根据屏幕空间的顶点坐标做线性插值了，然后对插值得到的纹理坐标$s’$乘上$z_e$就能还原出正确的纹理坐标！！！！</strong></p><p>&emsp;&emsp;说了这么多都是在捋清函数关系，实现其实很简单的，上面已经说的很清楚了。我们在$VertexOut$中定义的变量$oneDivZ$就用于的透射投影映射的。除开纹理坐标，其他的世界空间坐标、顶点颜色、法线都是定义在世界空间的坐标顶点上的，为了得到正确的插值，都需要做与纹理坐标一样的处理。乘上$\frac{1}{z_e}$这一步我放在了顶点着色器的最后一步，只要放在插值之前都行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VertexOut SimpleShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oneDivZ to correct mapping.</span></span><br><span class="line">    result.oneDivZ = <span class="number">1.0</span> / result.posH.w;</span><br><span class="line">    result.posTrans *= result.oneDivZ;</span><br><span class="line">    result.texcoord *= result.oneDivZ;</span><br><span class="line">    result.color *= result.oneDivZ;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后再光栅化插值之后各自乘上相应的倒数即可恢复出正确的插值结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::scanLinePerRow(<span class="keyword">const</span> VertexOut &amp;left, <span class="keyword">const</span> VertexOut &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// scan the line from left to right.</span></span><br><span class="line">    VertexOut current;</span><br><span class="line">    <span class="keyword">int</span> length = right.posH.x - left.posH.x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// linear interpolation</span></span><br><span class="line">        <span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/length;</span><br><span class="line">        current = lerp(left, right, weight);</span><br><span class="line">        current.posH.x = left.posH.x + i;</span><br><span class="line">        current.posH.y = left.posH.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// depth testing.</span></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// restore.</span></span><br><span class="line">        <span class="keyword">double</span> w = <span class="number">1.0</span>/current.oneDivZ;</span><br><span class="line">        current.posTrans *= w;</span><br><span class="line">        current.color *= w;</span><br><span class="line">        current.texcoord *= w;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fragment shader</span></span><br><span class="line">        m_backBuffer-&gt;drawPixel(current.posH.x, current.posH.y,</span><br><span class="line">                                m_shader-&gt;fragmentShader(current));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、双线性纹理采样"><a href="#2、双线性纹理采样" class="headerlink" title="2、双线性纹理采样"></a>2、双线性纹理采样</h2><p>&emsp;&emsp;定义的纹理坐标都是$[0.0f,1.0f]$的浮点数，为了采样纹理我们需要把它乘上纹理的宽高转成整数的下标取访问纹理的像素矩阵。乘上纹理的宽高之后我们得到的依然应该是一个浮点数，为了获取像素下标，一个简单的方法就是向下取整（这种采样方法对应于OpenGL的GL_NEAREST纹理过滤方法）。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> trueU = texcoord.x * (m_width - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> trueV = texcoord.y * (m_height - <span class="number">1</span>);</span><br><span class="line">x = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueU);</span><br><span class="line">y = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueV);</span><br><span class="line"><span class="keyword">int</span> index[<span class="number">0</span>] = (x * m_width + y) * m_channel;</span><br><span class="line">Vector3D texels;</span><br><span class="line"><span class="comment">// INV_SCALE is 1.0/255</span></span><br><span class="line">texels.x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index + <span class="number">0</span>]) * INV_SCALE;</span><br><span class="line">texels.y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index + <span class="number">1</span>]) * INV_SCALE;</span><br><span class="line">texels.z = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index + <span class="number">2</span>]) * INV_SCALE;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;问题就出在这里，这样直接抛弃小数点以后的值导致采样出的相邻纹理并不连续，那么用float采样行吗？答案是：不行！这边实现的采样函数是从数组取值，纹理坐标转为数组下标，数组下标不能用float只能用int，那么就没办法了吗？并不是，可以对周围纹理进行采样然后按照各自比例进行混合，这样能够提高显示效果。混合的方法就是双线性插值。所谓双线性插值，就是先后线性插值一次，共两次。即横向线性插值一次，然后根据前面一次的插值结果竖向插值一次，二维纹理是有两个维度，所以做双线性插值。</p><p>&emsp;&emsp;除了采样之外，还有一个纹理坐标溢出的问题。纹理坐标超过的$[0,1]$通常由两种处理方式，一种是$clamp$，超过$[0,1]$的地方的像素都获取边上的像素，这样效果就是拉伸。一种是$repeat$，故名思议，即重复平铺。这里我实现的是重复平铺，在计算真正的纹理下标之前做相应的判断和处理即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Texture2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width;</span><br><span class="line">    <span class="keyword">int</span> m_height;</span><br><span class="line">    <span class="keyword">int</span> m_channel;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *m_pixelBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Texture2D():m_width(<span class="number">0</span>), m_height(<span class="number">0</span>), m_channel(<span class="number">0</span>), m_pixelBuffer(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ~Texture2D();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">loadImage</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector4D <span class="title">sample</span><span class="params">(<span class="keyword">const</span> Vector2D &amp;texcoord)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Texture2D::loadImage(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pixelBuffer)<span class="keyword">delete</span> m_pixelBuffer;</span><br><span class="line">    m_pixelBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">    m_pixelBuffer = stbi_load(path.c_str(), &amp;m_width, &amp;m_height, &amp;m_channel, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m_pixelBuffer == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Failed to load image-&gt;"</span> &lt;&lt; QString::fromStdString(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  m_pixelBuffer != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4D Texture2D::sample(<span class="keyword">const</span> Vector2D &amp;texcoord) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// just for rgb and rgba format.</span></span><br><span class="line">    <span class="function">Vector4D <span class="title">result</span><span class="params">(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(m_pixelBuffer == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for bilinear interpolation.</span></span><br><span class="line">    <span class="keyword">double</span> factorU = <span class="number">0</span>, factorV = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the corresponding coordinate.</span></span><br><span class="line">    <span class="keyword">if</span>(texcoord.x &gt;= <span class="number">0.0f</span> &amp;&amp; texcoord.x &lt;= <span class="number">1.0f</span> &amp;&amp; texcoord.y &gt;= <span class="number">0.0f</span> &amp;&amp; texcoord.y &lt;= <span class="number">1.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> trueU = texcoord.x * (m_width - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">double</span> trueV = texcoord.y * (m_height - <span class="number">1</span>);</span><br><span class="line">        x = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueU);</span><br><span class="line">        y = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueV);</span><br><span class="line">        factorU = trueU - x;</span><br><span class="line">        factorV = trueV - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// repeating way.</span></span><br><span class="line">        <span class="keyword">float</span> u = texcoord.x,v = texcoord.y;</span><br><span class="line">        <span class="keyword">if</span>(texcoord.x &gt; <span class="number">1.0f</span>)</span><br><span class="line">            u = texcoord.x - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(texcoord.x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(texcoord.x &lt; <span class="number">0.0f</span>)</span><br><span class="line">            u = <span class="number">1.0f</span> - (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(texcoord.x) - texcoord.x);</span><br><span class="line">        <span class="keyword">if</span>(texcoord.y &gt; <span class="number">1.0f</span>)</span><br><span class="line">            v = texcoord.y - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(texcoord.y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(texcoord.y &lt; <span class="number">0.0f</span>)</span><br><span class="line">            v = <span class="number">1.0f</span> - (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(texcoord.y) - texcoord.y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> trueU = u * (m_width - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">double</span> trueV = v * (m_height - <span class="number">1</span>);</span><br><span class="line">        x = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueU);</span><br><span class="line">        y = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(trueV);</span><br><span class="line">        factorU = trueU - x;</span><br><span class="line">        factorV = trueV - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// texel fetching.</span></span><br><span class="line">    Vector3D texels[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> index[<span class="number">4</span>];</span><br><span class="line">    index[<span class="number">0</span>] = (x * m_width + y) * m_channel;</span><br><span class="line">    index[<span class="number">1</span>] = (x * m_width + y + <span class="number">1</span>) * m_channel;</span><br><span class="line">    index[<span class="number">2</span>] = ((x + <span class="number">1</span>) * m_width + y + <span class="number">1</span>) * m_channel;</span><br><span class="line">    index[<span class="number">3</span>] = ((x + <span class="number">1</span>) * m_width + y) * m_channel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left bottom</span></span><br><span class="line">    texels[<span class="number">0</span>].x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">0</span>] + <span class="number">0</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">0</span>].y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">0</span>] + <span class="number">1</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">0</span>].z = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">0</span>] + <span class="number">2</span>]) * INV_SCALE;</span><br><span class="line">    <span class="comment">//return texels[0];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// left top</span></span><br><span class="line">    texels[<span class="number">1</span>].x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">1</span>] + <span class="number">0</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">1</span>].y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">1</span>] + <span class="number">1</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">1</span>].z = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">1</span>] + <span class="number">2</span>]) * INV_SCALE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// right top</span></span><br><span class="line">    texels[<span class="number">2</span>].x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">2</span>] + <span class="number">0</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">2</span>].y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">2</span>] + <span class="number">1</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">2</span>].z = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">2</span>] + <span class="number">2</span>]) * INV_SCALE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// right bottom</span></span><br><span class="line">    texels[<span class="number">3</span>].x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">3</span>] + <span class="number">0</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">3</span>].y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">3</span>] + <span class="number">1</span>]) * INV_SCALE;</span><br><span class="line">    texels[<span class="number">3</span>].z = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_pixelBuffer[index[<span class="number">3</span>] + <span class="number">2</span>]) * INV_SCALE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bilinear interpolation.</span></span><br><span class="line">    <span class="comment">// horizational</span></span><br><span class="line">    texels[<span class="number">0</span>] = texels[<span class="number">0</span>] * (<span class="number">1.0</span> - factorU) + texels[<span class="number">3</span>] * factorU;</span><br><span class="line">    texels[<span class="number">1</span>] = texels[<span class="number">1</span>] * (<span class="number">1.0</span> - factorU) + texels[<span class="number">2</span>] * factorU;</span><br><span class="line">    <span class="comment">//vertical</span></span><br><span class="line">    result = texels[<span class="number">0</span>] * (<span class="number">1.0</span> - factorV) + texels[<span class="number">1</span>] *factorV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;加载图片我的用的stb_image，一个简单使用的头文件，因为加载图片不是我们的重点，所以就不造这方面的轮子了。</p><h1 id="三、程序结果"><a href="#三、程序结果" class="headerlink" title="三、程序结果"></a>三、程序结果</h1><p>&emsp;&emsp;目前的帧率还不错hhh。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/ret1.png" alt="ret1"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/ret2.png" alt="ret2"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.7/blog/SoftRenderer-3DPipeline/ret3.gif" alt="ret3"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank" rel="noopener">https://learnopengl.com/Advanced-OpenGL/Depth-testing</a></p><p>$[2]$ <a href="https://www.cnblogs.com/pbblog/p/3484193.html" target="_blank" rel="noopener">https://www.cnblogs.com/pbblog/p/3484193.html</a></p><p>$[3]$ <a href="https://learnopengl.com/Getting-started/Coordinate-Systems" target="_blank" rel="noopener">https://learnopengl.com/Getting-started/Coordinate-Systems</a></p><p>$[4]$ <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank" rel="noopener">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></p><p>$[5]$ <a href="https://blog.csdn.net/popy007/article/details/5570803" target="_blank" rel="noopener">https://blog.csdn.net/popy007/article/details/5570803</a></p><p>$[6]$ <a href="https://learnopengl-cn.github.io/01 Getting started/06 Textures/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Soft Renderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Soft Renderer </tag>
            
            <tag> 3D pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软渲染器Soft Renderer：光栅化篇</title>
      <link href="/2019/05/01/SoftRenderer-Rasterization/"/>
      <url>/2019/05/01/SoftRenderer-Rasterization/</url>
      
        <content type="html"><![CDATA[<p>本章开始构建基于Qt平台软渲染器的初步框架，当然Qt相关的内容并不是软渲染器的重点，我只是借助Qt平台将渲染出来的像素矩阵用Qt的控件显示出来。光栅化是当今图形学渲染的一种方式，与之对应的是光线追踪渲染方式，本章我根据自己的理解着重讲述线框光栅化的Bresenham画线算法以及三角形填充光栅化的Edge-Walking算法。<strong>注意：初学者慎入</strong>。本篇相关的完整代码请看<a href="https://github.com/ZeusYang/Soft-Renderer/releases/tag/1.0.0" target="_blank" rel="noopener">这里</a>。</p><p><div align="left"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/3.png" height="400"></div></p><a id="more"></a><ul><li><p>渲染管线框架</p></li><li><p>光栅化算法</p></li></ul><h1 id="一、渲染管线框架"><a href="#一、渲染管线框架" class="headerlink" title="一、渲染管线框架"></a>一、渲染管线框架</h1><p>&emsp;&emsp;渲染管线的搭建主要包含像素显示、网格数据封装、渲染循环、帧率fps计算、帧缓冲、着色器、渲染逻辑、光栅化等等，其中光栅化作为重点对象抽出来放在后面。当然我们不会一下子就完成渲染管线的基本功能，我们现在是要搭建一个框架，大部分的内容不用写入或者仅仅是做简单的处理，这样后面完善软渲染器的时候只需在相应的位置填写相应的代码逻辑即可。本章目标就是搭建一个渲染管线，用光栅化算法画三角形。当然，如果仅仅是画一个三角形，当然不用这么麻烦，但是我的目标是实现三维的软渲染器，深入理解三维渲染的整个流程，得从基础一步一步慢慢来。</p><h2 id="1、像素显示的画布"><a href="#1、像素显示的画布" class="headerlink" title="1、像素显示的画布"></a>1、像素显示的画布</h2><p>&emsp;&emsp;渲染器最终渲染出来的是一个像素矩阵，我们要把这个像素矩阵显示出来。显示的方法有很多，因人而异，这里我采用自己最熟悉的$Qt$来实现。显示的窗口继承一个普通的$QWidget$父类，然后我们通过重写它的$paintEvent$函数，将渲染出来的像素画到$QWidget$上。但是采用$QPainter$直接画上去的方式效率非常低，我通过查询资料得知，若想要快速地绘制给定的像素矩阵，可以利用$QImage$来实现。话不多说，上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Window</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~Window();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Window *ui;</span><br><span class="line">    QImage *canvas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接收到一帧的像素之后，在重绘事件里面利用$QImage$绘制给定的像素数组（记得调用$update$触发重绘事件）。<strong>由于篇幅原因，我不会讲太多细节方面的东西，代码也不会全部放出来，那样没意义。想看完整源代码的朋友直接去本人的github上看。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::receiveFrame(<span class="keyword">unsigned</span> <span class="keyword">char</span> *image)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(canvas) <span class="keyword">delete</span> canvas;</span><br><span class="line">    canvas = <span class="keyword">new</span> QImage(image, width(), height(), QImage::Format_RGBA8888);</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Window::paintEvent(QPaintEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(canvas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        painter.drawImage(<span class="number">0</span>, <span class="number">0</span>, *canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    QWidget::paintEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、帧缓冲类"><a href="#2、帧缓冲类" class="headerlink" title="2、帧缓冲类"></a>2、帧缓冲类</h2><p>&emsp;&emsp;帧缓冲通常包含基本的颜色缓冲附件、深度缓冲附件等，这里我们暂且只实现颜色缓冲附件（四通道，格式为$RGBA$，各占一个字节），深度缓冲附件后面再加上。渲染管线最终的渲染结果是写入帧缓冲的，我们采用一个一维的单字节数组作为帧缓冲的颜色缓冲。帧缓冲的最基本的功能就是清楚缓冲区、写入像素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_height, m_channel;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; m_colorBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FrameBuffer(<span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line">    ~FrameBuffer() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_width;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_height;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">getColorBuffer</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_colorBuffer.data();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearColorBuffer</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawPixel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">const</span> Vector4D &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FrameBuffer::FrameBuffer(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">    :m_channel(<span class="number">4</span>), m_width(width), m_height(height)</span><br><span class="line">&#123;</span><br><span class="line">    m_colorBuffer.resize(m_width*m_height*m_channel, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameBuffer::clearColorBuffer(<span class="keyword">const</span> Vector4D &amp;color)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// fill the color buffer.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> red = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.x);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> green = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.y);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> blue = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.z);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> alpha = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>;row &lt; m_height;++ row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;col &lt; m_width;++ col)</span><br><span class="line">        &#123;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">0</span>] = red;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">1</span>] = green;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">2</span>] = blue;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">3</span>] = alpha;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameBuffer::drawPixel(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">const</span> Vector4D &amp;color)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m_width || y &lt; <span class="number">0</span> || y &gt;= m_height)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> red = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.x);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> green = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.y);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> blue = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.z);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> alpha = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.w);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index = y*m_width*m_channel + x*m_channel;</span><br><span class="line">    m_colorBuffer[index + <span class="number">0</span>] = red;</span><br><span class="line">    m_colorBuffer[index + <span class="number">1</span>] = green;</span><br><span class="line">    m_colorBuffer[index + <span class="number">2</span>] = blue;</span><br><span class="line">    m_colorBuffer[index + <span class="number">3</span>] = alpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、网格顶点数据"><a href="#3、网格顶点数据" class="headerlink" title="3、网格顶点数据"></a>3、网格顶点数据</h2><p>&emsp;&emsp;三维的渲染程序中的顶点数据通常包含顶点位置、顶点颜色、纹理坐标、顶点法线，然后在此基础上利用一组给定顺序的顶点数据表示一个网格，渲染时网格的数据将被送入管线进行处理。为此，有必要对顶点数据做一定的封装。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector4D position;</span><br><span class="line">    Vector4D color;</span><br><span class="line">    Vector2D texcoord;</span><br><span class="line">    Vector3D normal;</span><br><span class="line"></span><br><span class="line">    Vertex() = <span class="keyword">default</span>;</span><br><span class="line">    Vertex(Vector4D _pos, Vector4D _color, Vector2D _tex, Vector3D _normal)</span><br><span class="line">        :position(_pos),color(_color),texcoord(_tex),normal(_normal) &#123;&#125;</span><br><span class="line">    Vertex(<span class="keyword">const</span> Vertex &amp;rhs)</span><br><span class="line">  :position(rhs.position),color(rhs.color),texcoord(rhs.texcoord),normal(rhs.normal)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;顶点数据经过顶点着色器的处理之后，会被送到下一个渲染管线的阶段处理。顶点着色器的顶点数据输出与输入有些差异，为此我们也定义一个类表示为顶点着色器的输出，这对于构建渲染管线尤为重要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector4D posTrans;  <span class="comment">//世界变换后的坐标</span></span><br><span class="line">    Vector4D posH;      <span class="comment">//投影变换后的坐标</span></span><br><span class="line">    Vector2D texcoord;  <span class="comment">//纹理坐标</span></span><br><span class="line">    Vector3D normal;<span class="comment">//法线</span></span><br><span class="line">    Vector4D color;    <span class="comment">//颜色</span></span><br><span class="line">    <span class="keyword">double</span> oneDivZ;     <span class="comment">//1/z用于深度测试</span></span><br><span class="line"></span><br><span class="line">    VertexOut() = <span class="keyword">default</span>;</span><br><span class="line">    VertexOut(Vector4D _posT, Vector4D _posH, Vector2D _tex, </span><br><span class="line">              Vector3D _normal, Vector4D _color, <span class="keyword">double</span> _oneDivZ)</span><br><span class="line">        :posTrans(_posT),posH(_posH),texcoord(_tex),</span><br><span class="line">          normal(_normal),color(_color),oneDivZ(_oneDivZ) &#123;&#125;</span><br><span class="line">    VertexOut(<span class="keyword">const</span> VertexOut&amp; rhs) :posTrans(rhs.posTrans), </span><br><span class="line">        posH(rhs.posH), texcoord(rhs.texcoord), normal(rhs.normal),</span><br><span class="line">        color(rhs.color), oneDivZ(rhs.oneDivZ) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就是关于网格的表示，为了节省空间（特别是对于很大的模型），我们直接采用索引来组织网格。若想详细了解OpenGL的顶点索引概念请看<a href="https://www.jianshu.com/p/c1a494288d73" target="_blank" rel="noopener">这里</a>。一个网格有两个数组，分别是$Vertex$数组和$Index$数组。下面的代码中，有一个$asTriangle$方法，这是一个三角形网格，调用这个方法之后网格存储的就是一个三角形，用于后面的光栅化调试，光栅化的基本单元就是三角形。<strong>通常情况，所有的网格模型都可以用一定数量的三角形构成，因而我们实现的软渲染器的基本图元就是三角形。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mesh</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; vertices;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices;</span><br><span class="line"></span><br><span class="line">    Mesh() = <span class="keyword">default</span>;</span><br><span class="line">    ~Mesh() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Mesh(<span class="keyword">const</span> Mesh&amp; mesh)</span><br><span class="line">        :vertices(mesh.vertices), indices(mesh.indices)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;mesh == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        vertices = mesh.vertices;</span><br><span class="line">        indices = mesh.indices;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVertices</span><span class="params">(Vertex* _vs, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vertices.resize(count);</span><br><span class="line">        <span class="keyword">new</span>(&amp;vertices[<span class="number">0</span>])<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt;(_vs, _vs + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIndices</span><span class="params">(<span class="keyword">int</span>* _es, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        indices.resize(count);</span><br><span class="line">        <span class="keyword">new</span>(&amp;indices)<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(_es, _es + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asBox</span><span class="params">(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">double</span> depth)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asTriangle</span><span class="params">(<span class="keyword">const</span> Vector3D p1, <span class="keyword">const</span> Vector3D p2, <span class="keyword">const</span> Vector3D p3)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Mesh::asTriangle(Vector3D p1, Vector3D p2, Vector3D p3)</span><br><span class="line">&#123;</span><br><span class="line">    vertices.resize(<span class="number">3</span>);</span><br><span class="line">    indices.resize(<span class="number">3</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].position = p1;</span><br><span class="line">    vertices[<span class="number">0</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].position = p2;</span><br><span class="line">    vertices[<span class="number">1</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].position = p3;</span><br><span class="line">    vertices[<span class="number">2</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].texcoord = Vector2D(<span class="number">0.5f</span>, <span class="number">1.f</span>);</span><br><span class="line">    indices[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    indices[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    indices[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、简单的着色器"><a href="#4、简单的着色器" class="headerlink" title="4、简单的着色器"></a>4、简单的着色器</h2><p>&emsp;&emsp;着色器方面时软渲染中较为高级的内容，目前我们只是搭建一个框架，因而着色器不需要什么复杂的操作，只需简单地传递数据就行了。博主实现的软渲染器只包含必不可少的顶点着色器和片元着色器，目前的顶点着色器将顶点原封不动地输出，片元着色器也是如此，这样我们后面要实现光照效果的时候直接在着色器里写上就行了。为了更加有条理，我们设计一个着色器的虚类，这样实现不同效果的着色器时我们直接继承这个虚类即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseShader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseShader() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~BaseShader() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> VertexOut <span class="title">vertexShader</span><span class="params">(<span class="keyword">const</span> Vertex &amp;in)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector4D <span class="title">fragmentShader</span><span class="params">(<span class="keyword">const</span> VertexOut &amp;in)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleShader</span> :</span> <span class="keyword">public</span> BaseShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SimpleShader() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~SimpleShader() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> VertexOut <span class="title">vertexShader</span><span class="params">(<span class="keyword">const</span> Vertex &amp;in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector4D <span class="title">fragmentShader</span><span class="params">(<span class="keyword">const</span> VertexOut &amp;in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VertexOut SimpleShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut result;</span><br><span class="line">    result.posTrans = in.position;</span><br><span class="line">    result.posH = in.position;</span><br><span class="line">    result.color = in.color;</span><br><span class="line">    result.normal = in.normal;</span><br><span class="line">    result.oneDivZ = <span class="number">1.0</span>;</span><br><span class="line">    result.texcoord = in.texcoord;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4D SimpleShader::fragmentShader(<span class="keyword">const</span> VertexOut &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    Vector4D litColor;</span><br><span class="line">    litColor = in.color;</span><br><span class="line">    <span class="keyword">return</span> litColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setModelMatrix(<span class="keyword">const</span> Matrix4x4 &amp;world)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setViewMatrix(<span class="keyword">const</span> Matrix4x4 &amp;view)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setProjectMatrix(<span class="keyword">const</span> Matrix4x4 &amp;project)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到$SimpleShader$仅仅是将顶点数据直接输出，不进行任何处理。</p><h2 id="5、搭建基本的渲染管线"><a href="#5、搭建基本的渲染管线" class="headerlink" title="5、搭建基本的渲染管线"></a>5、搭建基本的渲染管线</h2><p>&emsp;&emsp;目前我们已经有了一些渲染管线的基本组件，现在就需要把这些组件串起来。首先是渲染循环的问题，$Qt$有它自己的事件循环，而且主线程的事件循环要尽量避免大量的运算（否则UI控件会陷入未响应），因此将渲染循环放到子线程里是一个不错的渲染，这样也可以避免我们的软渲染逻辑与$Qt$的接口耦合得太高。</p><h3 id="渲染线程"><a href="#渲染线程" class="headerlink" title="渲染线程"></a>渲染线程</h3><p>&emsp;&emsp;$Qt$提供了$QThread$类构建线程，我采用的方式为：渲染循环类继承$QObject$，然后调用$moveToThread$番方法挂到子线程上运行，最后将线程的启动信号与$loop$渲染循环关联即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderLoop</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RenderLoop</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~RenderLoop();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopIt</span><span class="params">()</span> </span>&#123;stoped = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFpsZero</span><span class="params">()</span></span>&#123;fps = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFps</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> fps;&#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">frameOut</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *image)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> stoped;</span><br><span class="line">    <span class="keyword">int</span> fps;</span><br><span class="line">    <span class="keyword">int</span> width, height, channel;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RenderLoop::RenderLoop(<span class="keyword">int</span> w, <span class="keyword">int</span> h, QObject *parent)</span><br><span class="line">    : QObject(parent), width(w), height(h), channel(<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fps = <span class="number">0</span>;</span><br><span class="line">    stoped = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RenderLoop::~RenderLoop()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pipeline initialization</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">// fps counting.</span></span><br><span class="line">    fps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stoped)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// render logic</span></span><br><span class="line">        ......</span><br><span class="line">        ++ fps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后在主窗口中创建$RenderLoop$对象，挂到$QThread$上启动。此外还有一点要注意的是在子线程中最好不用使用$QTimer$类，因此我在主窗口中创建$QTimer$类，设定为每秒触发，触发时主线程读取子线程的$fps$，这样就达到了显示帧率的目的了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">在Window类声明处：</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QTimer *timer;</span><br><span class="line">    QThread *loopThread;</span><br><span class="line">    RenderLoop *loop;</span><br><span class="line"></span><br><span class="line">在Window类构造函数处：</span><br><span class="line">    loop = <span class="keyword">new</span> RenderLoop(width(), height(), <span class="literal">nullptr</span>);</span><br><span class="line">    loopThread = <span class="keyword">new</span> QThread(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fps counting.</span></span><br><span class="line">    timer = <span class="keyword">new</span> QTimer();</span><br><span class="line">    connect(timer,&amp;QTimer::timeout,<span class="keyword">this</span>,&amp;Window::fpsTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render thread.</span></span><br><span class="line">    loop-&gt;moveToThread(loopThread);</span><br><span class="line">    connect(loopThread,&amp;QThread::finished,loop, &amp;RenderLoop::deleteLater);</span><br><span class="line">    connect(loopThread,&amp;QThread::started,loop,&amp;RenderLoop::loop);</span><br><span class="line">    connect(loop,&amp;RenderLoop::frameOut,<span class="keyword">this</span>,&amp;Window::receiveFrame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin the thread.</span></span><br><span class="line">    loopThread-&gt;start();</span><br><span class="line">    timer-&gt;start(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">Window的其他函数：</span><br><span class="line"><span class="keyword">void</span> Window::fpsTimeOut()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fps = loop-&gt;getFps();</span><br><span class="line">    loop-&gt;setFpsZero();</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle(QString(<span class="string">" fps: %1"</span>).arg(fps));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><p>&emsp;&emsp;回顾一下$OpenGL$的渲染流程（这里只考虑一般的情况，即不包含几何着色器、细分着色器等），首先外部处理网格，将网格顶点数据和网格顶点索引送入渲染管线，设置基本图元（如三角形）、渲染方式（如线框模式）。渲染管线的第一阶段为顶点着色器阶段（在这之前还有个缓冲清理阶段），顶点着色器对网格数据逐顶点处理（包含坐标空间变换、投影变换等等），随之输出。然后渲染管线对输出的顶点数据进行裁剪，送入光栅化部件，计算几何图元覆盖的像素点，其中进行了大量的线性插值操作。接着片元着色器获取光栅化后的像素，对每个像素做颜色计算等，然后输出颜色数据、深度数据，最后根据这些缓冲数据做深度测试。</p><p>&emsp;&emsp;所以一个最基本的渲染管线应该有如下几个步骤：</p><p>&emsp;&emsp;初始化（如缓冲区创建）$\to$输入顶点缓冲、索引缓冲$\to$清除缓冲区$\to$设置着色器、渲染方式$\to$绘制$\to$交换双缓冲$\to$输出。根据这些步骤，创建$Pipeline$类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_height;              <span class="comment">// width and height of viewport.</span></span><br><span class="line">    BaseShader *m_shader;               <span class="comment">// shaders including vertex shader and fragment shader.</span></span><br><span class="line">    FrameBuffer *m_frontBuffer;</span><br><span class="line">    FrameBuffer *m_backBuffer;</span><br><span class="line">    Matrix4x4 viewPortMatrix;           <span class="comment">// viewport transformation matrix.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; m_vertices;     <span class="comment">// vertex buffer.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; m_indices;<span class="comment">// index buffer.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pipeline(<span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line">    ~Pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;color, <span class="keyword">bool</span> depth = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVertexBuffer</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; &amp;vertices)</span></span>&#123;m_vertices = vertices;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIndexBuffer</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;indices)</span></span>&#123;m_indices = indices;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setShaderMode</span><span class="params">(ShadingMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawIndex</span><span class="params">(RenderMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swapBuffer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">output</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_frontBuffer-&gt;getColorBuffer();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Pipeline::Pipeline(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">    :m_width(width),m_height(height)</span><br><span class="line">    ,m_shader(<span class="literal">nullptr</span>),m_frontBuffer(<span class="literal">nullptr</span>)</span><br><span class="line">    ,m_backBuffer(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pipeline::~Pipeline()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_shader)<span class="keyword">delete</span> m_shader;</span><br><span class="line">    <span class="keyword">if</span>(m_frontBuffer)<span class="keyword">delete</span> m_frontBuffer;</span><br><span class="line">    <span class="keyword">if</span>(m_backBuffer)<span class="keyword">delete</span> m_backBuffer;</span><br><span class="line">    m_shader = <span class="literal">nullptr</span>;</span><br><span class="line">    m_frontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">    m_backBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::initialize()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_frontBuffer)</span><br><span class="line">        <span class="keyword">delete</span> m_frontBuffer;</span><br><span class="line">    <span class="keyword">if</span>(m_backBuffer)</span><br><span class="line">        <span class="keyword">delete</span> m_backBuffer;</span><br><span class="line">    <span class="keyword">if</span>(m_shader)</span><br><span class="line">        <span class="keyword">delete</span> m_shader;</span><br><span class="line">    viewPortMatrix.setViewPort(<span class="number">0</span>,<span class="number">0</span>,m_width,m_height);</span><br><span class="line">    m_frontBuffer = <span class="keyword">new</span> FrameBuffer(m_width, m_height);</span><br><span class="line">    m_backBuffer = <span class="keyword">new</span> FrameBuffer(m_width, m_height);</span><br><span class="line">    m_shader = <span class="keyword">new</span> SimpleShader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::drawIndex(RenderMode mode)</span><br><span class="line">&#123;</span><br><span class="line"> 输入顶点着色器;</span><br><span class="line">    光栅化;</span><br><span class="line">    输入片元着色器;</span><br><span class="line">    写入缓冲区;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::clearBuffer(<span class="keyword">const</span> Vector4D &amp;color, <span class="keyword">bool</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="keyword">void</span>)depth;</span><br><span class="line">    m_backBuffer-&gt;clearColorBuffer(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::setShaderMode(ShadingMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_shader)<span class="keyword">delete</span> m_shader;</span><br><span class="line">    <span class="keyword">if</span>(mode == ShadingMode::simple)</span><br><span class="line">        m_shader = <span class="keyword">new</span> SimpleShader();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mode == ShadingMode::phong)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::swapBuffer()</span><br><span class="line">&#123;</span><br><span class="line">    FrameBuffer *tmp = m_frontBuffer;</span><br><span class="line">    m_frontBuffer = m_backBuffer;</span><br><span class="line">    m_backBuffer = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意到我创建了帧缓冲，分别是$m_frontBuffer$和$m_backBuffer$，前者存储着当前显示的像素，后者缓冲区用于写入像素。这就是著名的双缓冲原理，可以避免画面的闪烁、撕裂等现象。除此之外，还有一个值得特别说明的就是视口变换矩阵$viewPortMatrix$，这个一般很少见到，因为被内嵌在了渲染管线里面了。经过投影变换、透视除法操作之后，顶点数据都在标准化设备空间中，即$x$轴、$y$轴、$z$轴取值范围为$[-1,1]$。但是屏幕的像素坐标范围并非如此，通常屏幕的$x$轴坐标范围为$[0,width]$，$y$轴坐标范围为$[0,height]$，屏幕像素坐标原点在左上角，$x$轴正向朝右，$y$轴正向朝下，所以我们还要把标准化设备坐标顶点数据变换到屏幕的坐标范围中，这就是<strong>视口变换</strong>（$z$轴一般保持不变）。视口变换矩阵的构造并没有难度，因为这仅仅是简单的线性映射，因此不再赘述。视口变换矩阵如下所示：</p><script type="math/tex; mode=display">viewPortMatrix=\left[\begin{matrix}\frac{w}{2}&0&0&s_x+\frac{w}{2}\\0&-\frac{h}{2}&0&s_y+\frac{h}{2}\\0&0&1&0\\0&0&0&1\end{matrix}\right] \tag {1}</script><p>&emsp;&emsp;其中$(s_x,s_y)$是视口左上角的坐标，$(w,h)$为屏幕的宽度和高度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setViewPort(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(width)/<span class="number">2.0f</span>;</span><br><span class="line">    entries[<span class="number">5</span>]  = -<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(height)/<span class="number">2.0f</span>;</span><br><span class="line">    entries[<span class="number">12</span>] =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(left)+<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(width)/<span class="number">2.0f</span>;</span><br><span class="line">    entries[<span class="number">13</span>] =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(top)+<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(height)/<span class="number">2.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;$Pipeline$还有个非常重要的函数$drawIndex$，它是渲染管线的核心部分，涉及到了图元装配、顶点着色器调度、光栅化、片元着色器调度、写入帧缓冲这几个重要的步骤。我们实现的软渲染器几何图元默认为三角形，所以图元装配就是每三个顶点装成一个图元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::drawIndex(RenderMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_indices.empty())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m_indices.size()/<span class="number">3</span>;++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! vertices assembly to triangle primitive</span></span><br><span class="line">        Vertex p1,p2,p3;</span><br><span class="line">        &#123;</span><br><span class="line">            p1 = m_vertices[<span class="number">3</span>*i+<span class="number">0</span>];</span><br><span class="line">            p2 = m_vertices[<span class="number">3</span>*i+<span class="number">1</span>];</span><br><span class="line">            p3 = m_vertices[<span class="number">3</span>*i+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! vertex shader stage.</span></span><br><span class="line">        VertexOut v1,v2,v3;</span><br><span class="line">        &#123;</span><br><span class="line">            v1 = m_shader-&gt;vertexShader(p1);</span><br><span class="line">            v2 = m_shader-&gt;vertexShader(p2);</span><br><span class="line">            v3 = m_shader-&gt;vertexShader(p3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! rasterization and fragment shader stage.</span></span><br><span class="line">        &#123;</span><br><span class="line">            v1.posH = viewPortMatrix * v1.posH;</span><br><span class="line">            v2.posH = viewPortMatrix * v2.posH;</span><br><span class="line">            v3.posH = viewPortMatrix * v3.posH;</span><br><span class="line">            <span class="keyword">if</span>(mode == RenderMode::wire)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// bresenham rasterization</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mode == RenderMode::fill)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// edge walking rasterization</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有了以上的$Pipeline$函数，我们的渲染循环逻辑的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!stoped)</span><br><span class="line">&#123;</span><br><span class="line">    pipeline-&gt;clearBuffer(Vector4D(<span class="number">0.502f</span>,<span class="number">0.698f</span>,<span class="number">0.800f</span>,<span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    pipeline-&gt;drawIndex(RenderMode::fill);</span><br><span class="line"></span><br><span class="line">    pipeline-&gt;swapBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="function">emit <span class="title">frameOut</span><span class="params">(pipeline-&gt;output())</span></span>;</span><br><span class="line">    ++ fps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、光栅化算法"><a href="#二、光栅化算法" class="headerlink" title="二、光栅化算法"></a>二、光栅化算法</h1><p>&emsp;&emsp;顶点着色器处理的还是一个个离散的几何顶点，在顶点着色器之后我们还需要进行光栅化操作，将几何覆盖的屏幕像素计算出来，送入片元着色器计算每个点的像素数据。光栅化一般有两种模式：一种是线框模式，即只描绘几何的边；二是填充模式，即将几何的面片全部填充完。Bresenham算法是经典的描线算法，它采用迭代的形式将所需的算术操作降低到最少。除此之外还有DDA描线算法，效率上不如Bresenham算法，所以我没有实现。</p><h2 id="1、Bresenham描线算法"><a href="#1、Bresenham描线算法" class="headerlink" title="1、Bresenham描线算法"></a>1、Bresenham描线算法</h2><p>&emsp;&emsp;我们要描绘的是从$(x_0,y_0)$到$(x_1,y_1)$的一条直线线段。一些数学符号标记如下：</p><script type="math/tex; mode=display">\Delta x= x_1-x_0>0,\ \Delta y=y_1-y_0>0,\ m=\frac{\Delta y}{\Delta x}</script><p>&emsp;&emsp;其中$m$即直线线段的斜率，为了便于讨论，我们假设$|m|\leq 1$，其他情况很容易推广。</p><p>&emsp;&emsp;在如上的情况下，Bresenham算法从$x=x_0$开始，每次将$x$坐标值加一，然后推算相应的$y$坐标值。记第$i$次迭代获得的点为$(x_i,y_i)$。那么第$i+1$次迭代时获取的点就在$(\overline x_i+1,\overline y_i)$和$(\overline x_i+1,\overline y_i+1)$这两个中选取。那如何判断应该选哪个呢？即选择这两个点之一的判断标准是什么？<strong>直观上，我们应该选取距离的直线线段在该$y$轴上的交点最近的点</strong>，如下图1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/4.png" alt="1556629627471"></p><center>图1 判别标准</center><p>&emsp;&emsp;直线的一般表达式为$y=mx+B$，$m$为直线的斜率，那么$(x_{i+1},y_{i+1})$表示为如下（注意$y_{i+1}$表示的是直线在$x_{i+1}$上真正的$y$值）：</p><script type="math/tex; mode=display">x_{i+1}=x_i+1\\y_{i+1}=mx_{i+1}+B=m(x_i+1)+B \tag {2}</script><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/5.png" alt="1556630006821"></p><center>图2 交点到右边的点、右上的点的距离 </center><p>&emsp;&emsp;故$d_{upper}$和$d_{lower}$的取值如下：</p><script type="math/tex; mode=display">d_{upper}=\overline y_i+1-\overline y_{i+1}=\overline y_i+1-m\overline x_{i+1}-B\\d_{lower}=y_{i+1}-\overline y_i=mx_{i+1}+B-\overline y_i \tag {3}</script><p>&emsp;&emsp;显然，如果$d_{lower}-d_{upper}&gt;0$，则应该取右上方的点；如果$d_{lower}-d_{upper}<0$，则应该取右边的点。而$d_{lower}-d_{upper}=0$可任取这两个点。因此，我们的判断标准就是$d_{lower}-d_{upper}>0$的符号。</0$，则应该取右边的点。而$d_{lower}-d_{upper}=0$可任取这两个点。因此，我们的判断标准就是$d_{lower}-d_{upper}></p><script type="math/tex; mode=display">d_{lower}-d_{upper}=m(x_i+1)+B-\overline y_i-(\overline y_i+1-m(x_i+1)-B)\\=2m(x_i+1)-2\overline y_i+2B-1 \tag {4}</script><p>&emsp;&emsp;式$(4)$中的$m$是直线的斜率，因此将式$(4)$作为判断标准需要做非常昂贵的浮点数除法运算。为了消去除法，注意到$m=\frac{\Delta y}{\Delta x}$，两边同时乘上$\Delta x&gt;0$，正负符号不变。</p><script type="math/tex; mode=display">p_i=\Delta x\cdot (d_{lower}-d_{upper})=2\Delta y\cdot(x_i+1)-2\Delta x\cdot \overline y_i+(2B-1)\Delta x\\=2\Delta y\cdot x_i-2\Delta x\cdot\overline y_i+c\\where \ \ c=(2B-1)\Delta x+2\Delta y \tag {5}</script><p>&emsp;&emsp;所以可以用$p_i$的符号作为选取的标准。但是，式$(5)$的计算能够进一步简化，考虑$p_i$和$p_{i+1}$（注意我们根据$p_i$的符号来选取$\overline y_{i+1}$）：</p><script type="math/tex; mode=display">p_{i+1}-p_{i}=(2\Delta y\cdot x_{i+1}-2\Delta x\cdot\overline y_{i+1}+c)-(2\Delta y\cdot x_i-2\Delta x\cdot\overline y_i+c)\\=2\Delta y-2\Delta x(\overline y_{i+1}-\overline y_i) \tag {6}</script><p>&emsp;&emsp;若$p_i\leq 0$，那么选择右边的点，此时$\overline y_{i+1}=\overline y_i$，那么有：</p><script type="math/tex; mode=display">p_{i+1}=p_i+2\Delta y \tag {7}</script><p>&emsp;&emsp;若$p_i&gt;0$，那么选择右上角的点，此时$\overline y_{i+1}=\overline y_i+1$，那么有：</p><script type="math/tex; mode=display">p_{i+1}=p_i+2\Delta y-2\Delta x \tag {8}</script><p>&emsp;&emsp;所以我们可以根据$p_i$的符号快速计算出$p_{i+1}$的符号，如此迭代下去：</p><hr><p><strong>Bresenham Algorithm:</strong></p><hr><p>$draw (x_0, y_0);$</p><p>Calculate $\Delta x$,$\Delta y$,$2\Delta y$,$2\Delta y-2\Delta x$,$p_0=2\Delta y-\Delta x$;</p><p>for $x$ from $x_0$ to $x_1$:</p><p>&emsp;&emsp;if $p_i\leq 0$ </p><p>&emsp;&emsp;&emsp;&emsp;draw $(x_{i+1},\overline y_{i+1})=(x_i+1,\overline y_i)$ ;</p><p>&emsp;&emsp;&emsp;&emsp;compute $p_{i+1}=p_i+2\Delta y$;</p><p>&emsp;&emsp;if $p_i &gt; 0$ </p><p>&emsp;&emsp;&emsp;&emsp;draw $(x_{i+1},\overline y_{i+1})=(x_i+1,\overline y_i+1)$ ;</p><p>&emsp;&emsp;&emsp;&emsp;compute $p_{i+1}=p_i+2\Delta y-2\Delta x$;</p><p>&emsp;&emsp;$x += 1;$</p><hr><p>&emsp;&emsp;上面我们讨论的都是$|m|<1$的情况，那$|m|>1$的情况呢？其实这是对称的，这时把$x$看成$y$，把$y$看成$x$即可。另外，当$\Delta x &lt;0$时，我们的$x$不是递增$1$，而是递减$1$，具体实现如下：</1$的情况，那$|m|></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::bresenhamLineRasterization(<span class="keyword">const</span> VertexOut &amp;from, <span class="keyword">const</span> VertexOut &amp;to)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dx = to.posH.x - from.posH.x;</span><br><span class="line">    <span class="keyword">int</span> dy = to.posH.y - from.posH.y;</span><br><span class="line">    <span class="keyword">int</span> stepX = <span class="number">1</span>, stepY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// judge the sign</span></span><br><span class="line">    <span class="keyword">if</span>(dx &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stepX = <span class="number">-1</span>;</span><br><span class="line">        dx = -dx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dy &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stepY = <span class="number">-1</span>;</span><br><span class="line">        dy = -dy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d2x = <span class="number">2</span>*dx, d2y = <span class="number">2</span>*dy;</span><br><span class="line">    <span class="keyword">int</span> d2y_minus_d2x = d2y - d2x;</span><br><span class="line">    <span class="keyword">int</span> sx = from.posH.x;</span><br><span class="line">    <span class="keyword">int</span> sy = from.posH.y;</span><br><span class="line"></span><br><span class="line">    VertexOut tmp;</span><br><span class="line">    <span class="comment">// slope &lt; 1.</span></span><br><span class="line">    <span class="keyword">if</span>(dy &lt;= dx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = d2y - dx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= dx;++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// linear interpolation</span></span><br><span class="line">            tmp = lerp(from, to, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dx);</span><br><span class="line">            <span class="comment">// fragment shader</span></span><br><span class="line">            m_backBuffer-&gt;drawPixel(sx,sy,m_shader-&gt;fragmentShader(tmp));</span><br><span class="line">            sx += stepX;</span><br><span class="line">            <span class="keyword">if</span>(flag &lt;= <span class="number">0</span>)</span><br><span class="line">                flag += d2y;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sy += stepY;</span><br><span class="line">                flag += d2y_minus_d2x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slope &gt; 1.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = d2x - dy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= dy;++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// linear interpolation</span></span><br><span class="line">            tmp = lerp(from, to, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dy);</span><br><span class="line">            <span class="comment">// fragment shader</span></span><br><span class="line">            m_backBuffer-&gt;drawPixel(sx,sy,m_shader-&gt;fragmentShader(tmp));</span><br><span class="line">            sy += stepY;</span><br><span class="line">            <span class="keyword">if</span>(flag &lt;= <span class="number">0</span>)</span><br><span class="line">                flag += d2x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sx += stepX;</span><br><span class="line">                flag -= d2y_minus_d2x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、Edge-Walking三角形填充算法"><a href="#2、Edge-Walking三角形填充算法" class="headerlink" title="2、Edge-Walking三角形填充算法"></a>2、Edge-Walking三角形填充算法</h2><p>&emsp;&emsp;三角形光栅化填充对输入给定的三个三角形顶点，计算这个三角区域覆盖的所有像素。三角形填充的光栅化算法有很多种，这里仅实现了Edge-Walking算法，此外还有Edge-Equation算法。关于Edge-Walking算法的前世今生我不再赘述了，这个算法的思路比较简单，但是实现起来比较麻烦一点。</p><p>&emsp;&emsp;话不多少，直接上伪代码（懒得自己写了伪代码了）：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/6.png" alt="1556632613625"></p><p>&emsp;&emsp;大致的思想就是从上往下（或从下往上）扫描，获取每对$X_L$、$X_R$，然后在$[X_L,X_R]$范围内从左到右扫描。显然就是双重循环。一般，我们的三角形光栅化对象有如下四种情况：</p><p><img src="http://hi.csdn.net/attachment/201103/8/8458191_1299584107w6lP.png" alt="4ç§ä¸è§å½¢"></p><center>图3 四类三角形 </center><p>&emsp;&emsp;先来看平底三角形的情况，如下图4所示。显然，平底三角形很容易地实现从下往上扫面，竖直方向上仅需考虑左右两条边。<strong>当然这里有个问题，就是如何确定$X_L$和$X_R$？如果直接采用算法伪代码中的利用$dx/dy$迭代获取$X$值，因为$X$值是整数，而$dx/dy$是浮点数，当$dx/dy&lt;1$时，把$dx/dy$加到$X$上面计算机对整数类型坐标自动向下取整，结果相当于没加。（即便是浮点数类型，最终也要取整，因为屏幕空间的像素坐标必须是整数）</strong></p><p><img src="http://hi.csdn.net/attachment/201103/8/8458191_12995845892C4L.png" alt="åæ åå¹³åºä¸è§å½¢"></p><center>图4 平底三角形</center><p>&emsp;&emsp;一种解决方案就是线性插值，算法从下往上扫描时，$y-=1$，我们根据当前的$y$值来获取$x$值：</p><script type="math/tex; mode=display">X_L = (1.0f-\frac{y1-y}{y1-y0})*x1+\frac{y1-y}{y1-y0}*x0 \\X_y = (1.0f-\frac{y2-y}{y2-y0})*x2+\frac{y2-y}{y2-y0}*x0</script><p>&emsp;&emsp;平顶的三角形光栅化亦类似，不再赘述。那么除了平底和平顶的情况之外，我们该如何处理其余的情况？一个技巧就是将其他情况的三角形分割乘一个平底三角形、一个平顶三角形，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/7.png" alt="1556634037498"></p><center>图5 三角形分割</center><p>&emsp;&emsp;这样我们通过调用平底三角形光栅化方法、平顶三角形光栅化方法即可实现一般情况的三角形光栅化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::scanLinePerRow(<span class="keyword">const</span> VertexOut &amp;left, <span class="keyword">const</span> VertexOut &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut current;</span><br><span class="line">    <span class="keyword">int</span> length = right.posH.x - left.posH.x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// linear interpolation</span></span><br><span class="line">        <span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/length;</span><br><span class="line">        current = lerp(left, right, weight);</span><br><span class="line">        current.posH.x = left.posH.x + i;</span><br><span class="line">        current.posH.y = left.posH.y;</span><br><span class="line">        <span class="comment">// fragment shader</span></span><br><span class="line">        m_backBuffer-&gt;drawPixel(current.posH.x, current.posH.y,</span><br><span class="line">                                m_shader-&gt;fragmentShader(current));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::rasterTopTriangle(VertexOut &amp;v1, VertexOut &amp;v2, VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut left = v2;</span><br><span class="line">    VertexOut right = v3;</span><br><span class="line">    VertexOut dest = v1;</span><br><span class="line">    VertexOut tmp, newleft, newright;</span><br><span class="line">    <span class="keyword">if</span>(left.posH.x &gt; right.posH.x)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = left;</span><br><span class="line">        left = right;</span><br><span class="line">        right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dy = left.posH.y - dest.posH.y + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dy;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dy != <span class="number">0</span>)</span><br><span class="line">            weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dy;</span><br><span class="line">        newleft = lerp(left, dest, weight);</span><br><span class="line">        newright = lerp(right, dest, weight);</span><br><span class="line">        newleft.posH.y = newright.posH.y = left.posH.y - i;</span><br><span class="line">        scanLinePerRow(newleft, newright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::rasterBottomTriangle(VertexOut &amp;v1, VertexOut &amp;v2, VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut left = v1;</span><br><span class="line">    VertexOut right = v2;</span><br><span class="line">    VertexOut dest = v3;</span><br><span class="line">    VertexOut tmp, newleft, newright;</span><br><span class="line">    <span class="keyword">if</span>(left.posH.x &gt; right.posH.x)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = left;</span><br><span class="line">        left = right;</span><br><span class="line">        right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dy = dest.posH.y - left.posH.y + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dy;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dy != <span class="number">0</span>)</span><br><span class="line">            weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dy;</span><br><span class="line">        newleft = lerp(left, dest, weight);</span><br><span class="line">        newright = lerp(right, dest, weight);</span><br><span class="line">        newleft.posH.y = newright.posH.y = left.posH.y + i;</span><br><span class="line">        scanLinePerRow(newleft, newright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::edgeWalkingFillRasterization(<span class="keyword">const</span> VertexOut &amp;v1, <span class="keyword">const</span> VertexOut &amp;v2, <span class="keyword">const</span> VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// split the triangle into two part</span></span><br><span class="line">    VertexOut tmp;</span><br><span class="line">    VertexOut target[<span class="number">3</span>] = &#123;v1, v2,v3&#125;;</span><br><span class="line">    <span class="keyword">if</span>(target[<span class="number">0</span>].posH.y &gt; target[<span class="number">1</span>].posH.y)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = target[<span class="number">0</span>];</span><br><span class="line">        target[<span class="number">0</span>] = target[<span class="number">1</span>];</span><br><span class="line">        target[<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target[<span class="number">0</span>].posH.y &gt; target[<span class="number">2</span>].posH.y)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = target[<span class="number">0</span>];</span><br><span class="line">        target[<span class="number">0</span>] = target[<span class="number">2</span>];</span><br><span class="line">        target[<span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target[<span class="number">1</span>].posH.y &gt; target[<span class="number">2</span>].posH.y)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = target[<span class="number">1</span>];</span><br><span class="line">        target[<span class="number">1</span>] = target[<span class="number">2</span>];</span><br><span class="line">        target[<span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bottom triangle</span></span><br><span class="line">    <span class="keyword">if</span>(equal(target[<span class="number">0</span>].posH.y,target[<span class="number">1</span>].posH.y))</span><br><span class="line">    &#123;</span><br><span class="line">        rasterBottomTriangle(target[<span class="number">0</span>],target[<span class="number">1</span>],target[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// top triangle</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(equal(target[<span class="number">1</span>].posH.y,target[<span class="number">2</span>].posH.y))</span><br><span class="line">    &#123;</span><br><span class="line">        rasterTopTriangle(target[<span class="number">0</span>], target[<span class="number">1</span>], target[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// split it.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(target[<span class="number">1</span>].posH.y-target[<span class="number">0</span>].posH.y)/(target[<span class="number">2</span>].posH.y-target[<span class="number">0</span>].posH.y);</span><br><span class="line">        VertexOut newPoint = lerp(target[<span class="number">0</span>],target[<span class="number">2</span>],weight);</span><br><span class="line">        newPoint.posH.y = target[<span class="number">1</span>].posH.y;</span><br><span class="line">        rasterTopTriangle(target[<span class="number">0</span>], newPoint, target[<span class="number">1</span>]);</span><br><span class="line">        rasterBottomTriangle(newPoint,target[<span class="number">1</span>],target[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、程序结果"><a href="#三、程序结果" class="headerlink" title="三、程序结果"></a>三、程序结果</h1><p>&emsp;&emsp;最终，不借用任何图形接口通过自己实现的光栅化算法画出了三角形：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/0.png" alt="0"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/1.png" alt="1"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/2.png" alt="2"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/3.png" alt="3"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="https://blog.csdn.net/cppyin/article/details/6232453" target="_blank" rel="noopener">https://blog.csdn.net/cppyin/article/details/6232453</a></p><p>$[2]$ <a href="https://blog.csdn.net/y1196645376/article/details/78937614" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/78937614</a></p><p>$[3]$ <a href="https://blog.csdn.net/y1196645376/article/details/78907914" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/78907914</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Soft Renderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Soft Renderer </tag>
            
            <tag> Rasterization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软渲染器Soft Renderer：3D数学篇</title>
      <link href="/2019/05/01/SoftRenderer-Math/"/>
      <url>/2019/05/01/SoftRenderer-Math/</url>
      
        <content type="html"><![CDATA[<p>本章开始博主将手动搭建一个渲染管线，深入理解3D渲染的整个流程。线性代数中的向量和矩阵是计算机图形学的常客，深入理解和掌握对于图形渲染有着非常重要的意义，本节主要是关于3D数学库的内容。</p><a id="more"></a><ul><li>向量</li><li>矩阵</li></ul><h1 id="一、向量"><a href="#一、向量" class="headerlink" title="一、向量"></a>一、向量</h1><p>&emsp;&emsp;$n$维向量本质就是一个$n$元组，从几何意义上来说，向量是有大小和方向的有向线段。向量的大小就是向量的长度（模）向量有非负的长度，而向量的方向描述了空间中向量的指向。向量的相关内容高中就已涉及，因此不再赘述。若想要重新深入了解相关内容，可以查看这个<a href="http://www.cnblogs.com/msxh/p/6156004.html" target="_blank" rel="noopener">地址</a>。</p><p>&emsp;&emsp;图形渲染中通常使用的向量为$2$到$4$维，如下分别是$2$维、$3$维、$4$维向量类的常用方法，主要是运算操作符重载以及点乘、叉乘、模、标准化、线性插值等基本操作。向量的内容简单，没什么要特别说明的。</p><h2 id="1、2D向量类"><a href="#1、2D向量类" class="headerlink" title="1、2D向量类"></a>1、2D向量类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vector2D():x(<span class="number">0.0f</span>), y(<span class="number">0.0f</span>) &#123;&#125;</span><br><span class="line">    Vector2D(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY):x(newX), y(newY)&#123;&#125;</span><br><span class="line">    Vector2D(<span class="keyword">const</span> <span class="keyword">float</span> * rhs):x(*rhs), y((*rhs)+<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    Vector2D(<span class="keyword">const</span> Vector2D &amp; rhs):x(rhs.x), y(rhs.y)&#123;&#125;</span><br><span class="line">    ~Vector2D() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY)</span></span>&#123;x=newX;y=newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123;x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123;y = newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normalization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Vector2D <span class="title">getNormalize</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sqrt</span>(x*x + y*y));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getSquaredLength</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x*x + y*y);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Vector2D <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(x + rhs.x, y + rhs.y);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(x - rhs.x, y - rhs.y);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(x*rhs, y*rhs);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (rhs==<span class="number">0</span>) ? Vector2D(<span class="number">0.0f</span>, <span class="number">0.0f</span>) : Vector2D(x / rhs, y / rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(x,rhs.x) &amp;&amp; equal(y,rhs.y));&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !((*<span class="keyword">this</span>)==rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector2D &amp;rhs)&#123;x+=rhs.x;y+=rhs.y;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Vector2D &amp;rhs)&#123;x-=rhs.x;y-=rhs.y;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;x*=rhs;y*=rhs;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;<span class="keyword">if</span>(!equal(rhs, <span class="number">0.0</span>))&#123;x/=rhs;y/=rhs;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    Vector2D <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(-x, -y);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// interpolation</span></span><br><span class="line">    <span class="function">Vector2D <span class="title">lerp</span><span class="params">(<span class="keyword">const</span> Vector2D &amp;v2,<span class="keyword">const</span> <span class="keyword">float</span> factor)</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span> - factor) + v2*factor;&#125;</span><br><span class="line">    <span class="function">Vector2D <span class="title">quadraticInterpolate</span><span class="params">(<span class="keyword">const</span> Vector2D &amp; v2, <span class="keyword">const</span> Vector2D &amp; v3, <span class="keyword">const</span> <span class="keyword">float</span> factor)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor)*(<span class="number">1.0f</span>-factor) + v2*<span class="number">2.0f</span>*factor*(<span class="number">1.0f</span>-factor) + v3*factor*factor;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2、3D向量类"><a href="#2、3D向量类" class="headerlink" title="2、3D向量类"></a>2、3D向量类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector3D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vector3D():x(<span class="number">0.0f</span>), y(<span class="number">0.0f</span>), z(<span class="number">0.0f</span>)&#123;&#125;</span><br><span class="line">    Vector3D(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ):x(newX), y(newY), z(newZ)&#123;&#125;</span><br><span class="line">    Vector3D(<span class="keyword">const</span> <span class="keyword">float</span> * rhs):x(*rhs), y(*(rhs+<span class="number">1</span>)), z(*(rhs+<span class="number">2</span>))&#123;&#125;</span><br><span class="line">    Vector3D(<span class="keyword">const</span> Vector3D &amp;rhs):x(rhs.x), y(rhs.y), z(rhs.z)&#123;&#125;</span><br><span class="line">    ~Vector3D() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ)</span></span>&#123;x=newX;y=newY;z=newZ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123;x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123;y = newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZ</span><span class="params">(<span class="keyword">float</span> newZ)</span> </span>&#123;z = newZ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getZ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> z;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normalization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getNormalized</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length caculation</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sqrt</span>(x*x+y*y+z*z));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getSquaredLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x*x+y*y+z*z;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// product</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">dotProduct</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x*rhs.x + y*rhs.y + z*rhs.z;&#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">crossProduct</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> Vector3D(y*rhs.z - z*rhs.y, z*rhs.x - x*rhs.z, x*rhs.y - y*rhs.x);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// linear interpolation</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">lerp</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;v2, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor) + v2*factor;&#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">QuadraticInterpolate</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;v2, <span class="keyword">const</span> Vector3D &amp;v3, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor)*(<span class="number">1.0f</span>-factor) + v2*<span class="number">2.0f</span>*factor*(<span class="number">1.0f</span>-factor) + v3*factor*factor;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Vector3D <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(x + rhs.x, y + rhs.y, z + rhs.z);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(x - rhs.x, y - rhs.y, z - rhs.z);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(x*rhs, y*rhs, z*rhs);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(rhs,<span class="number">0.0f</span>))?Vector3D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>):Vector3D(x/rhs, y/rhs, z/rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(x,rhs.x) &amp;&amp; equal(y,rhs.y) &amp;&amp; equal(z,rhs.z));&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !((*<span class="keyword">this</span>)==rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector3D &amp;rhs) &#123;x+=rhs.x;y+=rhs.y;z+=rhs.z;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Vector3D &amp; rhs) &#123;x-=rhs.x;y-=rhs.y;z-=rhs.z;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;x*=rhs;y*=rhs;z*=rhs;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;<span class="keyword">if</span>(!equal(rhs,<span class="number">0.0f</span>))&#123;x/=rhs; y/=rhs; z/=rhs;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    Vector3D <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(-x, -y, -z);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、4D向量类"><a href="#3、4D向量类" class="headerlink" title="3、4D向量类"></a>3、4D向量类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector4D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y,z,w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vector4D():x(<span class="number">0.0f</span>), y(<span class="number">0.0f</span>), z(<span class="number">0.0f</span>), w(<span class="number">0.0f</span>)&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ, <span class="keyword">float</span> newW):x(newX), y(newY), z(newZ), w(newW)&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">const</span> <span class="keyword">float</span> * rhs):x(*rhs), y(*(rhs+<span class="number">1</span>)), z(*(rhs+<span class="number">2</span>)), w(*(rhs+<span class="number">3</span>))&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">const</span> Vector4D &amp;rhs):x(rhs.x), y(rhs.y), z(rhs.z), w(rhs.w)&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">const</span> Vector3D &amp; rhs):x(rhs.x), y(rhs.y), z(rhs.z), w(<span class="number">1.0f</span>)&#123;&#125;</span><br><span class="line">    ~Vector4D() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ, <span class="keyword">float</span> newW)</span></span>&#123;x=newX;y=newY;z=newZ;w=newW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123;x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123;y = newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZ</span><span class="params">(<span class="keyword">float</span> newZ)</span> </span>&#123;z = newZ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setW</span><span class="params">(<span class="keyword">float</span> newW)</span> </span>&#123;w = newW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getZ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> z;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getW</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> w;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// product</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">dotProduct</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x*rhs.x + y*rhs.y + z*rhs.z + w*rhs.w;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// linear interpolation</span></span><br><span class="line">    <span class="function">Vector4D <span class="title">lerp</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;v2, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor) + v2*factor;&#125;</span><br><span class="line">    <span class="function">Vector4D <span class="title">QuadraticInterpolate</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;v2, <span class="keyword">const</span> Vector4D &amp;v3, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor)*(<span class="number">1.0f</span>-factor)+v2*<span class="number">2.0f</span>*factor*(<span class="number">1.0f</span>-factor)+v3*factor*factor;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Vector4D <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(x+rhs.x, y+rhs.y, z+rhs.z, w+rhs.w);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(x-rhs.x, y-rhs.y, z-rhs.z, w-rhs.w);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(x*rhs, y*rhs, z*rhs, w*rhs);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> (equal(rhs,<span class="number">0.0f</span>))?Vector4D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>):Vector4D(x/rhs, y/rhs, z/rhs, w/rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(x,rhs.x)&amp;&amp;equal(y,rhs.y)&amp;&amp;equal(z,rhs.z)&amp;&amp;equal(w,rhs.w));&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !((*<span class="keyword">this</span>)==rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector4D &amp;rhs) &#123;x+=rhs.x;y+=rhs.y;z+=rhs.z;w+=rhs.w;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Vector4D &amp; rhs) &#123;x-=rhs.x;y-=rhs.y;z-=rhs.z;w-=rhs.w;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;x*=rhs;y*=rhs;z*=rhs;w*=rhs;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;<span class="keyword">if</span>(!equal(rhs,<span class="number">0.0f</span>))&#123;x/=rhs; y/=rhs; z/=rhs; w/=rhs;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    Vector4D <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(-x, -y, -z, -w);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、矩阵"><a href="#二、矩阵" class="headerlink" title="二、矩阵"></a>二、矩阵</h1><p>&emsp;&emsp;矩阵本质就是向量的进一步扩展的，一个$n\times m$的矩阵可看成$n$个$m$维行向量组成或者$m$个$n$维列向量组成，关于矩阵的基本概念、操作请看<a href="https://blog.csdn.net/AutisticPatient/article/details/62892100" target="_blank" rel="noopener">这里</a>。通常我们采用方阵来描述线性变换。所谓线性变换，即变换之后保留了直线而不被弯曲，平行线依然平行，原点没有变化，但其他的几何性质如长度、角度、面积和体积可能被变换改变了。直观来说，线性变换可能“拉伸”坐标系，但不会“弯曲”或“卷折”坐标系。</p><p>&emsp;&emsp;矩阵在计算机中有行主序存储、列主序存储两种方式，行主序存储即按照顺序逐行存储，列主序存储则按照顺序逐列存储。图形学渲染中我们通常采用的是列主序的方式，<strong>以下的讨论都是列主序的矩阵存储方式。</strong>那么矩阵是如何变换向量的？</p><p>&emsp;&emsp;<strong>向量在几何上能被解释成一系列与轴平行的位移</strong>，一般来说，任意向量$\vec v$都能写成如下的形式：</p><script type="math/tex; mode=display">\vec v=\left[\begin{matrix}x\\y\\z\end{matrix}\right]=\left[\begin{matrix}x\\0\\0\end{matrix}\right]+\left[\begin{matrix}0\\y\\0\end{matrix}\right]+\left[\begin{matrix}0\\0\\z\end{matrix}\right]=x\left[\begin{matrix}1\\0\\0\end{matrix}\right]+y\left[\begin{matrix}0\\1\\0\end{matrix}\right]+z\left[\begin{matrix}0\\0\\1\end{matrix}\right] \tag {1}</script><p>&emsp;&emsp;公式$(1)$右边的单位向量就是$x$、$y$、$z$轴方向的向量，<strong>向量的每个坐标都表明了平行于相应坐标轴的有向位移</strong>。我们记$\vec p$、$\vec q$、$\vec r$分别为公式$(1)$中右边的$x$、$y$、$z$轴的单位列向量，则有：</p><script type="math/tex; mode=display">\vec v=x\vec p+y\vec q+z\vec r=\left[\begin{matrix}\vec p &\vec q&\vec r\end{matrix}\right]\left[\begin{matrix}x \\y\\z\end{matrix}\right] \tag {2}</script><p>&emsp;&emsp;向量$\vec v$就变成了向量$\vec p$、$\vec q$、$\vec r$的线性表示，向量$\vec p$、$\vec q$、$\vec r$称作基向量。以上仅仅讨论的是笛卡尔坐标系，但更通用的情况是，一个$3$维坐标系能用任意$3$个线性无关的基向量表示，以列向量$\vec p$、$\vec q$、$\vec r$构建$3\times 3$的矩阵$M$：</p><script type="math/tex; mode=display">M=\left[\begin{matrix}\vec p &\vec q&\vec r\end{matrix}\right]=\left[\begin{matrix}p_x &q_x&r_x\\p_y &q_y&r_y\\p_z &q_z&r_z\end{matrix}\right] \tag {3}</script><p>&emsp;&emsp;结合公式$(2)$和公式$(3)$，即有：</p><script type="math/tex; mode=display">\vec v=M\left[\begin{matrix}x \\y\\z\end{matrix}\right] \tag{4}</script><p>&emsp;&emsp;坐标系变换矩阵的每一列（如果是行主序，就是每一行）都是该坐标系的基向量，一个点$v$右乘该矩阵就相当于执行了一次坐标系转换。<strong>求解线性变换矩阵的关键就是根据当前的坐标系求解变换之后的坐标系的基向量，然后将基向量填入向量位置！</strong></p><p>&emsp;&emsp;一个矩阵类通常有如下方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix4x4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> entries[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Matrix4x4()&#123;loadIdentity();&#125;</span><br><span class="line">    Matrix4x4(<span class="keyword">float</span> e0, <span class="keyword">float</span> e1, <span class="keyword">float</span> e2, <span class="keyword">float</span> e3,</span><br><span class="line">              <span class="keyword">float</span> e4, <span class="keyword">float</span> e5, <span class="keyword">float</span> e6, <span class="keyword">float</span> e7,</span><br><span class="line">              <span class="keyword">float</span> e8, <span class="keyword">float</span> e9, <span class="keyword">float</span> e10,<span class="keyword">float</span> e11,</span><br><span class="line">              <span class="keyword">float</span> e12,<span class="keyword">float</span> e13,<span class="keyword">float</span> e14,<span class="keyword">float</span> e15);</span><br><span class="line">    Matrix4x4(<span class="keyword">const</span> <span class="keyword">float</span> *rhs);</span><br><span class="line">    Matrix4x4(<span class="keyword">const</span> Matrix4x4 &amp;rhs);</span><br><span class="line">    ~Matrix4x4() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEntry</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getEntry</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector4D <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector4D <span class="title">getColumn</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadIdentity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadZero</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>-(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Matrix4x4 &amp; rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Matrix4x4 &amp; rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> Matrix4x4 &amp; rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs);</span><br><span class="line"></span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> (*<span class="keyword">this</span>);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>*(<span class="keyword">const</span> Vector4D rhs) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inverse, transpose</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inverted</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getInverse</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getTranspose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invertTranspose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getInverseTranspose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operation on space</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTranslation</span><span class="params">(<span class="keyword">const</span> Vector3D &amp; translation)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setScale</span><span class="params">(<span class="keyword">const</span> Vector3D &amp; scaleFactor)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationAxis</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle, <span class="keyword">const</span> Vector3D &amp; axis)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationX</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationY</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationZ</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationEuler</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angleX, <span class="keyword">const</span> <span class="keyword">double</span> angleY, <span class="keyword">const</span> <span class="keyword">double</span> angleZ)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPerspective</span><span class="params">(<span class="keyword">float</span> fovy, <span class="keyword">float</span> aspect, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPerspective</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOrtho</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1、线性变换、仿射变换"><a href="#1、线性变换、仿射变换" class="headerlink" title="1、线性变换、仿射变换"></a>1、线性变换、仿射变换</h2><p>&emsp;&emsp;满足$F(a+b)=F(a)+F(b)$和$F(ka)=kF(a)$的映射$F(a)$就是线性的。对于映射$F(a)=Ma$，当$M$为任意方阵时，也可以说明$F$映射是一个线性变换。在计算机图形学中，缩放、旋转的变换操作都是线性的，但是<strong>平移不是线性变换</strong>。</p><p>&emsp;&emsp;具有$v’=Mv’+b$形式的变换都是仿射变换。平移作为最常用的变换之一，然而却不是线性变换；所以为了包括平移变换提出了仿射变换。仿射变换是指线性变换后接着平移。因此，仿射变换的集合是线性变换的超集，任何线性变换都是仿射变换，但不是所有的仿射变换都是线性变换。<strong>为了统一用矩阵表示低维度的仿射变换，我们可以通过高维度的线性变换来完成，为此引入了$4$维齐次坐标。</strong>（当然引入第$4$维$w$还有其他的用途，如当$w=0$时，可解释为无穷远的“点”，其意义是描述方向），关于齐次坐标的更多内容请查看<a href="https://www.cnblogs.com/J1ac/p/9340622.html" target="_blank" rel="noopener">这里</a>。</p><p>&emsp;&emsp;从而，对于高维度来说只是经历了一次切变+投影变换就可以实现低维度的平移（更多内容查看<a href="https://www.matongxue.com/madocs/244.html#/madoc" target="_blank" rel="noopener">这里</a>），在$3D$渲染中，我们采用$4\times 4$的矩阵做相应的变换。关于平移和缩放不再赘述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setTranslation(<span class="keyword">const</span> Vector3D &amp;translation)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">12</span>] = translation.x;</span><br><span class="line">    entries[<span class="number">13</span>] = translation.y;</span><br><span class="line">    entries[<span class="number">14</span>] = translation.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4x4::setScale(<span class="keyword">const</span> Vector3D &amp;scaleFactor)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  = scaleFactor.x;</span><br><span class="line">    entries[<span class="number">5</span>]  = scaleFactor.y;</span><br><span class="line">    entries[<span class="number">10</span>] = scaleFactor.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、绕任意轴旋转"><a href="#2、绕任意轴旋转" class="headerlink" title="2、绕任意轴旋转"></a>2、绕任意轴旋转</h2><p>&emsp;&emsp;在3D中，绕坐标轴旋转，而不是绕点旋转，此时首先需要定义的是何为旋转正方向： 左手坐标系中定义此方向的规则为左手法则。首先，要明确旋转轴指向哪个方向。当然，旋转轴在理论上是无限延伸的，但我们还是要认为它有正端点和负端点。与笛卡尔坐标轴定义坐标系相同，左手法则是这样的:伸出左手，大拇指向上，其余手指弯曲。大拇指指向旋转轴的正方向，此时，四指弯曲的方向就是旋转的正方向。<strong>右手坐标系则根据右手法则利用右手判断旋转正方向，本文讨论的是常见的右手坐标系。</strong></p><p> &emsp;&emsp;在旋转变换中，一个常见的特殊情况就是绕$x$轴、绕$y$轴、绕$z$轴旋转，这类的旋转矩阵求解比较简单，只需牢牢记住<strong>列主序矩阵的列向量就是变换后的坐标系的基向量</strong>即可快速推导出相应的旋转矩阵：</p><script type="math/tex; mode=display">R_x(\theta)=\left[\begin{matrix}1&0&0\\0&cos\theta&-sin\theta\\0&sin\theta&cos\theta \end{matrix}\right]\\R_y(\theta)=\left[\begin{matrix}cos\theta&0&sin\theta\\0&1&0\\-sin\theta&0&cos\theta \end{matrix}\right]\\R_z(\theta)=\left[\begin{matrix}cos\theta&-sin\theta&0\\sin\theta&cos\theta&0\\0&0&1\end{matrix}\right] \tag {5}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationX(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">5</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">6</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">9</span>]  = -entries[<span class="number">6</span>];</span><br><span class="line">    entries[<span class="number">10</span>] =  entries[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationY(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">2</span>]  = -<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">8</span>]  = -entries[<span class="number">2</span>];</span><br><span class="line">    entries[<span class="number">10</span>] =  entries[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationZ(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">1</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">4</span>]  = -entries[<span class="number">1</span>];</span><br><span class="line">    entries[<span class="number">5</span>]  =  entries[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是更一般的情况是绕任意轴进行旋转，构建这样的矩阵稍微有点麻烦，我们接下来就做一些绕任意轴旋转的矩阵构建推到。在这里我们不考虑平移，因而围绕旋转的轴一定是通过原点的。如下图1所示，将$\vec v$旋转到$\vec v ‘$，任意轴用单位向量$\vec n$表示，绕$\vec n$旋转$\theta$角度的矩阵记为$R(\vec n, \theta)$，$\vec v’$是向量绕轴$\vec n$旋转后的向量，即$\vec v’=R(\vec n,\theta)\vec v$。</p><p><img src="https://img-my.csdn.net/uploads/201304/08/1365419995_7039.png" alt="img"></p><center>图1 绕任意轴旋转</center><p>&emsp;&emsp;<strong>我们的目标就是用$\vec v$、$\vec n$和$\theta$来表示$\vec v’$，从而构造出$R(\vec n, \theta)$。</strong>首先将$\vec v$分解成平行于$\vec n$的向量$\vec v_{||}$和垂直于$\vec n$的分量$\vec v_{⊥}$，而$\vec v’_{⊥}$是垂直于$\vec n$的分向量。注意，$\vec n$是单位向量，但$\vec v$不是单位向量，可得$\vec v$在$\vec n$方向的投影向量$\vec v_{||}$为：</p><script type="math/tex; mode=display">\vec v_{||}=(\vec v\cdot\vec n)\vec n \tag {6}</script><p>&emsp;&emsp;从而根据$\vec v_{||}$和$\vec v$可知$\vec v_{⊥}$和$w$，$w$是垂直于$\vec n$和$\vec v_{⊥}$的向量：</p><script type="math/tex; mode=display">\vec v_{⊥}=\vec v-\vec v_{||} \tag {7}</script><script type="math/tex; mode=display">w=\vec n \times \vec v_{⊥} = \vec n\times (\vec v-\vec v_{||})\\=\vec n\times\vec v-\vec n\times\vec v_{||}=\vec n\times\vec v-0=\vec n\times \vec v \tag{8}</script><p>&emsp;&emsp;$\vec w$和$\vec v_{⊥}$相互垂直，$\vec w$、$\vec v_{⊥}$和$\vec v’_{⊥}$在同一个平面上，$\vec v’_{⊥}$和$\vec v_{⊥}$的夹角为$\theta$，从而$\vec v’_{⊥}$可由$\vec w$和$\vec v_{⊥}$线性表示为：</p><script type="math/tex; mode=display">\vec v'_{⊥}=cos\theta\vec v_{⊥}+sin\theta\vec w\\=cos\theta(\vec v-(\vec v\cdot\vec n)\vec n)+sin\theta(\vec n\times\vec v)\tag {9}</script><p>&emsp;&emsp;最后，根据公式$(6)$和公式$(9)$我们已知$\vec v_{||}$和$\vec v’_{⊥}$，从而可以得出$\vec v’$：</p><script type="math/tex; mode=display">\vec v'=\vec v_{||}+\vec v'_{⊥}\\=cos\theta(\vec v-(\vec v\cdot\vec n)\vec n)+sin\theta(\vec n\times\vec v)+(\vec v\cdot\vec n)\vec n \tag {10}</script><p>&emsp;&emsp;由公式$(10)$可知，我们已经用$\vec v$、$\vec n$和$\theta$表示$\vec v’$，那如何根据上述的公式$(10)$构建旋转矩阵$R(\vec n, \theta)$？还是那个思路：<strong>列主序变换矩阵的列向量就是变换后的坐标系的基向量</strong>。我们只需求出笛卡尔坐标系的$\vec x$、$\vec y$、$\vec z$三个轴方向上的基向量按照公式$(10)$旋转之后的基向量$\vec x’$、$\vec y’$、$\vec z’$，然后填入矩阵$R(\vec n, \theta)$即可，以$\vec x=[1\ \ 0 \ \ 0]^T$为例：</p><script type="math/tex; mode=display">\vec x'=cos\theta(\vec x-(\vec x\cdot\vec n)\vec n)+sin\theta(\vec n\times\vec x)+(\vec x\cdot\vec n)\vec n=\left[\begin{matrix}n^2_x(1-cos\theta)+cos\theta \\n_xn_y(1-cos\theta)+n_zsin\theta \\n_xn_z(1-cos\theta)-n_ysin\theta) \end{matrix}\right] \tag {11}</script><p>&emsp;&emsp;$\vec y=[0\ \  1\ \  0]^T$和$\vec z=[0\ \  0\ \  1]^T$同理：</p><script type="math/tex; mode=display">\vec y'=\left[\begin{matrix}n_xn_y(1-cos\theta)-n_zsin\theta\\n^2_y(1-cos\theta)+cos\theta\\n_yn_z(1-cos\theta)+n_xsin\theta\end{matrix}\right] \tag {12}</script><script type="math/tex; mode=display">\vec z'=\left[\begin{matrix}n_xn_z(1-cos\theta)+n_ysin\theta\\n_yn_z(1-cos\theta)-n_xsin\theta\\n^2_z(1-cos\theta)+cos\theta\end{matrix}\right] \tag {13}</script><p>&emsp;&emsp;将$\vec x’$、$\vec y’$、$\vec z’$合并到$R(\vec n, \theta)$中：</p><script type="math/tex; mode=display">R(\vec n, \theta)=\left[\begin{matrix}\vec x'&\vec y'&\vec z'\end{matrix}\right]\\=\begin{bmatrix}{n_x}^2(1-cos\theta)+cos\theta&n_xn_y(1-cos\theta)-n_zsin\theta&n_xn_z(1-cos\theta)+n_ysin\theta\\n_xn_y(1-cos\theta)+n_zsin\theta&n^2_y(1-cos\theta)+cos\theta&n_yn_z(1-cos\theta)-n_xsin\theta\\n_xn_z(1-cos\theta)-n_ysin\theta)&n_yn_z(1-cos\theta)+n_xsin\theta&n^2_z(1-cos\theta)+cos\theta\end{bmatrix} \tag {14}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationAxis(<span class="keyword">const</span> <span class="keyword">double</span> angle, <span class="keyword">const</span> Vector3D &amp;axis)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3D u = axis.getNormalized();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sinAngle = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    <span class="keyword">float</span> cosAngle = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    <span class="keyword">float</span> oneMinusCosAngle = <span class="number">1.0f</span> - cosAngle;</span><br><span class="line"></span><br><span class="line">    loadIdentity();</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">0</span>]  = (u.x)*(u.x) + cosAngle*(<span class="number">1</span>-(u.x)*(u.x));</span><br><span class="line">    entries[<span class="number">4</span>]  = (u.x)*(u.y)*(oneMinusCosAngle) - sinAngle*u.z;</span><br><span class="line">    entries[<span class="number">8</span>]  = (u.x)*(u.z)*(oneMinusCosAngle) + sinAngle*u.y;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">1</span>]  = (u.x)*(u.y)*(oneMinusCosAngle) + sinAngle*u.z;</span><br><span class="line">    entries[<span class="number">5</span>]  = (u.y)*(u.y) + cosAngle*(<span class="number">1</span>-(u.y)*(u.y));</span><br><span class="line">    entries[<span class="number">9</span>]  = (u.y)*(u.z)*(oneMinusCosAngle) - sinAngle*u.x;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">2</span>]  = (u.x)*(u.z)*(oneMinusCosAngle) - sinAngle*u.y;</span><br><span class="line">    entries[<span class="number">6</span>]  = (u.y)*(u.z)*(oneMinusCosAngle) + sinAngle*u.x;</span><br><span class="line">    entries[<span class="number">10</span>] = (u.z)*(u.z) + cosAngle*(<span class="number">1</span>-(u.z)*(u.z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、透视投影、正交投影"><a href="#3、透视投影、正交投影" class="headerlink" title="3、透视投影、正交投影"></a>3、透视投影、正交投影</h2><p>&emsp;&emsp;$3D$空间中的物体最终都要通过投影显示到$2D$的屏幕上，这一过程就是投影变换。投影变换矩阵将视图空间中的顶点数据变换到裁剪空间，裁剪空间中的顶点最后通过透视除法被变换到标准化设备坐标（$NDC$）。通常由两类投影：透视投影、正交投影。</p><h3 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h3><p>&emsp;&emsp;关于透视投影矩阵的前世今生我不过多说，直接上透视投影矩阵的推导过程。一个视锥体我们目前用六个参数表示：$left$，$right$，$bottom$，$top$，$near$，$far$，简写为$l$、$r$、$b$、$t$、$n$和$f$，即视锥体的六个面。<strong>我们的目标就是将视图空间中在视锥体内的点变换到标准化设备坐标中的立方体内。</strong>即$x$轴方向从$[l,r]$映射到$[-1,1]$，$y$轴方向从$[b,t]$映射到$[-1,1]$，$z$轴方向从$[-n,-f]$映射到$[-1,1]$。</p><p>&emsp;&emsp;<strong>可能你会觉得奇怪，$z$轴方向为什么是从$[-n,-f]$映射到$[-1,1]$？这是因为摄像机空间的坐标系是右手坐标系，在视图空间中摄像机是朝向视图坐标系的$z$轴的负方向，如下图左边所示，$+Y$、$+Z$、$+X$标准摄像机坐标系的三个轴，而摄像机的观察视锥体是朝向$-Z$方向的。而$NDC$又是左手坐标系，朝向$+Z$方向，所以我们要取负。</strong></p><p><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix01.png" alt="OpenGL Perspective Frustum and NDC"></p><center>图2 透视投影视锥和标准化设备坐标</center><p><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix03.png" alt="Top View of Frustum"></p><center>图3 从-Y方向看去的视锥横截面</center><p><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix04.png" alt="Side View of Frustum"></p><center>图4 从-X方向看去的视锥横截面</center><p>&emsp;&emsp;在视锥体中的顶点$(x_e,y_e,z_e)$被投影到视锥体的近平面，近平面上的点我们记为$(x_p,y_p,-n)$。如图3和图4所示，根据三角形相似的原理，我们有：</p><script type="math/tex; mode=display">\frac{x_p}{x_e}=\frac{-n}{z_e}\ \rightarrow\ x_p=\frac{-n\cdot x_e}{z_e}=\frac{n\cdot x_e}{-z_e} \tag {15}</script><script type="math/tex; mode=display">\frac{y_p}{y_e}=\frac{-n}{y_e}\ \rightarrow\ y_p=\frac{-n\cdot y_e}{z_e}=\frac{n\cdot y_e}{-z_e} \tag {16}</script><p>&emsp;&emsp;注意到公式$(15)$和$(16)$中分母都是一个$-z_e$，这与我们将裁剪空间中的顶点做透视除法相对应，透视投影然后做透视除法如下公式$(17)$、$(18)$所示：</p><script type="math/tex; mode=display">\left(\begin{matrix}x_{clip}\\y_{clip}\\z_{clip}\\w_{clip}\end{matrix}\right)=M_{projection}\cdot\left(\begin{matrix}x_{eye}\\y_{eye}\\z_{eye}\\w_{eye}\end{matrix}\right) \tag {17}</script><script type="math/tex; mode=display">\left(\begin{matrix}x_{ndc}\\y_{ndc}\\z_{ndc}\end{matrix}\right)=\left(\begin{matrix}x_{clip}/w_{clip}\\y_{clip}/w_{clip}\\z_{clip}/w_{clip}\end{matrix}\right) \tag {18}</script><p>&emsp;&emsp;为了便于构建矩阵（$x_e$和$y_e$均与$-z_e$相除，不好构建矩阵），我们令裁剪空间中的$w_{clip}$为$-z_e$，将除以$-z_e$的这一步挪到了透视除法去做。故目前的透视矩阵就变为：</p><script type="math/tex; mode=display">\left(\begin{matrix}x_{c}\\y_{c}\\z_{c}\\w_{c}\end{matrix}\right)=\left(\begin{matrix}.&.&.&.\\.&.&.&.\\.&.&.&.\\0&0&-1&0\end{matrix}\right)    \left(\begin{matrix}x_{e}\\y_{e}\\z_{e}\\w_{e}\end{matrix}\right) \tag  {19}</script><p>&emsp;&emsp;其中”$.$”均表示未知。得到在近平面的$x_p$和$y_p$之后，我们还要将$x_p$映射到$[-1,1]$范围，同理$y_p$也是。以$x_p$为例，我们知道其值域为$[l,r]$。为了将$x_p$其映射到$[-1,1]$，我们首先将其映射到$[0,1]$，不难得到如下式子：</p><script type="math/tex; mode=display">\frac{x_p-l}{r-l}\in[0,1] \tag {20}</script><p>&emsp;&emsp;式$(20)$乘上一个$2$再减去$1$就映射到了$[-1,1]$，映射之后记为$x_n$：</p><script type="math/tex; mode=display">x_n=2\frac{x_p-l}{r-l}-1=\frac{2x_p}{r-l}-\frac{r+l}{r-l}\in[-1,1] \tag {21}</script><p>&emsp;&emsp;同理$y_p$到$y_n$的映射：</p><script type="math/tex; mode=display">y_n=\frac{2y_p}{r-l}-\frac{t+b}{t-b}\in[-1,1] \tag {22}</script><p>&emsp;&emsp;然后将公式$(15)$中的$x_p$带入公式$(21)$，将公式$(16)$中的$y_p$带入公式$(22)$，以$x_p$为例：</p><script type="math/tex; mode=display">x_n=\frac{2x_p}{r-l}-\frac{r+l}{r-l}=\frac{2\frac{n\cdot x_e}{-z_e}}{r-l}-\frac{r+l}{r-l}\\=\frac{2n\cdot x_e}{(r-l)(-z_e)}-\frac{r+l}{r-l}=\frac{\frac{2n}{r-l}\cdot x_e}{-z_e}-\frac{r+l}{r-l}\\=\frac{\frac{2n}{r-l}\cdot x_e}{-z_e}+\frac{\frac{r+l}{r-l}\cdot z_e}{-z_e}=\underbrace{(\frac{2n}{r-l}\cdot x_e+\frac{r+l}{r-l}\cdot z_e)}_{x_c}/-z_e \tag {23}</script><p>&emsp;&emsp;其中$x_c$即公式$(19)$中的裁剪空间中的$x$轴坐标值。$y_p$同理可得$y_c$:</p><script type="math/tex; mode=display">y_n=\underbrace{(\frac{2n}{t-b}\cdot y_e+\frac{t+b}{t-b}\cdot z_e)}_{y_c}/-z_e \tag {24}</script><p>&emsp;&emsp;现在我们已经知道了$x_c$和$y_c$分辨关于$x_e$、$y_e$以及$z_e$的表达形式，我们可以填充式$(19)$中的投影矩阵第一行与第二行：</p><script type="math/tex; mode=display">\left(\begin{matrix}x_{c}\\y_{c}\\z_{c}\\w_{c}\end{matrix}\right)=\left(\begin{matrix}\frac{2n}{r-l}&0&\frac{r+l}{r-l}&0\\0&\frac{2n}{t-b}&\frac{t+b}{t-b}&0\\0&0&A&B\\0&0&-1&0\end{matrix}\right)    \left(\begin{matrix}x_{e}\\y_{e}\\z_{e}\\w_{e}\end{matrix}\right) \tag  {25}</script><p>&emsp;&emsp;现在我们还剩下投影矩阵的第三行还不知道。因为我们知道$z$的投影与$x_e$和$y_e$无关，只与$z_e$、$w_e$有关，故可以假设投影矩阵的第三行如上式$(25)$所示，$A$和$B$就是我们假设的要求解的未知表达式。此外，在视图空间中的$w_e$是等于$1$的，$w_c$即前面提到的$-z_e$，从而有：</p><script type="math/tex; mode=display">z_n=z_c/w_c=\frac{Az_e+Bw_e}{-z_e}=\frac{Az_e+B}{-z_e} \tag {26}</script><p>&emsp;&emsp;为了求出公式$(26)$中的$A$和$B$，我们取两个极端的例子：在$-n$处的$z$值被映射到$-1$，在$-f$处的$z$值被映射到$1$，将$(z_n,z_e)=(-1,-n)$和$(z_n,z_e)=(1,-f)$带入式$(26)$中，可得方程组：</p><script type="math/tex; mode=display">\begin{cases}\frac{-An+B}{n}=-1\\\frac{-Af+B}{f}=1\\\end{cases}\ \rightarrow\ \begin{cases}{-An+B}=-n\\{-Af+B}=f\\\end{cases} \tag {27}</script><p>&emsp;&emsp;求解方程$(27)$，可得$A$与$B$如下所示：</p><script type="math/tex; mode=display">A=-\frac{f+n}{f-n}\\B=-\frac{2fn}{f-n} \tag {28}</script><p>&emsp;&emsp;将公式$(28)$带入公式$(26)$中：</p><script type="math/tex; mode=display">z_n=\underbrace{(-\frac{f+n}{f-n}z_e-\frac{2fn}{f-n})}_{z_c}/{-z_e} \tag {29}</script><p>&emsp;&emsp;我们最终得到了$z_c$关于$z_e$的表达式，将$A$与$B$填入式$(25)$的投影矩阵即可，$M_{projection}$就是我们一直在寻求的透视投影矩阵：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2n}{r-l}&0&\frac{r+l}{r-l}&0\\0&\frac{2n}{t-b}&\frac{t+b}{t-b}&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)     \tag {30}</script><p>&emsp;&emsp;公式$(30)$中的透视投影矩阵只是一个通用的形式，在视图空间中的视锥体通常都是关于$x$轴和$y$轴对称的，从而有$r=-l$、$t=-b$，将式$(30)$简化成如下形式：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2n}{r-l}&0&0&0\\0&\frac{2n}{t-b}&0&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)     \tag {31}</script><p>&emsp;&emsp;&emsp;但是通常我们传入构建透视矩阵函数的参数是$fovy$（$y$轴方向的视域角）、$aspect$（屏幕的宽高比）、$near$（近平面）以及$far$（远平面），如何根据这些参数构造式$(31)$的透视投影矩阵呢？注意到$r-l=width$即近平面宽度，$t-b=height$即近平面的高度，我们可以根据$fovy$和$aspect$得出$width$和$height$，具体细节不再赘述：</p><script type="math/tex; mode=display">r-l=width=2*near*aspect*tan(fovy/2)\\t-b=height=2*near*tan(fovy/2)</script><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{1}{aspect*tan(fovy/2)}&0&0&0\\0&\frac{1}{tan(fovy/2)}&0&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)     \tag {32}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setPerspective(<span class="keyword">float</span> fovy, <span class="keyword">float</span> aspect, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span><br><span class="line">&#123;</span><br><span class="line">    loadZero();</span><br><span class="line">    <span class="comment">// convert fov from degrees to radians</span></span><br><span class="line">    <span class="keyword">float</span> rFovy = fovy*M_PI/<span class="number">180</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> tanHalfFovy = tanf(<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(rFovy*<span class="number">0.5f</span>));</span><br><span class="line">    entries[<span class="number">0</span>]         = <span class="number">1.0f</span>/(aspect*tanHalfFovy);</span><br><span class="line">    entries[<span class="number">5</span>]         = <span class="number">1.0f</span>/(tanHalfFovy);</span><br><span class="line">    entries[<span class="number">10</span>]        = -(far+near)/(far-near);</span><br><span class="line">    entries[<span class="number">11</span>]        = <span class="number">-1.0f</span>;</span><br><span class="line">    entries[<span class="number">14</span>]        = (<span class="number">-2.0f</span>*near*far)/(far-near);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h3><p>&emsp;&emsp;理解了透视投影矩阵的构造之后，正交投影就简单太多了，正交投影只需做简单的线性映射就行了。只需将$x$轴方向从$[l,r]$映射到$[-1,1]$，$y$轴方向从$[b,t]$映射到$[-1,1]$，$z$轴方向从$[-n,-f]$映射到$[-1,1]$，而这个映射的过程很简单，正如前面公式$(20)$和$(21)$那样，先映射到$[0,1]$，再映射到$[0,2]$，最后映射到$[-1,1]$，这个过程我也不细说了，直接上结果：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2}{r-l}&0&0&-\frac{r+l}{r-l}\\0&\frac{2}{t-b}&0&-\frac{t+b}{t-b}\\0&0&\frac{-2}{f-n}&-\frac{f+n}{f-n}\\0&0&0&1\end{matrix}\right)     \tag {33}</script><p>&emsp;&emsp;然后又因为视锥体关于$x$轴、$y$轴对称，简化的正交投影矩阵就为：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2}{r-l}&0&0&0\\0&\frac{2}{t-b}&0&0\\0&0&\frac{-2}{f-n}&-\frac{f+n}{f-n}\\0&0&0&1\end{matrix}\right)     \tag {33}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setOrtho(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]     =  <span class="number">2.0f</span>/(right-left);</span><br><span class="line">    entries[<span class="number">5</span>]     =  <span class="number">2.0f</span>/(top-bottom);</span><br><span class="line">    entries[<span class="number">10</span>]    = <span class="number">-2.0f</span>/(far-near);</span><br><span class="line">    entries[<span class="number">12</span>]    = -(right+left)/(right-left);</span><br><span class="line">    entries[<span class="number">13</span>]    = -(top+bottom)/(top-bottom);</span><br><span class="line">    entries[<span class="number">14</span>]    = -(far+near)/(far-near);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、lookAt函数构造视图矩阵"><a href="#4、lookAt函数构造视图矩阵" class="headerlink" title="4、lookAt函数构造视图矩阵"></a>4、lookAt函数构造视图矩阵</h2><p>&emsp;&emsp;视图矩阵的工作目标是将世界坐标系中的所有物体的顶点的坐标从世界坐标系转换到摄像机坐标系。这是因为摄像机坐标系的原点不一定与世界坐标系重合，同时由于自身的旋转，坐标轴也一定不与世界坐标系的坐标轴平行。为完成工作任务，需要分为两步走：首先整体平移，将摄像机平移至世界坐标系原点，然后将顶点从世界坐标系变换至摄像机坐标系。</p><p>&emsp;&emsp;lookAt函数的输入参数分别为：$eye$摄像机的位置，$target$摄像机目标点，$up$世界空间的上向量,。首先我们要根据这些参数确定摄像机坐标系的三个轴向量，<strong>其中需要非常注意的就是变换到视图空间中时摄像机是朝向视图空间的$-Z$方向的，所以求视图空间中的$Z$轴时是摄像机的位置减去目标点的位置</strong>：</p><script type="math/tex; mode=display">Z = normalize(eye - target)\\X = normalize(cross(up, Z))\\Y = normalize(cross(Z,X))</script><p>&emsp;&emsp;通过以上的方式我们就求出了视图空间的三条轴向量，再加上摄像机的位置我们就可以求出将世界坐标变换到与视图坐标重合的矩阵了，记为$M=T\cdot R$，其中$T$是平移到摄像机位置$eye$的变换矩阵，$R$是旋转到摄像机坐标轴方向的旋转矩阵：</p><script type="math/tex; mode=display">M=T\cdot R=\left[\begin{matrix}1&0&0&eye_x\\0&1&0&eye_x\\0&0&1&eye_x\\0&0&0&1\end{matrix}\right]\cdot\left[\begin{matrix}X_x&Y_x&Z_x&0\\X_y&Y_y&Z_y&0\\X_z&Y_z&Z_z&0\\0&0&0&1\end{matrix}\right] \tag {34}</script><p>&emsp;&emsp;<strong>然而公式$(34)$并不是我们要求的视图矩阵，上式中的矩阵$M$仅仅是将世界坐标轴变换到摄像机坐标轴。摄像机只是一个虚拟的物品，我们不能将上述的矩阵$M$作用于摄像机，因为摄像机根本不存在！我们视图矩阵最终作用的世界空间中的物体，这就涉及到了一个相对运动的概念！</strong></p><p>&emsp;&emsp;<strong>当我们向前移动摄像机的时候，可以看成是摄像机不动，而物体朝着与摄像机朝向相反的方向移动。当我们向右旋转摄像机时，相当于摄像机不动而物体朝着摄像机的左边移动。摄像机的构造得益于相对于运动的理论，计算机图形学中的虚拟$3D$摄像机实际上是通过物体的移动来实现的，所以我们要构造的视图矩阵是公式$(34)$中的逆矩阵。</strong></p><script type="math/tex; mode=display">viewMatrix = M^{-1}=(T\cdot R)^{-1}=R^{-1}\cdot T^{-1}=\left[\begin{matrix}X_x&Y_x&Z_x&0\\X_y&Y_y&Z_y&0\\X_z&Y_z&Z_z&0\\0&0&0&1\end{matrix}\right]^{-1}\cdot\left[\begin{matrix}1&0&0&eye_x\\0&1&0&eye_x\\0&0&1&eye_x\\0&0&0&1\end{matrix}\right]^{-1} \tag {35}</script><p>&emsp;&emsp;由上式可知，构造视图矩阵涉及到$R$和$T$的求逆，其中的平移矩阵$T$的求逆则是直接取平移量的相反数即可：</p><script type="math/tex; mode=display">T^{-1}=\left[\begin{matrix}1&0&0&eye_x\\0&1&0&eye_x\\0&0&1&eye_x\\0&0&0&1\end{matrix}\right]^{-1}=\left[\begin{matrix}1&0&0&-eye_x\\0&1&0&-eye_x\\0&0&1&-eye_x\\0&0&0&1\end{matrix}\right] \tag {36}</script><p>&emsp;&emsp;至于旋转矩阵$R$，我们知道旋转矩阵都是正交矩阵，正交矩阵的一个特点就是它的逆等于它的转置：</p><script type="math/tex; mode=display">R^{-1}=\left[\begin{matrix}X_x&Y_x&Z_x&0\\X_y&Y_y&Z_y&0\\X_z&Y_z&Z_z&0\\0&0&0&1\end{matrix}\right]^{-1}=\left[\begin{matrix}X_x&X_y&X_z&0\\Y_x&Y_y&Y_z&0\\Z_x&Z_y&Z_z&0\\0&0&0&1\end{matrix}\right] \tag {37}</script><p>&emsp;&emsp;最后，我们得到视图矩阵：</p><script type="math/tex; mode=display">viewMatrix=R^{-1}\cdot T^{-1}=\left[\begin{matrix}X_x&X_y&X_z&0\\Y_x&Y_y&Y_z&0\\Z_x&Z_y&Z_z&0\\0&0&0&1\end{matrix}\right]\cdot\left[\begin{matrix}1&0&0&-eye_x\\0&1&0&-eye_x\\0&0&1&-eye_x\\0&0&0&1\end{matrix}\right]\\=\left[\begin{matrix}X_x&X_y&X_z&-(\vec X\cdot \vec {eye})\\Y_x&Y_y&Y_z&-(\vec Y\cdot \vec {eye})\\Z_x&Z_y&Z_z&-(\vec Z\cdot \vec {eye})\\0&0&0&1\end{matrix}\right] \tag {38}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setLookAt(Vector3D cameraPos, Vector3D target, Vector3D worldUp)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3D zAxis = cameraPos - target;</span><br><span class="line">    zAxis.normalize();</span><br><span class="line">    Vector3D xAxis = worldUp.crossProduct(zAxis);</span><br><span class="line">    xAxis.normalize();</span><br><span class="line">    Vector3D yAxis = zAxis.crossProduct(xAxis);</span><br><span class="line">    yAxis.normalize();</span><br><span class="line"></span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>] = xAxis.x;</span><br><span class="line">    entries[<span class="number">4</span>] = xAxis.y;</span><br><span class="line">    entries[<span class="number">8</span>] = xAxis.z;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">1</span>] = yAxis.x;</span><br><span class="line">    entries[<span class="number">5</span>] = yAxis.y;</span><br><span class="line">    entries[<span class="number">9</span>] = yAxis.z;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">2</span>] = zAxis.x;</span><br><span class="line">    entries[<span class="number">6</span>] = zAxis.y;</span><br><span class="line">    entries[<span class="number">10</span>] = zAxis.z;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">12</span>] = -(xAxis.dotProduct(cameraPos));</span><br><span class="line">    entries[<span class="number">13</span>] = -(yAxis.dotProduct(cameraPos));</span><br><span class="line">    entries[<span class="number">14</span>] = -(zAxis.dotProduct(cameraPos));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank" rel="noopener">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></p><p>$[2]$ <a href="https://blog.csdn.net/zsq306650083/article/details/8773996" target="_blank" rel="noopener">https://blog.csdn.net/zsq306650083/article/details/8773996</a></p><p>$[3]$ <a href="https://blog.csdn.net/y1196645376/article/details/78463248" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/78463248</a></p><p>$[4]$ <a href="https://www.cnblogs.com/J1ac/p/9340622.html" target="_blank" rel="noopener">https://www.cnblogs.com/J1ac/p/9340622.html</a></p><p>$[5]$ <a href="https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Soft Renderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Soft Renderer </tag>
            
            <tag> 3D Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流体模拟基础</title>
      <link href="/2019/05/01/fluidSimulation/"/>
      <url>/2019/05/01/fluidSimulation/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。</p><a id="more"></a><ul><li>矢量微积分</li><li>Naiver-Stokes偏微分方程组</li><li>N-S方程的分步求解</li><li>对流算法</li></ul><h2 id="一、矢量微积分"><a href="#一、矢量微积分" class="headerlink" title="一、矢量微积分"></a>一、矢量微积分</h2><p>&emsp;&emsp;高等数学中太多数讨论的是一维的微积分，而矢量微积分则是一维微积分的高维扩展。矢量微积分的三个基础算子：<strong>梯度</strong>（符号为$∇$），<strong>散度</strong>（符号为$∇\cdot$)，<strong>旋度</strong>（符号为$∇\times$），在此基础上流体力学中经常用到的还有拉普拉斯算子。</p><h3 id="1、梯度（Gradient）"><a href="#1、梯度（Gradient）" class="headerlink" title="1、梯度（Gradient）"></a>1、梯度（Gradient）</h3><p>&emsp;&emsp;梯度实际上就是矢量的空间偏导数，且结果依然是一个矢量，$2$维的梯度如下：</p><script type="math/tex; mode=display">∇f(x,y)=(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}) \tag {1.1}</script><p>&emsp;&emsp;依此类推，$3$维的梯度有如下形式：</p><script type="math/tex; mode=display">∇f(x,y,z)=(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y},\frac{\partial f}{\partial z}) \tag {1.2}</script><p>&emsp;&emsp;有时也会采用如下形式来表示梯度：</p><script type="math/tex; mode=display">∇f=\frac{\partial f}{\partial \vec x} \tag {1.3}</script><p>&emsp;&emsp;梯度通常用来近似计算函数值（实际上就是一维形式的推广)：</p><script type="math/tex; mode=display">f(\vec x+\Delta \vec x)\approx f(\vec x)+∇f(\vec x)\cdot \Delta \vec x \tag {1.4}</script><p>&emsp;&emsp;同样的，多个函数的梯度就构成了一个矩阵：</p><script type="math/tex; mode=display">∇\vec F=∇(f,g,h)=\left(   \begin{matrix}   \frac{\partial f}{\partial x} & \frac{\partial f}{\partial y} & \frac{\partial f}{\partial z} \\   \frac{\partial g}{\partial x} & \frac{\partial g}{\partial y} & \frac{\partial g}{\partial z} \\   \frac{\partial h}{\partial x} & \frac{\partial h}{\partial y} & \frac{\partial h}{\partial z} \\  \end{matrix}  \right)  =\left( \begin{matrix}∇f\\ ∇g\\ ∇h\\ \end{matrix}  \right) \tag {1.5}</script><h3 id="2、散度（Divergence）"><a href="#2、散度（Divergence）" class="headerlink" title="2、散度（Divergence）"></a>2、散度（Divergence）</h3><p>&emsp;&emsp;散度算子仅仅应用于向量场，它衡量在某一点出相应的矢量聚集或者发散程度，测量方向为<strong>径向</strong>，结果为标量。$2$维、$3$维形式的散度算子如下所示：</p><script type="math/tex; mode=display">∇\cdot \vec u=∇\cdot (u,v)=\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}</script><script type="math/tex; mode=display">∇\cdot \vec u=∇\cdot (u,v,w)=\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}+\frac{\partial w}{\partial z} \tag {1.6}</script><p>&emsp;&emsp;输入是矢量，而输出为标量。类比梯度，散度符号$∇\cdot \vec u$可以理解为梯度$∇$与矢量$\vec u$的点乘：</p><script type="math/tex; mode=display">∇\cdot \vec u=(\frac{\partial}{\partial x},\frac{\partial}{\partial y},\frac{\partial}{\partial z})\cdot (u,v,w)=\frac{\partial}{\partial x}u+\frac{\partial}{\partial y}v+\frac{\partial}{\partial z}w \tag {1.7}</script><p>&emsp;&emsp;若矢量场散度为$0$，则称该矢量场<strong>无散度</strong>。</p><h3 id="3、旋度（Curl）"><a href="#3、旋度（Curl）" class="headerlink" title="3、旋度（Curl）"></a>3、旋度（Curl）</h3><p>&emsp;&emsp;旋度衡量围绕某一点的旋转速度，测量方向为<strong>切向</strong>，三维形式的旋度是一个向量：</p><script type="math/tex; mode=display">∇\times \vec u=∇\times (u,v,w)=(\frac{\partial w}{\partial y}-\frac{\partial v}{\partial z},\frac{\partial u}{\partial z}-\frac{\partial w}{\partial x},\frac{\partial v}{\partial x}-\frac{\partial u}{\partial y}) \tag {1.8}</script><p>&emsp;&emsp;倒推到$2$维，我们取上式中的$w=0$，即矢量场为$(u,v,0)$，$2$维向量场的旋度是一个标量：</p><script type="math/tex; mode=display">∇\times \vec u=∇\times (u,v)=\frac{\partial v}{\partial x}-\frac{\partial u}{\partial y} \tag {1.9}</script><p>&emsp;&emsp;同样地，旋度符号$∇\times \vec u$我们可以理解为梯度$∇$与矢量场$\vec u$的叉乘：</p><script type="math/tex; mode=display">∇\times \vec u=(\frac{\partial }{\partial x},\frac{\partial }{\partial y},\frac{\partial }{\partial z})\times(u,v,w) \tag {1.10}</script><p>&emsp;&emsp;若矢量场旋度为$0$，则称该矢量场<strong>无旋度</strong>。</p><h3 id="4、拉普拉斯算子（Laplacian）"><a href="#4、拉普拉斯算子（Laplacian）" class="headerlink" title="4、拉普拉斯算子（Laplacian）"></a>4、拉普拉斯算子（Laplacian）</h3><p>&emsp;&emsp;拉普拉斯算子定义为梯度的散度，符号表示为$∇\cdot∇$，显然$∇\cdot$是散度，而后面的$∇$则为梯度，故拉普拉斯算子即梯度的散度，是一个二阶微分算子。$2$维、$3$维形式分别如下：</p><script type="math/tex; mode=display">∇\cdot∇f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}</script><script type="math/tex; mode=display">∇\cdot∇f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}+\frac{\partial^2f}{\partial z^2} \tag {1.11}</script><p>&emsp;&emsp;简言之，拉普拉斯算子定义如下：</p><script type="math/tex; mode=display">∇\cdot∇f=\Sigma_{i=1}^n\frac{\partial^2f}{\partial x_i^2} \tag {1.12}</script><p>&emsp;&emsp;偏微分方程$∇\cdot ∇f=0$被称为拉普拉斯方程；而如果右边为某个非$0$常数，即$∇\cdot ∇f=q$，我们称之为泊松方程。更一般地，如果梯度再乘上一个标量$a$（如$1/\rho$)，即$∇\cdot (a∇f)=q$，我们依旧称之为泊松问题。</p><h2 id="二、-Naiver-Stokes-偏微分方程组"><a href="#二、-Naiver-Stokes-偏微分方程组" class="headerlink" title="二、$Naiver-Stokes$偏微分方程组"></a>二、$Naiver-Stokes$偏微分方程组</h2><p>&emsp;&emsp;流体模拟器的构建主要围绕著名的不可压缩$Navier-Stokes$方程展开，它是一个流体力学领域的偏微分方程，方程形式如下：</p><script type="math/tex; mode=display">\frac{\partial \vec u}{\partial t}+\vec u\cdot ∇\vec u+\frac1\rho∇p=\vec g+\nu∇\cdot∇\vec u \tag {2.1}</script><script type="math/tex; mode=display">∇\cdot\vec u=0 \tag {2.2}</script><p>&emsp;&emsp;这个方程组看起非常地复杂，接下来我们就把它剖析成一个个比较简单的部分来理解。</p><h3 id="1、符号标记"><a href="#1、符号标记" class="headerlink" title="1、符号标记"></a>1、符号标记</h3><p>&emsp;&emsp;我们有必要定义一些物理量的符号用以标记：</p><p>&emsp;&emsp;符号$\vec u$在流体力学中通常表示为流体的速度矢量，记$3$维的速度矢量$\vec u=(u,v,w)$；</p><p>&emsp;&emsp;希腊字符$\rho$是流体的密度，对于水，该值大约为$1000kg/m^3$，而空气则大约为$1.3kg/m^3$；</p><p>&emsp;&emsp;字符$p$代表压力，流体对任何物体施加的单位面积力；</p><p>&emsp;&emsp;字符$\vec g$则是我们熟悉的重力加速度，通常取$(0,-9.81,0)m/s^2$。我们约定$y$轴向上，而$x$轴和$z$轴在水平面上。另外补充一点，我们把其他的一些类似的力都累加到$\vec g$上，也就是我们统一用$\vec g$表示所有类似力之和，这类力我们称之为<strong>体积力</strong>（称之为体积力是因为它们的力是作用到整个流体而不只是流体的表面）；</p><p>&emsp;&emsp;希腊字符$\nu$是流体的运动粘度，它衡量流体的黏滞性。糖蜜之类的流体有非常高的粘度，而像酒精之类的流体有很低的粘度；</p><p>&emsp;&emsp;其它一些矢量微积分的符号算子前面已经提到过，不再赘述。</p><h3 id="2、动量方程"><a href="#2、动量方程" class="headerlink" title="2、动量方程"></a>2、动量方程</h3><p>&emsp;&emsp;偏微分方程$(2.1)$我们称之为<strong>动量方程</strong>，它本质上就是我们熟悉的牛顿定律$\vec F=m\vec a$的形式，描述了施加在流体上的力是如何影响流体的运动。</p><p>&emsp;&emsp;假设我们用粒子系统来模拟流体，每个粒子代表流体的一小滴，每个粒子有各自的质量$m$、体积$V$和速度$\vec u$。为了让整个粒子系统运作起来，我们必须弄清楚每个粒子所承受的力的作用。牛顿第二定律告诉我们：$\vec F=m\vec a$，而根据加速度定义，我们有：</p><script type="math/tex; mode=display">\vec a=\frac{D\vec u}{Dt} \tag {2.3}</script><p>&emsp;&emsp;符号$D$是指<strong>物质导数</strong>，所谓物质导数，就是对流体质点求导数，而且是针对流体质点（在这里就是流体粒子）而不是空间的固定点。因而牛顿第二定律就变成：</p><script type="math/tex; mode=display">m\frac{D\vec u}{Dt}=\vec F \tag {2.4}</script><p>&emsp;&emsp;那么流体粒子承受的力有哪些呢？一个最简单的力就是重力：$m\vec g$。而其他的流体质点（或其他流体粒子）也会对当前的流体粒子产生作用力。流体内部的相互作用力之一便是压力，较大压力的区域会向较低压力区域产生作用力。值得注意的是，我们只关注施加在粒子上的压力的净合力。例如，若施加在粒子上压力在每个方向上都相等，那么它的压力的合力便为0。我们用压力的负梯度（取负是因为方向是由压力大的区域指向压力小的区域）来衡量在当前流体粒子处压力的不平衡性，即取$-∇p$。那么流体粒子所承受的压力就是对$-∇p$在整个流体粒子的体积上进行积分，为了简化，我们简单地将$V$与$-∇p$相乘，故粒子压力部分为$-V∇p$。</p><p>&emsp;&emsp;其他的流体相互作用力则是由流体的黏性产生的，我们直观地把这种力理解为尽可能使得粒子以周围区域的平均速度移动的力，也就是使得粒子的速度与周围区域粒子速度的差距最小化。拉普拉斯算子是衡量一个量与之周围区域该量平均值之差的算符，因而$∇\cdot∇\vec u$是当前粒子速度矢量与周围区域平均速度矢量之差。为了计算粘滞力，我们同样对$∇\cdot∇\vec u$在整个粒子体积$V$上进行积分，与前面类似，我们简单取$V∇\cdot∇\vec u$。除此之外，我们还引进一个称为动力粘度系数的物理量，符号为$\mu$。因而粘滞力为$V\mu∇\cdot∇\vec u$。</p><p>&emsp;&emsp;把重力、压力和粘滞力综合一起，我们可得：</p><script type="math/tex; mode=display">m\frac{D\vec u}{Dt}=\vec F=m\vec g-V∇p+V\mu∇\cdot∇\vec u \tag {2.5}</script><p>&emsp;&emsp;当粒子系统中的粒子数量趋于无穷大，而每个粒子大小趋于$0$时，会产生一个问题：此时每个粒子的质量$m$和体积$V$变为$0$，此时上式变得没有意义。为此，我们把$(2.5)$式调整一下，两边同除以体积$V$，又因$\rho=m/V$，故有：</p><script type="math/tex; mode=display">\rho\frac{D\vec u}{Dt}=\rho\vec g-∇p+\mu∇\cdot∇\vec u \tag {2.6}</script><p>&emsp;&emsp;两边同除以$\rho$，移项调整：</p><script type="math/tex; mode=display">\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g+\frac\mu\rho∇\cdot∇\vec u \tag {2.7}</script><p>&emsp;&emsp;为了进一步简化，定义运动粘度为$\nu=\mu/\rho$，式$(2.7)$变为：</p><script type="math/tex; mode=display">\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g+\nu∇\cdot∇\vec u \tag {2.8}</script><p>&emsp;&emsp;我们已经快把动量方程推导出来，现在我们要把物质导数$\frac{D\vec u}{Dt}$弄清楚，为此，我们需要了解两种描述方法：<strong>拉格朗日描述</strong>和<strong>欧拉描述</strong>。</p><h3 id="3、拉格朗日描述与欧拉描述"><a href="#3、拉格朗日描述与欧拉描述" class="headerlink" title="3、拉格朗日描述与欧拉描述"></a>3、拉格朗日描述与欧拉描述</h3><p>&emsp;&emsp;当我们尝试研究流体或可变形固体的运动的时候，通常有两种方法来描述：<strong>拉格朗日描述</strong>（ Lagrangian viewpoint）、<strong>欧拉描述</strong>（Eulerian viewpoint）。</p><p>&emsp;&emsp;拉格朗日描述方法是我们比较熟悉的方法，这种描述方法把物体看成是由类似于粒子系统的形式组成，固体或流体的每个点看作一个独立的粒子，粒子有各自相应的位置$\vec x$和速度$\vec u$。我们可以把粒子理解为组成物体的分子。对于我们通常采用拉格朗日描述法进行建模模拟，即用一系列离散的粒子集来构建，粒子之间通过网格相联系。</p><p>&emsp;&emsp;欧拉描述方法则采用了完全不同的角度，它常被用于流体力学中。与拉格朗日描述追踪每个物体粒子的方法不同，欧拉描述关注点是空间中的一个固定点，并考察在这个固定点上流体性质（如密度、速度、温度等）是如何随着时间变化的。流体流动经过这个固定点可能会导致这个固定点的物理性质发生一些变化（如一个温度较高的流体粒子流经这个固定点，后面紧跟着一个温度较低的流体粒子流过固定点，那么这个固定点的温度会降低，但是并没有任何一个流体粒子的温度发生了变化）。</p><p>&emsp;&emsp;用天气测量举个简单的例子：拉格朗日描述方法就是你乘坐在一个随风而飘的热气球上，测量周围空气的压力、密度和浑浊度等天气指标；而欧拉描述方法就是你固定在地面上，测量流过的空气的天气指标。</p><p>&emsp;&emsp;欧拉描述法似乎看起来带来了一些不必要的复杂度，但是目前大多数的流体模拟器都是基于欧拉描述法，这是因为欧拉描述法相比于拉格朗日描述法有一些不可比拟的优点：欧拉描述法能够更加方便地计算一些物理量的空间导数（例如压力梯度和粘度）；而如果用粒子方法的话（即拉格朗日描述法），那么计算物理量相对于空间位置的变化是比较难的。</p><p>&emsp;&emsp;把拉格朗日描述法和欧拉描述法联系起来的关键点就是物质导数。首先从拉格朗日描述法出发，假设有一群粒子，每个粒子都有各自的位置$\vec x$和速度$\vec u$。记$q$为通用的物理量（如密度、速度和温度等），每个粒子有其对应的$q$值。方程$q(t,\vec x)$描述在时间点$t$而位置为$\vec x$的粒子对应的物理量值$q$。则一个粒子的物理量$q$随时间$t$的变化率是多少？这是一个拉格朗日描述角度下的问题，我们取对时间$t$的导数（注意用到了求导链式法则，以及$\frac{\partial q}{\partial \vec x}=∇q$和$\vec u=\frac{d\vec x}{dt}）$：</p><script type="math/tex; mode=display">\frac d{dt}q(t,\vec x)=\frac{\partial q}{\partial t}+∇q\cdot\frac{d\vec x}{dt}=\frac{\partial q}{\partial t}+∇q\cdot\vec u\equiv\frac{Dq}{Dt} \tag {2.9}</script><p>&emsp;&emsp;这就是物质导数。把式$(2.9)$代入式$(2.8)$我们就得到了流体动量方程$(2.1)$。物质导数针对的是流体质点（在这里就是流体粒子）而不是空间的固定点。式$(2.9)$写完整一点就是：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}+v\frac{\partial q}{\partial y}+w\frac{\partial q}{\partial z} \tag {2.10}</script><p>&emsp;&emsp;对于给定的速度场$\vec u$， 流体的物理性质如何在这个速度场$\vec u$下变化的计算我们称之为<strong>对流</strong>（advection）。一个最简单的对流方程，就是其物理量的物质导数为$0$，如下所示：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=0\implies\frac{\partial q}{\partial t}+\vec u\cdot ∇q = 0 \tag {2.11}</script><p>&emsp;&emsp;公式$(2.11)$的意义即在拉格朗日视角观察下，每个流体粒子的物理量保持不变。</p><h3 id="4、不可压缩性"><a href="#4、不可压缩性" class="headerlink" title="4、不可压缩性"></a>4、不可压缩性</h3><p>&emsp;&emsp;关于流体的压缩性在此不做过多的物理细节描述，只需知道一点：通常情况下流体的体积变化非常小（除开一些极端的情况，而且这些极端情况我们日常生活中较少出现）。可压缩流体的模拟涉及到非常复杂的情况，往往需要昂贵的计算资源开销，为此在计算机流体模拟中我们通常把所有的流体当作是不可压缩的，即它们的体积不会发生变化。</p><p>&emsp;&emsp;任取流体的一部分，设其体积为$\Omega$而其边界闭合曲面为$\partial\Omega$，我们可以通过围绕边界曲面$\partial\Omega$对流体速度$\vec  u$在曲面法线方向上的分量进行积分来衡量这块部分流体的体积变化速率：</p><script type="math/tex; mode=display">\frac d{dt}Volume(\Omega)=\int\int_{\partial\Omega}\vec u\cdot n \tag{2.12}</script><p>&emsp;&emsp;对于不可压缩的流体，其体积保持为某个常量，故其体积变化速率为$0$：</p><script type="math/tex; mode=display">\int\int_{\partial\Omega}\vec u\cdot n=0 \tag {2.13}</script><p>&emsp;&emsp;由高斯散度定理，我们可以把式$(2.13)$转换为体积分：</p><script type="math/tex; mode=display">\int\int_{\partial\Omega}\vec u\cdot n=\int\int\int_\Omega∇\cdot \vec u=0 \tag{2.14}</script><p>&emsp;&emsp;式$(13)$应该对任意的$\Omega$成立，意即无论$\Omega$取何值，积分值均为$0$。这种情况下只有令积分函数值取$0$方可成立，即对$0$积分无论$\Omega$取何值结果均为$0$。所以有：</p><script type="math/tex; mode=display">∇\cdot \vec u=0 \tag{2.15}</script><p>&emsp;&emsp;这就是$Navier-Stokes$方程中的不可压缩条件$(2.2)$。满足不可压缩条件的速度场被称为是<strong>无散度</strong>的，即在该速度场下流体体积既不膨胀也不坍缩，而是保持在一个常量。模拟不可压缩流体的关键部分就是使得流体的速度场保持无散度的状态，这也是流体内部压力的来源。</p><p>&emsp;&emsp;为了把压力与速度场的散度联系起来，我们在动量方程$(2.1)$两边同时取散度：</p><script type="math/tex; mode=display">∇\cdot\frac{\partial \vec u}{\partial t}+∇\cdot(\vec u\cdot ∇\vec u)+∇\cdot\frac1\rho∇p=∇\cdot(\vec g+\nu∇\cdot∇\vec u) \tag {2.16}</script><p>&emsp;&emsp;对于上式$(2.16)$第一项，我们转变一下求导次序：</p><script type="math/tex; mode=display">\frac {\partial}{\partial t}∇\cdot\vec u \tag {2.17}</script><p>&emsp;&emsp;如果满足流体不可压缩条件，那么式$(2.17)$取值$0$（因为无散度），然后我们调整一下式$(2.16)$可得关于压力的方程：</p><script type="math/tex; mode=display">∇\cdot\frac1\rho∇p=∇\cdot(-\vec u\cdot ∇\vec u+\vec g+\nu∇\cdot∇\vec u) \tag{2.18}</script><h3 id="5、丢弃粘度项"><a href="#5、丢弃粘度项" class="headerlink" title="5、丢弃粘度项"></a>5、丢弃粘度项</h3><p>&emsp;&emsp;在某些流体如蜂蜜、小水珠等的模拟中，粘滞力起着非常重要的作用。但是在大多数流体动画模拟中，粘滞力的影响微乎其微，为此秉持着方程组越简单越好的原则，我们常常丢弃粘度项。当然这也不可避免地带来一些误差，事实上，在计算流体力学中尽可能地减少丢弃粘度项带来的误差是一个非常大的挑战。下面的叙述都是基于丢弃粘度项的前提。</p><p>&emsp;&emsp;丢弃了粘度项的$Navier-Stokes$方程被称为<strong>欧拉方程</strong>，而这种理想的流体则是<strong>无粘度</strong>的。丢弃了粘度项的欧拉方程如下：</p><script type="math/tex; mode=display">\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g \tag {2.19}</script><script type="math/tex; mode=display">∇\cdot\vec u=0 \tag{2.20}</script><p>&emsp;&emsp;<strong>大多数的流体模拟的计算方程都是欧拉方程。</strong></p><h3 id="6、边界条件"><a href="#6、边界条件" class="headerlink" title="6、边界条件"></a>6、边界条件</h3><p>&emsp;&emsp;目前为止我们讨论的都是流体内部的情况，然而边界部分也是流体模拟非常关键的部分。在流体模拟中我们仅仅关注两种边界条件：<strong>固体墙</strong>（solid walls）、<strong>自由面</strong>（free surfaces）。</p><p>&emsp;&emsp;<strong>固体墙</strong>顾名思义就是流体与固体接触的边界，用速度来描述很简单：流体既不会流进固体内部也不会从固体内部流出，因此流体在固体墙法线方向上的分量为$0$：</p><script type="math/tex; mode=display">\vec u\cdot n=0 \tag {2.21}</script><p>&emsp;&emsp;当然，上述是固体自身不移动的情况下。通常来说，流体速度在法线方向上的分量与固体的移动速度在法线方向上的分量应该保持一致：</p><script type="math/tex; mode=display">\vec u\cdot n=\vec u_{solid}\cdot n \tag{2.22}</script><p>&emsp;&emsp;上述的两个公式都是仅对流体速度在法线方向上的分量做了限制，对于无粘度的流体，切线方向上的流体速度与固体的移动速度无必然的联系。</p><p>&emsp;&emsp;<strong>自由面</strong>是另外一个非常重要的边界条件，它通常就是与另外一种流体相接壤的边界部分。例如在模拟水花四溅时，水流表面不与固体接触的都是自由面（如与空气这种流体接触）。因空气密度远小于水导致空气对水体的仿真影响非常小，为了简化模拟，我们将空气所占的空间设为某个固定大气压的区域，设为$0$是最方便的方案，此时自由面就是压强$p=0$的水体表面。</p><p>&emsp;&emsp;在小规模的流体仿真中，自由面的表面张力占据着非常重要的地位。在微观分子层面下，表面张力的存在是因为不同的分子相互吸引产生的力。从几何的角度来解释就是，表面张力就是促使流体的表面积尽可能小的一种力。物理学上，两种不同的流体之间实际上存在着与表面平均曲率成正比的压力骤变：</p><script type="math/tex; mode=display">[p]=\lambda k. \tag {2.23}</script><p>&emsp;&emsp;公式$(2.23)$中的$[p]$记为压力之差。$\lambda$是表面张力系数，可以根据模拟的流体类型查找对应的张力系数（例如空气与水在室温下张力系数为$\lambda \approx 0.073N/m$）。而$k$就是平均曲率，单位为$m^{-1}$。又因为我们常常设空气的压力为$0$，因此水与空气交界的自由面的压力为：</p><script type="math/tex; mode=display">p=\lambda k \tag {2.24}</script><p>​        </p><h2 id="三、N-S方程的分步求解"><a href="#三、N-S方程的分步求解" class="headerlink" title="三、N-S方程的分步求解"></a>三、N-S方程的分步求解</h2><p>&emsp;&emsp;有了对以上对$Navier-Stokes$方程的理论支撑，接下来我们就要如何用计算机来对该组偏微分方程进行离散化求解。为了程序的松耦合性以及使计算尽可能地高效、简单，在流体模型领域，我们将流体方程分成几个独立的步骤，然后按顺序先后推进。对于不可压缩的无粘度流体方程（即前面的欧拉方程$(2.19)$和$(2.20)$，我们将其离散化成对流项（advection）如公式$(3.1)$、体积力项（body force）如公式$(3.2)$、压力/不可压缩项如公式$(3.3)$：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=0 \tag {3.1}</script><script type="math/tex; mode=display">\frac{\partial \vec u}{\partial t}=\vec g \tag {3.2}</script><script type="math/tex; mode=display">\begin{cases}\frac{\partial \vec u}{\partial t}+\frac{1}{\rho}∇p=0\\∇\cdot\vec u=0\end{cases} \tag {3.3}</script><p>&emsp;&emsp;需要注意的是，在对流项公式$(3.1)$中我们用了一个通用量的符号$q$是因为我们不仅仅要对流体的速度进行对流，还需要对其他物理量进行对流。我们记对流项公式$(3.1)$的对流计算算法为$advect(\vec u, \Delta t, q)$，即对于给定的时间步长$\Delta t$和速度场$\vec u$，对物理量q进行对流。</p><p>&emsp;&emsp;对于体积力项$(3.2)$，我们采用简单的前向欧拉法即可：$\vec u \leftarrow \vec u + g\Delta t$。</p><p>&emsp;&emsp;对于压力/不可压缩项$(3.3)$，我们用一个称为$project(\Delta t, \vec u)$的算法，通过$project(\Delta t, \vec u)$计算出正确的压力以确保速度场$\vec u$的无散度性质。欧拉方案不会着重研究具体粒子间的作用力，因而不会正向去求解$\frac{1}{\rho}∇p$，它是利用流体不可压缩的特性，将速度场$\vec u$投影到散度为$0$的空间上，间接地解算了压力项。这种思想相当于，已知一个中间量$\vec u_{temp}$，对这个中间量的唯一一个操作（如正向求解压力$\frac{1}{\rho}∇p$）不可行，但是直到最终量$\vec u_{fianl}$符号的一个性质（散度为$0$），于是只要将$\vec u_{temp}$投影到符合散度为$0$的特性平面上，即可间接地还原正向求解压力的操作，得到最终的速度场$\vec u_{temp}$。</p><p>&emsp;&emsp;对流项$advect(\vec u, \Delta t, q)$的输入速度场$\vec u$要确保为无散度的状态，投影项$project(\Delta t, \vec u)$确保了流体体积保持不变，因而投影项输出的速度场必然是无散度的。所以我们只要确保投影项$project(\Delta t, \vec u)$输出的速度场$\vec u$作为对流项$advect(\vec u, \Delta t, q)$的输入即可，这时我们的分步求解流体方程的优势就体现出来了，其伪代码如下所示。</p><hr><p><strong>算法1 Fluid Simulation($\vec u_n$, $\Delta t$):</strong></p><hr><p><strong>1:  初始化速度场$\vec u_n$,使得$\vec u_n$无散度 </strong></p><p><strong>2:  对于每个时间步$n = 0,1,2,…$</strong></p><p><strong>3: &emsp;&emsp;决定一个合理的时间步长$\Delta t = t_{n+1}-t_n$ </strong></p><p><strong>4: &emsp;&emsp;对流项计算$\vec u_A=advect(\vec u_n,\Delta t,\vec q)$ </strong></p><p><strong>5: &emsp;&emsp;体积力项计算$\vec u_B=\vec u_A+\Delta t\vec g$</strong></p><p><strong>6:  &emsp;&emsp;无散度投影$\vec u_{n+1}=project(\Delta t,\vec u_B)$ </strong></p><hr><h3 id="1、时间步长"><a href="#1、时间步长" class="headerlink" title="1、时间步长"></a>1、时间步长</h3><p>&emsp;&emsp;在流体模拟算法中，确定适当的时间步长是算法的第一步。因为计算流体模拟的最后结果是呈现在屏幕上的，所以$\Delta t$的选取与屏幕的刷新率有重要的关系。若选取的$\Delta t$有$t_n+\Delta t &gt; t_{frame}$，那么必须做一个截断使$\Delta t=t_{frame}-t_n$。此外，流体模拟的三个步骤即对流项、体积力项、无散度投影项对时间步长$\Delta t$的要求不尽相同，要选择一个满足所有要求的最小时间步长能确保计算的收敛性。此外，一方面为了流体模拟的真实性，我们可能需要选取一个足够小的时间步长来复现流体的高质量细节。另一方面，有时高性能的需求又使得我们不能选取太小的时间步长去渲染一帧。假设一帧至少要进行三个时间步的模拟，那么$\Delta t$应该至少设成帧间隔时间的三分之一。</p><h3 id="2、网格结构"><a href="#2、网格结构" class="headerlink" title="2、网格结构"></a>2、网格结构</h3><p>&emsp;&emsp;欧拉法的整个流程都是基于网格的，所以合理的网格结构是算法高效的关键点。$Harlow$和$Welch$提出了一种经典的$MAC$（marker and cell）网格结构，许多不可压缩流体模拟的算法都在这个网格结构上呈现出了良好的效率。$MAC$网格是一种交叉排列的网格，不同类型的物理量被存储于网格的不同位置。以二维的网格为例，如图3-1左图所示，流体粒子的压力数据存储于网格的中心点$P_{i,j}$，而速度则沿着笛卡尔坐标被分成了两部分。水平方向的$u$成分被存储在了网格单元竖直边的中心处，例如网格单元$(i,j)$和$(i+1,j)$之间的水平速度记为$u_{i+1/2,j}$。垂直方向的$v$成分则被存储在了网格单元水平面的中心上。这样的存储方案十分有利于估算流体流进/流出某个网格单元的量。</p><p><figure class="half">    <img src="assets/1555851524585.png">    <img src="assets/1555851793961.png"></figure></p><center>图3-1 MAC网格,左图二维,右图三维</center><p>&emsp;&emsp;扩展到三维的情况，$MAC$网格同样是交错排列的结构网格，如图3-1右图所示。压力数值存储在立方体网格单元的中心，三个速度分量分别被记录在立方体网格单元的三个表面的中心点上。在数值计算时，这样的分配方式使得我们可以准确地采用中心差分法计算压力梯度和速度的散度，同时克服了中心差分法的一个普遍的缺点。一维的情况为例，在网格顶点位置$…,q_{i-1},q_i,q_{i+1}…$上估算量场$q$的导数，为了无偏（所谓无偏，就是不偏向左边或者右边）估计网格顶点$i$处的$\frac{\partial q}{\partial x}$，一种比较自然的方式就是采用一阶中心差分法：</p><script type="math/tex; mode=display">(\frac{\partial q}{\partial x})_i\approx \frac{q_{i+1}-q_{i-1}}{2\Delta x} \tag {3.4}</script><p>&emsp;&emsp;公式$(3.4)$是无偏的，且精确度为$O(\Delta x^2)$。而前向欧拉差分法偏向右边且精确度只有$O(\Delta x)$：</p><script type="math/tex; mode=display">(\frac{\partial q}{\partial x})_i\approx \frac{q_{i+1}-q_i}{\Delta x} \tag {3.5}</script><p>&emsp;&emsp;然而，公式$(3.4)$存在着一个非常严重的问题：网格点$i$的估算导数完全忽略了$q_i$的值。数学上，只有常数函数的一阶导数为零。但是公式$(3.4)$遇到了锯齿函数如$q_i=(-1)^i$时，它错误地将该类函数的导数估算为$0$，这种问题被称为零空间问题（null-space problem）。</p><p>&emsp;&emsp;交叉错排的$MAC$网格完美地克服了中心差分法的零空间问题，同时也保持了它的无偏二阶精度。在$MAC$网格上运用中心差分法，网格点$i$处的估算导数公式如下所示：</p><script type="math/tex; mode=display">(\frac{\partial q}{\partial x})_i\approx\frac{q_{i+1/2}-q_{i-1/2}}{\Delta x} \tag {3.6}</script><p>&emsp;&emsp;$MAC$网格确实给流体的压力计算和不可压缩性的处理带来了很大的便利，但与此同时也带来了一些其他方面的麻烦。如果我们要估算某个地方的速度向量，即便采样点恰好在网格点上我们也要做一些插值才能获取相应的速度向量。在网格点处，我们通常采用平均法，以二维为例：</p><script type="math/tex; mode=display">\vec u_{i,j}=(\frac{u_{i-1/2,j}+u_{i+1/2,j}}{2},\frac{v_{i,j-1/2}+v_{i,j+1/2}}{2}),\\\vec u_{i+1/2,j}=(u_{i+1/2,j},\frac{v_{i,j-1/2}+v_{i,j+1/2}+v_{i+1,j-1/2}+v_{i+1,j+1/2}}{4}),\\\vec u_{i,j+1/2}=(\frac{u_{i-1/2,j}+u_{i+1/2,j}+u_{i-1/2,j+1}+u_{i+1/2,j+1}}{4},v_{i,j+1/2}).\tag {3.7}</script><p>&emsp;&emsp;最后，在实现中下标索引一般没有浮点数之说，前面直接采用$i+1/2$的记法是为了便于叙述。一般约定如下：</p><script type="math/tex; mode=display">p(i,j,k)=p_{i,j,k},\\u(i,j,k)=u_{i-1/2,j,k},\\v(i,j,k)=v_{i,j-1/2,k},\\w(i,j,k)=w_{i,j,k-1/2}. \tag{3.8}</script><p>&emsp;&emsp;因而对于$nx\times ny\times nz$分辨率的网格，压力数值存储在$nx\times ny\times nz$的数组中，速度的$u$成分存储在$(nx+1)\times ny\times nz$数组中，速度的$v$成分存储在$nx\times (ny+1)\times nz$数组中，速度的$w$成分存储在$nx\times ny\times (nz+1)$数组中。</p><h2 id="四、对流算法"><a href="#四、对流算法" class="headerlink" title="四、对流算法"></a>四、对流算法</h2><p>&emsp;&emsp;求解如下所示的对流方程是流体模拟的关键一步：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=0 \tag {4.1}</script><p>&emsp;&emsp;我们把这个对流数值计算的算法记为：</p><script type="math/tex; mode=display">q^{n+1}=advect(\vec u,\Delta t,q^n) \tag {4.2}</script><p>&emsp;&emsp;公式$(4.2)$中的各个符号含义：</p><p>&emsp;&emsp;$\vec u$：在$MAC$网格上的离散化的速度场；</p><p>&emsp;&emsp;$\Delta t$：时间步长；</p><p>&emsp;&emsp;$q^n$：当前的物理量场$q$（如流体密度、速度、燃烧物浓度等）；</p><p>&emsp;&emsp;$q^{n+1}$：经过对流后得到的新的量场。</p><p>&emsp;&emsp;在这里要特别注意，输入对流算法的速度场$\vec u$必须是无散度的，否则模拟结果会出现一些奇怪的失真现象。</p><h3 id="1、半拉格朗日对流算法（Semi-Lagrangian-Advection）"><a href="#1、半拉格朗日对流算法（Semi-Lagrangian-Advection）" class="headerlink" title="1、半拉格朗日对流算法（Semi-Lagrangian Advection）"></a>1、半拉格朗日对流算法（Semi-Lagrangian Advection）</h3><p>&emsp;&emsp;一维情况下，对流方程$(4.1)$写成偏微分的形式如下：</p><script type="math/tex; mode=display">\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=0 \tag {4.3}</script><p>&emsp;&emsp;分别采用前向欧拉差分法计算对时间的偏导和中心差分法计算对空间的偏导，我们有：</p><script type="math/tex; mode=display">\frac{q^{n+1}_{i}-q^n_i}{\Delta t}+u^n_i\frac{q^n_{i+1}-q^n_{i-1}}{2\Delta x}=0 \tag {4.4}</script><p>&emsp;&emsp;转成以$q^{n+1}_i$为计算目标的显式公式，得：</p><script type="math/tex; mode=display">q^{n+1}_i=q^n_i-\Delta t u^n_i\frac{q^n_{i+1}-q^n_{i-1}}{2\Delta x} \tag {4.5}</script><p>&emsp;&emsp;公式$(4.5)$看起来没什么问题，但是却存在非常严重的漏洞。首先，前向欧拉法被证明是无条件不稳定的空间离散方法：无论取多么小Δ𝑡，随着时间步的推进，累积误差终将发散。即使使用更稳定的时间积分方法来取代前向欧拉方法，解决了时间上的PDE（Partial Differential Equation，偏微分方程）计算，空间上的PDE计算还是会带来重大的麻烦。标准中心差分方法不可避免地会出现的零空间问题，具有高频震荡性质的速度场对空间的导数被错误地计算为$0$或几乎为$0$，低离速度分量被分离出来，从而导致模拟效果中出现许多奇怪的高频摆动和震荡。</p><p>&emsp;&emsp;针对这些问题，研究者们提出了一个解然不同的、更加简单和更具物理直观意义的半拉格朗日法。之所以叫半拉格朗日法，是因为这种方法是以拉格朗日视角去解决欧拉视角的对流方程（“半”字的由来）。假设我们的目标是求解网格点$\vec x_G$的在第$n+1$个时间步时关于物理量$q$的新值，记为$q^{n+1}_G$。在拉格朗日的视角下，我们可以寻找在第$n+1$时间步之前，是空间中的哪一个点上的流体粒子在速度场$\vec u$的作用下“流向”了$\vec x_G$，我们记这个粒子在第$n$个时间步时的网格位置为$\vec x_P$，则第$n+1$个时间步时$\vec x_G$的$q^{n+1}_G$即为第$n$个时间步时$\vec x_P$的$q^{n}_P$。如下图4-1为半拉格朗日对流法的示意图。</p><p><img src="assets/1555901521756.png" alt="1555901521756"></p><center>图4-1 半拉格朗日对流法</center><p>&emsp;&emsp;半拉格朗日对流法的第一步就是要找出$\vec x_P$，为此我们根据$\vec x_G$做反向的追踪。粒子位置对时间的导数就是速度场：</p><script type="math/tex; mode=display">\frac{d\vec x}{dt}=\vec u(\vec x) \tag {4.6}</script><p>&emsp;&emsp;经过一个时间步长$\Delta t$之后，粒子由$\vec x_P$移动到$\vec x_G$。为了得到$\vec x_P$，最简单的方法就是采用前向欧拉法进行倒推：</p><script type="math/tex; mode=display">\vec x_P=\vec x_G-\Delta t\vec u(\vec x_G) \tag {4.7}</script><p>&emsp;&emsp;然而前向欧拉法只有一阶的精度，若在不改变$\Delta t$的情况下提高精度，我们可以采用高阶的龙格库塔法（Runge-Kutta method）。采用二阶的龙格库塔法如下所示：</p><script type="math/tex; mode=display">\vec x_{mid}=\vec x_G-\frac12\Delta t\vec u(\vec x_G),\\\vec x_P=\vec x_G-\Delta t\vec u(\vec x_{mid}). \tag {4.7}</script><p>&emsp;&emsp;倒推得到$\Delta  t$之前的网格位置$\vec x_P$一般不会恰好在网格顶点上，为此我们需要做些插值。三维模拟通常采用三线性插值，而二维的则采用双线性插值。</p><script type="math/tex; mode=display">q^{n+1}_G=interpolate(q_n,\vec x_P) \tag {4.8}</script><h3 id="2、边界情况"><a href="#2、边界情况" class="headerlink" title="2、边界情况"></a>2、边界情况</h3><p>&emsp;&emsp;若我们倒推得到的$\vec x_P$仍然在流体的内部，那么做插值是完全没问题的。但若$\vec x_P$在流体的边界之外呢？这种情况的出现的原因通常有两个：一个是$\vec x_P$确确实实在流体的外部且即将流入流体内部，另一个是由前向欧拉法或龙格库塔法的数值计算方法带来的误差导致。</p><p>&emsp;&emsp;在一种情况下，我们应该知道当流体流入时其携带的物理量，此时我们将这个外部流入的物理量作为返回值即可。例如，第$n$个时间步时的外部流体以速度$\vec U$和温度$T$在第$n+1$个时间步时注入流体内部$\vec x_G$的位置，那么$\vec T^{n+1}_G$的值就为$T$。</p><p>&emsp;&emsp;在第二种由误差导致的情况下，一个适当的策略就是根据边界上的最近点外推出所求得物理量。在模拟某些流体时，外推变得很简单。例如，在模拟烟雾时我们简单地假设烟雾流体外部即空气的速度风场为某个常数$\vec U$（可能为$0$），这样边界上的速度场都取$\vec U$。但还有一些必须根据流体内部的已知量外推出未知量，这时情况就变得比较复杂了。具体如何外推将在后面介绍，目前我们只需要知道大概的步骤：首先寻找边界上的最近点，然后在最近点的领域内插值获取相应的物理量场。</p><h3 id="3、时间步长大小"><a href="#3、时间步长大小" class="headerlink" title="3、时间步长大小"></a>3、时间步长大小</h3><p>&emsp;&emsp;对任何一种数值计算方法的主要的考虑点就是它是否稳定。幸运的是，<strong>半拉格朗日对流法已经被证明是一种无条件稳定的算法</strong>：无论$\Delta t$取多大，它永远不会出现数值爆炸的现象。因为每一个新值$q$的确定，都是通过对旧值得插值，无论是线性插值、双线性插值还是三线性插值，$q$的大小都是处于插值点之间，不会得到比原来插值点更大或者更小的值，因而$q$是有上下界的。这使得我们可以尽情地根据所需的模拟质量和模拟效率去调整时间步长。</p><p>&emsp;&emsp;但是在实践中，时间步长的大小也不能选得太过极端，否则会产生一些奇观的现象。Foster和Fekiw提出了一个对$\Delta t$的限制：流体粒子在$\Delta t$内的倒推轨迹最多经过某个常数个网格单元为宜，例如5个：</p><script type="math/tex; mode=display">\Delta t \leq \frac{5\Delta x}{u_{max}} \tag {4.9}</script><p>&emsp;&emsp;公式$(4.9)$中，$u_{max}$是速度场的最大值，我们可以简单地取 存储在网格中的最大速度值。一个更鲁棒的方法考虑了体积力（如重力、浮力等）对最大速度的影响：</p><script type="math/tex; mode=display">u_{max}=max(|u^n|)+\Delta t|g| \tag {4.10}</script><p>&emsp;&emsp;将不等式$(4.9)$的最大值带入公式$(4.10)$，我们有：</p><script type="math/tex; mode=display">u_{max}=max(|u^n|)+\frac{5\Delta x}{u_{max}}|g| \tag {4.11}</script><p>&emsp;&emsp;取一个简单的速度上界（简化了公式$(4.11)$），$u_{max}$：</p><script type="math/tex; mode=display">u_{max}=max(|u^n|)+\sqrt{5\Delta xg} \tag {4.12}</script><p>&emsp;&emsp;这样确保了$u_{max}$始终为正，且避免公式$(4.9)$的除$0$错误。</p><p>&emsp;&emsp;关于时间步长的讨论离不开$CFL$（以Courant、Friedrichs、Lewy三人的名字命名）条件。$CFL$条件是一个简单而直观的判断计算是否收敛的必要条件。它的直观物理解释就是时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。满足$CFL$条件意味着当$\Delta x$和$\Delta t$趋于取极限$0$时，数值计算所求的解就会收敛到原微分方程的解。</p><p>&emsp;&emsp;对于半拉格朗日对流法，其满足$CFL$条件当且仅当在极限情况下，追踪得到的粒子轨迹足够逼近真实的轨迹。足够逼近的意思是经过正确的网格插值能够得到正确的依赖域（即差分格式的依赖域包含了原微分方程的依赖域），追踪的轨迹就会收敛到正确真实的轨迹。</p><p>&emsp;&emsp;因而，对于采用标准的显式有限差分法的对流方程求解，为了保证收敛，我们要求$q^{n+1}$的新值是由以当前网格点为中心、以$C\Delta x$（$C$是一个小的整数常量）为半径的邻域范围内插值得到：</p><script type="math/tex; mode=display">\Delta t \leq C\frac{\Delta x}{|\vec u|} \tag {4.13}</script><p>&emsp;&emsp;公式$(4.13)$中的$C$被称为$CFL$数，因而不等式$(4.9)$可以看成是公式$(4.13)$取$CFL$数为$5$得到。</p><h3 id="4、数值耗散"><a href="#4、数值耗散" class="headerlink" title="4、数值耗散"></a>4、数值耗散</h3><p>&emsp;&emsp;对流算法在对流获取新的物理量场$q^{n+1}_i$时会进行一些插值操作，插值不可避免地会平滑物理量场，这带来了一些数值耗散。一次两次的数值耗散不会由太大的影响，但是在流体模拟中我们会在每个时间步都进行对流运算，反反复复的平滑操作将数值耗散不断扩大，损失大量的流体细节。</p><p>&emsp;&emsp;以一维的对流项计算为例，流体速度为常量$u&gt;0$：</p><script type="math/tex; mode=display">\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=0 \tag {4.14}</script><p>&emsp;&emsp;假设$\Delta t &lt; \frac{\Delta x}{u}$，即单个时间步长内粒子追踪轨迹长度小于单个网格单元的大小。我们的目标点是$x_i$，则倒推得到的粒子位置就落在了$[x_{i-1},x_i]$上的$x_i-\Delta tu$，然后进行线性插值得到$q^{n+1}_i$：</p><script type="math/tex; mode=display">q^{n+1}=\frac{\Delta tu}{\Delta x}q^n_{i-1}+(1-\frac{\Delta tu}{\Delta x})q^n_i \tag {4.15}</script><p>&emsp;&emsp;将公式$(4.15)$整理一下，有：</p><script type="math/tex; mode=display">q^{n+1}_i=q^n_i-\Delta tu\frac{q^n_i-q^n_{i-1}}{\Delta x} \tag {4.16}</script><p>&emsp;&emsp;公式$(4.16)$实际上正好就是采用时间上的前向欧拉差分法和空间上的单向有限差分法的欧拉方案，把$q^n_i$看成是$q^n$关于$x_i$的函数，对$q^n_{i-1}$进行泰勒级数展开：</p><script type="math/tex; mode=display">q^n_{i-1}=q^n_i-(\frac{\partial q}{\partial x})^n_i\Delta x+(\frac{\partial^2q}{\partial x^2})^n_i\frac{\Delta x^2}{2}+O(\Delta x^3) \tag {4.17}</script><p>&emsp;&emsp;将公式$(4.17)$代入公式$(4.16)$，并做一些变量消去，可得：</p><script type="math/tex; mode=display">q^{n+1}_i=q^n_i-\Delta tu(\frac{\partial q}{\partial x})^n_i+\Delta tu\Delta x(\frac{\partial^2q}{\partial x^2})^n_i+O(\Delta x^2) \tag {4.18}</script><p>&emsp;&emsp;在二阶截断误差的情况下，结合公式$(4.18)$和公式$(4.14)$，有：</p><script type="math/tex; mode=display">\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=u\Delta x(\frac{\partial^2q}{\partial x^2}) \tag {4.19}</script><p>&emsp;&emsp;右边就是对流方程计算时引入的额外类似粘度乘上系数$u\Delta x$的项。<strong>这也就是说，当我们采用简单的半拉格朗日法去求解无粘度的对流方程时，模拟的结果却看起来我们像时在模拟有粘度的流体。这就是数值耗散！</strong>当然，当$\Delta x\to 0$时，这个数值耗散系数也会趋于$0$，所以取时间步无穷小时能够得到正确的模拟结果，但这需要耗费巨额的计算资源开销。我们通常模拟的流体大多数都是无粘度的，所以如何减少这个数值耗散是个至关重要的难题。</p><p>&emsp;&emsp;一个简单有效的修复数值耗散的方法就是采用更加锐利的插值方法，从而尽可能地减少由插值带来的数值耗散。在一维的情况时，我们采用三次插值（cubic interpolant）如下公式$(4.21)$，而不是简单的一次线性插值$(4.20)$：</p><script type="math/tex; mode=display">q\approx(1-s)x_i+sx_{i+1} \tag {4.20}</script><script type="math/tex; mode=display">q\approx[-\frac13s+\frac12s^2-\frac16s^3]q_{i-1}+[1-s^2+\frac12(s^3-s)]q_i\\+[s+\frac12(s^2-s^3)]q_{i+1}+[\frac16(s^3-s)]q_{i+2} \tag {4.21}</script><p>&emsp;&emsp;扩展到二维或者三维就是双三次插值（bicubic interpolation）或三三次插值（tricubic interpolation）。以二维情况为例，我们可以先沿着$x$轴做第一遍的三次插值如公式$(4.22)$，然后再沿着$y$轴做第二遍插值如公式$(4.23)$：</p><script type="math/tex; mode=display">q_{j-1}=w_{-1}(s)q_{i-1,j-1}+w_0(s)+q_{i,j-1}+w_1(s)q_{i+1,j-1}+w_2(s)q_{i+2,j-1},\\q_{j}=w_{-1}(s)q_{i-1,j}+w_0(s)+q_{i,j}+w_1(s)q_{i+1,j}+w_2(s)q_{i+2,j},\\q_{j+1}=w_{-1}(s)q_{i-1,j+1}+w_0(s)+q_{i,j+1}+w_1(s)q_{i+1,j+1}+w_2(s)q_{i+2,j+1},\\q_{j+2}=w_{-1}(s)q_{i-1,j+2}+w_0(s)+q_{i,j+2}+w_1(s)q_{i+1,j+2}+w_2(s)q_{i+2,j+2}. \tag {4.22}</script><script type="math/tex; mode=display">q=w_{-1}(t)q_{j-1}+w_0(t)q_j+w_1(t)q_{j+1}+w_2(t)q_{j+2} \tag {4.23}</script><p>&emsp;&emsp;当然也可以先沿着$y$轴，然后再沿着$x$轴做插值操作。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Fluid Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Naiver-Stokes Equations </tag>
            
            <tag> Fluid Simulation </tag>
            
            <tag> Advection </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
