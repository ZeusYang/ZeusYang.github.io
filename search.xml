<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软渲染器Soft Renderer：光栅化篇</title>
      <link href="/2019/05/01/SoftRenderer-Rasterization/"/>
      <url>/2019/05/01/SoftRenderer-Rasterization/</url>
      
        <content type="html"><![CDATA[<p>本章开始构建基于Qt平台软渲染器的初步框架，当然Qt相关的内容并不是软渲染器的重点，我只是借助Qt平台将渲染出来的像素矩阵用Qt的控件显示出来。光栅化是当今图形学渲染的一种方式，与之对应的是光线追踪渲染方式，本章我根据自己的理解着重讲述线框光栅化的Bresenham画线算法以及三角形填充光栅化的Edge-Walking算法。<strong>注意：初学者慎入</strong>。本篇相关的完整代码请看<a href="https://github.com/ZeusYang/Soft-Renderer/releases/tag/1.0.0" target="_blank" rel="noopener">这里</a>。</p><a id="more"></a><ul><li><p>渲染管线框架</p></li><li><p>光栅化算法</p></li></ul><h1 id="渲染管线框架"><a href="#渲染管线框架" class="headerlink" title="渲染管线框架"></a>渲染管线框架</h1><p>&emsp;&emsp;渲染管线的搭建主要包含像素显示、网格数据封装、渲染循环、帧率fps计算、帧缓冲、着色器、渲染逻辑、光栅化等等，其中光栅化作为重点对象抽出来放在后面。当然我们不会一下子就完成渲染管线的基本功能，我们现在是要搭建一个框架，大部分的内容不用写入或者仅仅是做简单的处理，这样后面完善软渲染器的时候只需在相应的位置填写相应的代码逻辑即可。本章目标就是搭建一个渲染管线，用光栅化算法画三角形。当然，如果仅仅是画一个三角形，当然不用这么麻烦，但是我的目标是实现三维的软渲染器，深入理解三维渲染的整个流程，得从基础一步一步慢慢来。</p><h2 id="像素显示的画布"><a href="#像素显示的画布" class="headerlink" title="像素显示的画布"></a>像素显示的画布</h2><p>&emsp;&emsp;渲染器最终渲染出来的是一个像素矩阵，我们要把这个像素矩阵显示出来。显示的方法有很多，因人而异，这里我采用自己最熟悉的$Qt$来实现。显示的窗口继承一个普通的$QWidget$父类，然后我们通过重写它的$paintEvent$函数，将渲染出来的像素画到$QWidget$上。但是采用$QPainter$直接画上去的方式效率非常低，我通过查询资料得知，若想要快速地绘制给定的像素矩阵，可以利用$QImage$来实现。话不多说，上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Window</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~Window();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Window *ui;</span><br><span class="line">    QImage *canvas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接收到一帧的像素之后，在重绘事件里面利用$QImage$绘制给定的像素数组（记得调用$update$触发重绘事件）。<strong>由于篇幅原因，我不会讲太多细节方面的东西，代码也不会全部放出来，那样没意义。想看完整源代码的朋友直接去本人的github上看。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::receiveFrame(<span class="keyword">unsigned</span> <span class="keyword">char</span> *image)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(canvas) <span class="keyword">delete</span> canvas;</span><br><span class="line">    canvas = <span class="keyword">new</span> QImage(image, width(), height(), QImage::Format_RGBA8888);</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Window::paintEvent(QPaintEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(canvas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        painter.drawImage(<span class="number">0</span>, <span class="number">0</span>, *canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    QWidget::paintEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="帧缓冲类"><a href="#帧缓冲类" class="headerlink" title="帧缓冲类"></a>帧缓冲类</h2><p>&emsp;&emsp;帧缓冲通常包含基本的颜色缓冲附件、深度缓冲附件等，这里我们暂且只实现颜色缓冲附件（四通道，格式为$RGBA$，各占一个字节），深度缓冲附件后面再加上。渲染管线最终的渲染结果是写入帧缓冲的，我们采用一个一维的单字节数组作为帧缓冲的颜色缓冲。帧缓冲的最基本的功能就是清楚缓冲区、写入像素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_height, m_channel;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; m_colorBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FrameBuffer(<span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line">    ~FrameBuffer() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_width;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_height;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">getColorBuffer</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_colorBuffer.data();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearColorBuffer</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawPixel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">const</span> Vector4D &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FrameBuffer::FrameBuffer(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">    :m_channel(<span class="number">4</span>), m_width(width), m_height(height)</span><br><span class="line">&#123;</span><br><span class="line">    m_colorBuffer.resize(m_width*m_height*m_channel, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameBuffer::clearColorBuffer(<span class="keyword">const</span> Vector4D &amp;color)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// fill the color buffer.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> red = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.x);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> green = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.y);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> blue = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.z);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> alpha = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>;row &lt; m_height;++ row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;col &lt; m_width;++ col)</span><br><span class="line">        &#123;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">0</span>] = red;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">1</span>] = green;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">2</span>] = blue;</span><br><span class="line">            m_colorBuffer[row*m_width*m_channel+col*m_channel + <span class="number">3</span>] = alpha;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameBuffer::drawPixel(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">const</span> Vector4D &amp;color)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m_width || y &lt; <span class="number">0</span> || y &gt;= m_height)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> red = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.x);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> green = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.y);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> blue = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.z);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> alpha = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(<span class="number">255</span>*color.w);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index = y*m_width*m_channel + x*m_channel;</span><br><span class="line">    m_colorBuffer[index + <span class="number">0</span>] = red;</span><br><span class="line">    m_colorBuffer[index + <span class="number">1</span>] = green;</span><br><span class="line">    m_colorBuffer[index + <span class="number">2</span>] = blue;</span><br><span class="line">    m_colorBuffer[index + <span class="number">3</span>] = alpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网格顶点数据"><a href="#网格顶点数据" class="headerlink" title="网格顶点数据"></a>网格顶点数据</h2><p>&emsp;&emsp;三维的渲染程序中的顶点数据通常包含顶点位置、顶点颜色、纹理坐标、顶点法线，然后在此基础上利用一组给定顺序的顶点数据表示一个网格，渲染时网格的数据将被送入管线进行处理。为此，有必要对顶点数据做一定的封装。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector4D position;</span><br><span class="line">    Vector4D color;</span><br><span class="line">    Vector2D texcoord;</span><br><span class="line">    Vector3D normal;</span><br><span class="line"></span><br><span class="line">    Vertex() = <span class="keyword">default</span>;</span><br><span class="line">    Vertex(Vector4D _pos, Vector4D _color, Vector2D _tex, Vector3D _normal)</span><br><span class="line">        :position(_pos),color(_color),texcoord(_tex),normal(_normal) &#123;&#125;</span><br><span class="line">    Vertex(<span class="keyword">const</span> Vertex &amp;rhs)</span><br><span class="line">  :position(rhs.position),color(rhs.color),texcoord(rhs.texcoord),normal(rhs.normal)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;顶点数据经过顶点着色器的处理之后，会被送到下一个渲染管线的阶段处理。顶点着色器的顶点数据输出与输入有些差异，为此我们也定义一个类表示为顶点着色器的输出，这对于构建渲染管线尤为重要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector4D posTrans;  <span class="comment">//世界变换后的坐标</span></span><br><span class="line">    Vector4D posH;      <span class="comment">//投影变换后的坐标</span></span><br><span class="line">    Vector2D texcoord;  <span class="comment">//纹理坐标</span></span><br><span class="line">    Vector3D normal;<span class="comment">//法线</span></span><br><span class="line">    Vector4D color;    <span class="comment">//颜色</span></span><br><span class="line">    <span class="keyword">double</span> oneDivZ;     <span class="comment">//1/z用于深度测试</span></span><br><span class="line"></span><br><span class="line">    VertexOut() = <span class="keyword">default</span>;</span><br><span class="line">    VertexOut(Vector4D _posT, Vector4D _posH, Vector2D _tex, </span><br><span class="line">              Vector3D _normal, Vector4D _color, <span class="keyword">double</span> _oneDivZ)</span><br><span class="line">        :posTrans(_posT),posH(_posH),texcoord(_tex),</span><br><span class="line">          normal(_normal),color(_color),oneDivZ(_oneDivZ) &#123;&#125;</span><br><span class="line">    VertexOut(<span class="keyword">const</span> VertexOut&amp; rhs) :posTrans(rhs.posTrans), </span><br><span class="line">        posH(rhs.posH), texcoord(rhs.texcoord), normal(rhs.normal),</span><br><span class="line">        color(rhs.color), oneDivZ(rhs.oneDivZ) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就是关于网格的表示，为了节省空间（特别是对于很大的模型），我们直接采用索引来组织网格。若想详细了解OpenGL的顶点索引概念请看<a href="https://www.jianshu.com/p/c1a494288d73" target="_blank" rel="noopener">这里</a>。一个网格有两个数组，分别是$Vertex$数组和$Index$数组。下面的代码中，有一个$asTriangle$方法，这是一个三角形网格，调用这个方法之后网格存储的就是一个三角形，用于后面的光栅化调试，光栅化的基本单元就是三角形。<strong>通常情况，所有的网格模型都可以用一定数量的三角形构成，因而我们实现的软渲染器的基本图元就是三角形。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mesh</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; vertices;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices;</span><br><span class="line"></span><br><span class="line">    Mesh() = <span class="keyword">default</span>;</span><br><span class="line">    ~Mesh() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Mesh(<span class="keyword">const</span> Mesh&amp; mesh)</span><br><span class="line">        :vertices(mesh.vertices), indices(mesh.indices)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;mesh == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        vertices = mesh.vertices;</span><br><span class="line">        indices = mesh.indices;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVertices</span><span class="params">(Vertex* _vs, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vertices.resize(count);</span><br><span class="line">        <span class="keyword">new</span>(&amp;vertices[<span class="number">0</span>])<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt;(_vs, _vs + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIndices</span><span class="params">(<span class="keyword">int</span>* _es, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        indices.resize(count);</span><br><span class="line">        <span class="keyword">new</span>(&amp;indices)<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(_es, _es + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asBox</span><span class="params">(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">double</span> depth)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asTriangle</span><span class="params">(<span class="keyword">const</span> Vector3D p1, <span class="keyword">const</span> Vector3D p2, <span class="keyword">const</span> Vector3D p3)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Mesh::asTriangle(Vector3D p1, Vector3D p2, Vector3D p3)</span><br><span class="line">&#123;</span><br><span class="line">    vertices.resize(<span class="number">3</span>);</span><br><span class="line">    indices.resize(<span class="number">3</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].position = p1;</span><br><span class="line">    vertices[<span class="number">0</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].color = Vector4D(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">0</span>].texcoord = Vector2D(<span class="number">0.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].position = p2;</span><br><span class="line">    vertices[<span class="number">1</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">1</span>].texcoord = Vector2D(<span class="number">1.f</span>, <span class="number">0.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].position = p3;</span><br><span class="line">    vertices[<span class="number">2</span>].normal = Vector3D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].color = Vector4D(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">    vertices[<span class="number">2</span>].texcoord = Vector2D(<span class="number">0.5f</span>, <span class="number">1.f</span>);</span><br><span class="line">    indices[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    indices[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    indices[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单的着色器"><a href="#简单的着色器" class="headerlink" title="简单的着色器"></a>简单的着色器</h2><p>&emsp;&emsp;着色器方面时软渲染中较为高级的内容，目前我们只是搭建一个框架，因而着色器不需要什么复杂的操作，只需简单地传递数据就行了。博主实现的软渲染器只包含必不可少的顶点着色器和片元着色器，目前的顶点着色器将顶点原封不动地输出，片元着色器也是如此，这样我们后面要实现光照效果的时候直接在着色器里写上就行了。为了更加有条理，我们设计一个着色器的虚类，这样实现不同效果的着色器时我们直接继承这个虚类即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseShader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseShader() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~BaseShader() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> VertexOut <span class="title">vertexShader</span><span class="params">(<span class="keyword">const</span> Vertex &amp;in)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector4D <span class="title">fragmentShader</span><span class="params">(<span class="keyword">const</span> VertexOut &amp;in)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleShader</span> :</span> <span class="keyword">public</span> BaseShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SimpleShader() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~SimpleShader() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> VertexOut <span class="title">vertexShader</span><span class="params">(<span class="keyword">const</span> Vertex &amp;in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector4D <span class="title">fragmentShader</span><span class="params">(<span class="keyword">const</span> VertexOut &amp;in)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;world)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;view)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="keyword">const</span> Matrix4x4 &amp;project)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VertexOut SimpleShader::vertexShader(<span class="keyword">const</span> Vertex &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut result;</span><br><span class="line">    result.posTrans = in.position;</span><br><span class="line">    result.posH = in.position;</span><br><span class="line">    result.color = in.color;</span><br><span class="line">    result.normal = in.normal;</span><br><span class="line">    result.oneDivZ = <span class="number">1.0</span>;</span><br><span class="line">    result.texcoord = in.texcoord;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4D SimpleShader::fragmentShader(<span class="keyword">const</span> VertexOut &amp;in)</span><br><span class="line">&#123;</span><br><span class="line">    Vector4D litColor;</span><br><span class="line">    litColor = in.color;</span><br><span class="line">    <span class="keyword">return</span> litColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setModelMatrix(<span class="keyword">const</span> Matrix4x4 &amp;world)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setViewMatrix(<span class="keyword">const</span> Matrix4x4 &amp;view)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleShader::setProjectMatrix(<span class="keyword">const</span> Matrix4x4 &amp;project)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到$SimpleShader$仅仅是将顶点数据直接输出，不进行任何处理。</p><h2 id="搭建基本的渲染管线"><a href="#搭建基本的渲染管线" class="headerlink" title="搭建基本的渲染管线"></a>搭建基本的渲染管线</h2><p>&emsp;&emsp;目前我们已经有了一些渲染管线的基本组件，现在就需要把这些组件串起来。首先是渲染循环的问题，$Qt$有它自己的事件循环，而且主线程的事件循环要尽量避免大量的运算（否则UI控件会陷入未响应），因此将渲染循环放到子线程里是一个不错的渲染，这样也可以避免我们的软渲染逻辑与$Qt$的接口耦合得太高。</p><h3 id="渲染线程"><a href="#渲染线程" class="headerlink" title="渲染线程"></a>渲染线程</h3><p>&emsp;&emsp;$Qt$提供了$QThread$类构建线程，我采用的方式为：渲染循环类继承$QObject$，然后调用$moveToThread$番方法挂到子线程上运行，最后将线程的启动信号与$loop$渲染循环关联即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderLoop</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RenderLoop</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~RenderLoop();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopIt</span><span class="params">()</span> </span>&#123;stoped = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFpsZero</span><span class="params">()</span></span>&#123;fps = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFps</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> fps;&#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">frameOut</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *image)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> stoped;</span><br><span class="line">    <span class="keyword">int</span> fps;</span><br><span class="line">    <span class="keyword">int</span> width, height, channel;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RenderLoop::RenderLoop(<span class="keyword">int</span> w, <span class="keyword">int</span> h, QObject *parent)</span><br><span class="line">    : QObject(parent), width(w), height(h), channel(<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fps = <span class="number">0</span>;</span><br><span class="line">    stoped = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RenderLoop::~RenderLoop()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pipeline initialization</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">// fps counting.</span></span><br><span class="line">    fps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stoped)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// render logic</span></span><br><span class="line">        ......</span><br><span class="line">        ++ fps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后在主窗口中创建$RenderLoop$对象，挂到$QThread$上启动。此外还有一点要注意的是在子线程中最好不用使用$QTimer$类，因此我在主窗口中创建$QTimer$类，设定为每秒触发，触发时主线程读取子线程的$fps$，这样就达到了显示帧率的目的了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">在Window类声明处：</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QTimer *timer;</span><br><span class="line">    QThread *loopThread;</span><br><span class="line">    RenderLoop *loop;</span><br><span class="line"></span><br><span class="line">在Window类构造函数处：</span><br><span class="line">    loop = <span class="keyword">new</span> RenderLoop(width(), height(), <span class="literal">nullptr</span>);</span><br><span class="line">    loopThread = <span class="keyword">new</span> QThread(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fps counting.</span></span><br><span class="line">    timer = <span class="keyword">new</span> QTimer();</span><br><span class="line">    connect(timer,&amp;QTimer::timeout,<span class="keyword">this</span>,&amp;Window::fpsTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render thread.</span></span><br><span class="line">    loop-&gt;moveToThread(loopThread);</span><br><span class="line">    connect(loopThread,&amp;QThread::finished,loop, &amp;RenderLoop::deleteLater);</span><br><span class="line">    connect(loopThread,&amp;QThread::started,loop,&amp;RenderLoop::loop);</span><br><span class="line">    connect(loop,&amp;RenderLoop::frameOut,<span class="keyword">this</span>,&amp;Window::receiveFrame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin the thread.</span></span><br><span class="line">    loopThread-&gt;start();</span><br><span class="line">    timer-&gt;start(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">Window的其他函数：</span><br><span class="line"><span class="keyword">void</span> Window::fpsTimeOut()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fps = loop-&gt;getFps();</span><br><span class="line">    loop-&gt;setFpsZero();</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle(QString(<span class="string">" fps: %1"</span>).arg(fps));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><p>&emsp;&emsp;回顾一下$OpenGL$的渲染流程（这里只考虑一般的情况，即不包含几何着色器、细分着色器等），首先外部处理网格，将网格顶点数据和网格顶点索引送入渲染管线，设置基本图元（如三角形）、渲染方式（如线框模式）。渲染管线的第一阶段为顶点着色器阶段（在这之前还有个缓冲清理阶段），顶点着色器对网格数据逐顶点处理（包含坐标空间变换、投影变换等等），随之输出。然后渲染管线对输出的顶点数据进行裁剪，送入光栅化部件，计算几何图元覆盖的像素点，其中进行了大量的线性插值操作。接着片元着色器获取光栅化后的像素，对每个像素做颜色计算等，然后输出颜色数据、深度数据，最后根据这些缓冲数据做深度测试。</p><p>&emsp;&emsp;所以一个最基本的渲染管线应该有如下几个步骤：</p><p>&emsp;&emsp;初始化（如缓冲区创建）$\to$输入顶点缓冲、索引缓冲$\to$清除缓冲区$\to$设置着色器、渲染方式$\to$绘制$\to$交换双缓冲$\to$输出。根据这些步骤，创建$Pipeline$类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_height;              <span class="comment">// width and height of viewport.</span></span><br><span class="line">    BaseShader *m_shader;               <span class="comment">// shaders including vertex shader and fragment shader.</span></span><br><span class="line">    FrameBuffer *m_frontBuffer;</span><br><span class="line">    FrameBuffer *m_backBuffer;</span><br><span class="line">    Matrix4x4 viewPortMatrix;           <span class="comment">// viewport transformation matrix.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; m_vertices;     <span class="comment">// vertex buffer.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; m_indices;<span class="comment">// index buffer.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pipeline(<span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line">    ~Pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;color, <span class="keyword">bool</span> depth = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVertexBuffer</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; &amp;vertices)</span></span>&#123;m_vertices = vertices;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIndexBuffer</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;indices)</span></span>&#123;m_indices = indices;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setShaderMode</span><span class="params">(ShadingMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawIndex</span><span class="params">(RenderMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swapBuffer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">output</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_frontBuffer-&gt;getColorBuffer();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Pipeline::Pipeline(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">    :m_width(width),m_height(height)</span><br><span class="line">    ,m_shader(<span class="literal">nullptr</span>),m_frontBuffer(<span class="literal">nullptr</span>)</span><br><span class="line">    ,m_backBuffer(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pipeline::~Pipeline()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_shader)<span class="keyword">delete</span> m_shader;</span><br><span class="line">    <span class="keyword">if</span>(m_frontBuffer)<span class="keyword">delete</span> m_frontBuffer;</span><br><span class="line">    <span class="keyword">if</span>(m_backBuffer)<span class="keyword">delete</span> m_backBuffer;</span><br><span class="line">    m_shader = <span class="literal">nullptr</span>;</span><br><span class="line">    m_frontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">    m_backBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::initialize()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_frontBuffer)</span><br><span class="line">        <span class="keyword">delete</span> m_frontBuffer;</span><br><span class="line">    <span class="keyword">if</span>(m_backBuffer)</span><br><span class="line">        <span class="keyword">delete</span> m_backBuffer;</span><br><span class="line">    <span class="keyword">if</span>(m_shader)</span><br><span class="line">        <span class="keyword">delete</span> m_shader;</span><br><span class="line">    viewPortMatrix.setViewPort(<span class="number">0</span>,<span class="number">0</span>,m_width,m_height);</span><br><span class="line">    m_frontBuffer = <span class="keyword">new</span> FrameBuffer(m_width, m_height);</span><br><span class="line">    m_backBuffer = <span class="keyword">new</span> FrameBuffer(m_width, m_height);</span><br><span class="line">    m_shader = <span class="keyword">new</span> SimpleShader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::drawIndex(RenderMode mode)</span><br><span class="line">&#123;</span><br><span class="line"> 输入顶点着色器;</span><br><span class="line">    光栅化;</span><br><span class="line">    输入片元着色器;</span><br><span class="line">    写入缓冲区;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::clearBuffer(<span class="keyword">const</span> Vector4D &amp;color, <span class="keyword">bool</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="keyword">void</span>)depth;</span><br><span class="line">    m_backBuffer-&gt;clearColorBuffer(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::setShaderMode(ShadingMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_shader)<span class="keyword">delete</span> m_shader;</span><br><span class="line">    <span class="keyword">if</span>(mode == ShadingMode::simple)</span><br><span class="line">        m_shader = <span class="keyword">new</span> SimpleShader();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mode == ShadingMode::phong)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::swapBuffer()</span><br><span class="line">&#123;</span><br><span class="line">    FrameBuffer *tmp = m_frontBuffer;</span><br><span class="line">    m_frontBuffer = m_backBuffer;</span><br><span class="line">    m_backBuffer = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意到我创建了帧缓冲，分别是$m_frontBuffer$和$m_backBuffer$，前者存储着当前显示的像素，后者缓冲区用于写入像素。这就是著名的双缓冲原理，可以避免画面的闪烁、撕裂等现象。除此之外，还有一个值得特别说明的就是视口变换矩阵$viewPortMatrix$，这个一般很少见到，因为被内嵌在了渲染管线里面了。经过投影变换、透视除法操作之后，顶点数据都在标准化设备空间中，即$x$轴、$y$轴、$z$轴取值范围为$[-1,1]$。但是屏幕的像素坐标范围并非如此，通常屏幕的$x$轴坐标范围为$[0,width]$，$y$轴坐标范围为$[0,height]$，屏幕像素坐标原点在左上角，$x$轴正向朝右，$y$轴正向朝下，所以我们还要把标准化设备坐标顶点数据变换到屏幕的坐标范围中，这就是<strong>视口变换</strong>（$z$轴一般保持不变）。视口变换矩阵的构造并没有难度，因为这仅仅是简单的线性映射，因此不再赘述。视口变换矩阵如下所示：</p><script type="math/tex; mode=display">viewPortMatrix=\left[\begin{matrix}\frac{w}{2}&0&0&s_x+\frac{w}{2}\\0&-\frac{h}{2}&0&s_y+\frac{h}{2}\\0&0&1&0\\0&0&0&1\end{matrix}\right] \tag {1}</script><p>&emsp;&emsp;其中$(s_x,s_y)$是视口左上角的坐标，$(w,h)$为屏幕的宽度和高度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setViewPort(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(width)/<span class="number">2.0f</span>;</span><br><span class="line">    entries[<span class="number">5</span>]  = -<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(height)/<span class="number">2.0f</span>;</span><br><span class="line">    entries[<span class="number">12</span>] =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(left)+<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(width)/<span class="number">2.0f</span>;</span><br><span class="line">    entries[<span class="number">13</span>] =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(top)+<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(height)/<span class="number">2.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;$Pipeline$还有个非常重要的函数$drawIndex$，它是渲染管线的核心部分，涉及到了图元装配、顶点着色器调度、光栅化、片元着色器调度、写入帧缓冲这几个重要的步骤。我们实现的软渲染器几何图元默认为三角形，所以图元装配就是每三个顶点装成一个图元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::drawIndex(RenderMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_indices.empty())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m_indices.size()/<span class="number">3</span>;++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! vertices assembly to triangle primitive</span></span><br><span class="line">        Vertex p1,p2,p3;</span><br><span class="line">        &#123;</span><br><span class="line">            p1 = m_vertices[<span class="number">3</span>*i+<span class="number">0</span>];</span><br><span class="line">            p2 = m_vertices[<span class="number">3</span>*i+<span class="number">1</span>];</span><br><span class="line">            p3 = m_vertices[<span class="number">3</span>*i+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! vertex shader stage.</span></span><br><span class="line">        VertexOut v1,v2,v3;</span><br><span class="line">        &#123;</span><br><span class="line">            v1 = m_shader-&gt;vertexShader(p1);</span><br><span class="line">            v2 = m_shader-&gt;vertexShader(p2);</span><br><span class="line">            v3 = m_shader-&gt;vertexShader(p3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! rasterization and fragment shader stage.</span></span><br><span class="line">        &#123;</span><br><span class="line">            v1.posH = viewPortMatrix * v1.posH;</span><br><span class="line">            v2.posH = viewPortMatrix * v2.posH;</span><br><span class="line">            v3.posH = viewPortMatrix * v3.posH;</span><br><span class="line">            <span class="keyword">if</span>(mode == RenderMode::wire)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// bresenham rasterization</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mode == RenderMode::fill)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// edge walking rasterization</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有了以上的$Pipeline$函数，我们的渲染循环逻辑的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!stoped)</span><br><span class="line">&#123;</span><br><span class="line">    pipeline-&gt;clearBuffer(Vector4D(<span class="number">0.502f</span>,<span class="number">0.698f</span>,<span class="number">0.800f</span>,<span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    pipeline-&gt;drawIndex(RenderMode::fill);</span><br><span class="line"></span><br><span class="line">    pipeline-&gt;swapBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="function">emit <span class="title">frameOut</span><span class="params">(pipeline-&gt;output())</span></span>;</span><br><span class="line">    ++ fps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="光栅化算法"><a href="#光栅化算法" class="headerlink" title="光栅化算法"></a>光栅化算法</h1><p>&emsp;&emsp;顶点着色器处理的还是一个个离散的几何顶点，在顶点着色器之后我们还需要进行光栅化操作，将几何覆盖的屏幕像素计算出来，送入片元着色器计算每个点的像素数据。光栅化一般有两种模式：一种是线框模式，即只描绘几何的边；二是填充模式，即将几何的面片全部填充完。Bresenham算法是经典的描线算法，它采用迭代的形式将所需的算术操作降低到最少。除此之外还有DDA描线算法，效率上不如Bresenham算法，所以我没有实现。</p><h2 id="Bresenham描线算法"><a href="#Bresenham描线算法" class="headerlink" title="Bresenham描线算法"></a>Bresenham描线算法</h2><p>&emsp;&emsp;我们要描绘的是从$(x_0,y_0)$到$(x_1,y_1)$的一条直线线段。一些数学符号标记如下：</p><script type="math/tex; mode=display">\Delta x= x_1-x_0>0,\ \Delta y=y_1-y_0>0,\ m=\frac{\Delta y}{\Delta x}</script><p>&emsp;&emsp;其中$m$即直线线段的斜率，为了便于讨论，我们假设$|m|\leq 1$，其他情况很容易推广。</p><p>&emsp;&emsp;在如上的情况下，Bresenham算法从$x=x_0$开始，每次将$x$坐标值加一，然后推算相应的$y$坐标值。记第$i$次迭代获得的点为$(x_i,y_i)$。那么第$i+1$次迭代时获取的点就在$(\overline x_i+1,\overline y_i)$和$(\overline x_i+1,\overline y_i+1)$这两个中选取。那如何判断应该选哪个呢？即选择这两个点之一的判断标准是什么？<strong>直观上，我们应该选取距离的直线线段在该$y$轴上的交点最近的点</strong>，如下图1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/4.png" alt="1556629627471"></p><center>图1 判别标准</center><p>&emsp;&emsp;直线的一般表达式为$y=mx+B$，$m$为直线的斜率，那么$(x_{i+1},y_{i+1})$表示为如下（注意$y_{i+1}$表示的是直线在$x_{i+1}$上真正的$y$值）：</p><script type="math/tex; mode=display">x_{i+1}=x_i+1\\y_{i+1}=mx_{i+1}+B=m(x_i+1)+B \tag {2}</script><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/5.png" alt="1556630006821"></p><center>图2 交点到右边的点、右上的点的距离 </center><p>&emsp;&emsp;故$d_{upper}$和$d_{lower}$的取值如下：</p><script type="math/tex; mode=display">d_{upper}=\overline y_i+1-\overline y_{i+1}=\overline y_i+1-m\overline x_{i+1}-B\\d_{lower}=y_{i+1}-\overline y_i=mx_{i+1}+B-\overline y_i \tag {3}</script><p>&emsp;&emsp;显然，如果$d_{lower}-d_{upper}&gt;0$，则应该取右上方的点；如果$d_{lower}-d_{upper}<0$，则应该取右边的点。而$d_{lower}-d_{upper}=0$可任取这两个点。因此，我们的判断标准就是$d_{lower}-d_{upper}>0$的符号。</0$，则应该取右边的点。而$d_{lower}-d_{upper}=0$可任取这两个点。因此，我们的判断标准就是$d_{lower}-d_{upper}></p><script type="math/tex; mode=display">d_{lower}-d_{upper}=m(x_i+1)+B-\overline y_i-(\overline y_i+1-m(x_i+1)-B)\\=2m(x_i+1)-2\overline y_i+2B-1 \tag {4}</script><p>&emsp;&emsp;式$(4)$中的$m$是直线的斜率，因此将式$(4)$作为判断标准需要做非常昂贵的浮点数除法运算。为了消去除法，注意到$m=\frac{\Delta y}{\Delta x}$，两边同时乘上$\Delta x&gt;0$，正负符号不变。</p><script type="math/tex; mode=display">p_i=\Delta x\cdot (d_{lower}-d_{upper})=2\Delta y\cdot(x_i+1)-2\Delta x\cdot \overline y_i+(2B-1)\Delta x\\=2\Delta y\cdot x_i-2\Delta x\cdot\overline y_i+c\\where \ \ c=(2B-1)\Delta x+2\Delta y \tag {5}</script><p>&emsp;&emsp;所以可以用$p_i$的符号作为选取的标准。但是，式$(5)$的计算能够进一步简化，考虑$p_i$和$p_{i+1}$（注意我们根据$p_i$的符号来选取$\overline y_{i+1}$）：</p><script type="math/tex; mode=display">p_{i+1}-p_{i}=(2\Delta y\cdot x_{i+1}-2\Delta x\cdot\overline y_{i+1}+c)-(2\Delta y\cdot x_i-2\Delta x\cdot\overline y_i+c)\\=2\Delta y-2\Delta x(\overline y_{i+1}-\overline y_i) \tag {6}</script><p>&emsp;&emsp;若$p_i\leq 0$，那么选择右边的点，此时$\overline y_{i+1}=\overline y_i$，那么有：</p><script type="math/tex; mode=display">p_{i+1}=p_i+2\Delta y \tag {7}</script><p>&emsp;&emsp;若$p_i&gt;0$，那么选择右上角的点，此时$\overline y_{i+1}=\overline y_i+1$，那么有：</p><script type="math/tex; mode=display">p_{i+1}=p_i+2\Delta y-2\Delta x \tag {8}</script><p>&emsp;&emsp;所以我们可以根据$p_i$的符号快速计算出$p_{i+1}$的符号，如此迭代下去：</p><hr><p><strong>Bresenham Algorithm:</strong></p><hr><p>$draw (x_0, y_0);$</p><p>Calculate $\Delta x$,$\Delta y$,$2\Delta y$,$2\Delta y-2\Delta x$,$p_0=2\Delta y-\Delta x$;</p><p>for $x$ from $x_0$ to $x_1$:</p><p>&emsp;&emsp;if $p_i\leq 0$ </p><p>&emsp;&emsp;&emsp;&emsp;draw $(x_{i+1},\overline y_{i+1})=(x_i+1,\overline y_i)$ ;</p><p>&emsp;&emsp;&emsp;&emsp;compute $p_{i+1}=p_i+2\Delta y$;</p><p>&emsp;&emsp;if $p_i &gt; 0$ </p><p>&emsp;&emsp;&emsp;&emsp;draw $(x_{i+1},\overline y_{i+1})=(x_i+1,\overline y_i+1)$ ;</p><p>&emsp;&emsp;&emsp;&emsp;compute $p_{i+1}=p_i+2\Delta y-2\Delta x$;</p><p>&emsp;&emsp;$x += 1;$</p><hr><p>&emsp;&emsp;上面我们讨论的都是$|m|<1$的情况，那$|m|>1$的情况呢？其实这是对称的，这时把$x$看成$y$，把$y$看成$x$即可。另外，当$\Delta x &lt;0$时，我们的$x$不是递增$1$，而是递减$1$，具体实现如下：</1$的情况，那$|m|></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::bresenhamLineRasterization(<span class="keyword">const</span> VertexOut &amp;from, <span class="keyword">const</span> VertexOut &amp;to)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dx = to.posH.x - from.posH.x;</span><br><span class="line">    <span class="keyword">int</span> dy = to.posH.y - from.posH.y;</span><br><span class="line">    <span class="keyword">int</span> stepX = <span class="number">1</span>, stepY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// judge the sign</span></span><br><span class="line">    <span class="keyword">if</span>(dx &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stepX = <span class="number">-1</span>;</span><br><span class="line">        dx = -dx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dy &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stepY = <span class="number">-1</span>;</span><br><span class="line">        dy = -dy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d2x = <span class="number">2</span>*dx, d2y = <span class="number">2</span>*dy;</span><br><span class="line">    <span class="keyword">int</span> d2y_minus_d2x = d2y - d2x;</span><br><span class="line">    <span class="keyword">int</span> sx = from.posH.x;</span><br><span class="line">    <span class="keyword">int</span> sy = from.posH.y;</span><br><span class="line"></span><br><span class="line">    VertexOut tmp;</span><br><span class="line">    <span class="comment">// slope &lt; 1.</span></span><br><span class="line">    <span class="keyword">if</span>(dy &lt;= dx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = d2y - dx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= dx;++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// linear interpolation</span></span><br><span class="line">            tmp = lerp(from, to, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dx);</span><br><span class="line">            <span class="comment">// fragment shader</span></span><br><span class="line">            m_backBuffer-&gt;drawPixel(sx,sy,m_shader-&gt;fragmentShader(tmp));</span><br><span class="line">            sx += stepX;</span><br><span class="line">            <span class="keyword">if</span>(flag &lt;= <span class="number">0</span>)</span><br><span class="line">                flag += d2y;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sy += stepY;</span><br><span class="line">                flag += d2y_minus_d2x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slope &gt; 1.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = d2x - dy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= dy;++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// linear interpolation</span></span><br><span class="line">            tmp = lerp(from, to, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dy);</span><br><span class="line">            <span class="comment">// fragment shader</span></span><br><span class="line">            m_backBuffer-&gt;drawPixel(sx,sy,m_shader-&gt;fragmentShader(tmp));</span><br><span class="line">            sy += stepY;</span><br><span class="line">            <span class="keyword">if</span>(flag &lt;= <span class="number">0</span>)</span><br><span class="line">                flag += d2x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sx += stepX;</span><br><span class="line">                flag -= d2y_minus_d2x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Edge-Walking三角形填充算法"><a href="#Edge-Walking三角形填充算法" class="headerlink" title="Edge-Walking三角形填充算法"></a>Edge-Walking三角形填充算法</h2><p>&emsp;&emsp;三角形光栅化填充对输入给定的三个三角形顶点，计算这个三角区域覆盖的所有像素。三角形填充的光栅化算法有很多种，这里仅实现了Edge-Walking算法，此外还有Edge-Equation算法。关于Edge-Walking算法的前世今生我不再赘述了，这个算法的思路比较简单，但是实现起来比较麻烦一点。</p><p>&emsp;&emsp;话不多少，直接上伪代码（懒得自己写了伪代码了）：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/6.png" alt="1556632613625"></p><p>&emsp;&emsp;大致的思想就是从上往下（或从下往上）扫描，获取每对$X_L$、$X_R$，然后在$[X_L,X_R]$范围内从左到右扫描。显然就是双重循环。一般，我们的三角形光栅化对象有如下四种情况：</p><p><img src="http://hi.csdn.net/attachment/201103/8/8458191_1299584107w6lP.png" alt="4ç§ä¸è§å½¢"></p><center>图3 四类三角形 </center><p>&emsp;&emsp;先来看平底三角形的情况，如下图4所示。显然，平底三角形很容易地实现从下往上扫面，竖直方向上仅需考虑左右两条边。<strong>当然这里有个问题，就是如何确定$X_L$和$X_R$？如果直接采用算法伪代码中的利用$dx/dy$迭代获取$X$值，因为$X$值是整数，而$dx/dy$是浮点数，当$dx/dy&lt;1$时，把$dx/dy$加到$X$上面计算机对整数类型坐标自动向下取整，结果相当于没加。（即便是浮点数类型，最终也要取整，因为屏幕空间的像素坐标必须是整数）</strong></p><p><img src="http://hi.csdn.net/attachment/201103/8/8458191_12995845892C4L.png" alt="åæ åå¹³åºä¸è§å½¢"></p><center>图4 平底三角形</center><p>&emsp;&emsp;一种解决方案就是线性插值，算法从下往上扫描时，$y-=1$，我们根据当前的$y$值来获取$x$值：</p><script type="math/tex; mode=display">X_L = (1.0f-\frac{y1-y}{y1-y0})*x1+\frac{y1-y}{y1-y0}*x0 \\X_y = (1.0f-\frac{y2-y}{y2-y0})*x2+\frac{y2-y}{y2-y0}*x0</script><p>&emsp;&emsp;平顶的三角形光栅化亦类似，不再赘述。那么除了平底和平顶的情况之外，我们该如何处理其余的情况？一个技巧就是将其他情况的三角形分割乘一个平底三角形、一个平顶三角形，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/7.png" alt="1556634037498"></p><center>图5 三角形分割</center><p>&emsp;&emsp;这样我们通过调用平底三角形光栅化方法、平顶三角形光栅化方法即可实现一般情况的三角形光栅化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Pipeline::scanLinePerRow(<span class="keyword">const</span> VertexOut &amp;left, <span class="keyword">const</span> VertexOut &amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut current;</span><br><span class="line">    <span class="keyword">int</span> length = right.posH.x - left.posH.x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// linear interpolation</span></span><br><span class="line">        <span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/length;</span><br><span class="line">        current = lerp(left, right, weight);</span><br><span class="line">        current.posH.x = left.posH.x + i;</span><br><span class="line">        current.posH.y = left.posH.y;</span><br><span class="line">        <span class="comment">// fragment shader</span></span><br><span class="line">        m_backBuffer-&gt;drawPixel(current.posH.x, current.posH.y,</span><br><span class="line">                                m_shader-&gt;fragmentShader(current));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::rasterTopTriangle(VertexOut &amp;v1, VertexOut &amp;v2, VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut left = v2;</span><br><span class="line">    VertexOut right = v3;</span><br><span class="line">    VertexOut dest = v1;</span><br><span class="line">    VertexOut tmp, newleft, newright;</span><br><span class="line">    <span class="keyword">if</span>(left.posH.x &gt; right.posH.x)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = left;</span><br><span class="line">        left = right;</span><br><span class="line">        right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dy = left.posH.y - dest.posH.y + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dy;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dy != <span class="number">0</span>)</span><br><span class="line">            weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dy;</span><br><span class="line">        newleft = lerp(left, dest, weight);</span><br><span class="line">        newright = lerp(right, dest, weight);</span><br><span class="line">        newleft.posH.y = newright.posH.y = left.posH.y - i;</span><br><span class="line">        scanLinePerRow(newleft, newright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::rasterBottomTriangle(VertexOut &amp;v1, VertexOut &amp;v2, VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    VertexOut left = v1;</span><br><span class="line">    VertexOut right = v2;</span><br><span class="line">    VertexOut dest = v3;</span><br><span class="line">    VertexOut tmp, newleft, newright;</span><br><span class="line">    <span class="keyword">if</span>(left.posH.x &gt; right.posH.x)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = left;</span><br><span class="line">        left = right;</span><br><span class="line">        right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dy = dest.posH.y - left.posH.y + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dy;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dy != <span class="number">0</span>)</span><br><span class="line">            weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)/dy;</span><br><span class="line">        newleft = lerp(left, dest, weight);</span><br><span class="line">        newright = lerp(right, dest, weight);</span><br><span class="line">        newleft.posH.y = newright.posH.y = left.posH.y + i;</span><br><span class="line">        scanLinePerRow(newleft, newright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pipeline::edgeWalkingFillRasterization(<span class="keyword">const</span> VertexOut &amp;v1, <span class="keyword">const</span> VertexOut &amp;v2, <span class="keyword">const</span> VertexOut &amp;v3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// split the triangle into two part</span></span><br><span class="line">    VertexOut tmp;</span><br><span class="line">    VertexOut target[<span class="number">3</span>] = &#123;v1, v2,v3&#125;;</span><br><span class="line">    <span class="keyword">if</span>(target[<span class="number">0</span>].posH.y &gt; target[<span class="number">1</span>].posH.y)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = target[<span class="number">0</span>];</span><br><span class="line">        target[<span class="number">0</span>] = target[<span class="number">1</span>];</span><br><span class="line">        target[<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target[<span class="number">0</span>].posH.y &gt; target[<span class="number">2</span>].posH.y)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = target[<span class="number">0</span>];</span><br><span class="line">        target[<span class="number">0</span>] = target[<span class="number">2</span>];</span><br><span class="line">        target[<span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target[<span class="number">1</span>].posH.y &gt; target[<span class="number">2</span>].posH.y)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = target[<span class="number">1</span>];</span><br><span class="line">        target[<span class="number">1</span>] = target[<span class="number">2</span>];</span><br><span class="line">        target[<span class="number">2</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bottom triangle</span></span><br><span class="line">    <span class="keyword">if</span>(equal(target[<span class="number">0</span>].posH.y,target[<span class="number">1</span>].posH.y))</span><br><span class="line">    &#123;</span><br><span class="line">        rasterBottomTriangle(target[<span class="number">0</span>],target[<span class="number">1</span>],target[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// top triangle</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(equal(target[<span class="number">1</span>].posH.y,target[<span class="number">2</span>].posH.y))</span><br><span class="line">    &#123;</span><br><span class="line">        rasterTopTriangle(target[<span class="number">0</span>], target[<span class="number">1</span>], target[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// split it.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(target[<span class="number">1</span>].posH.y-target[<span class="number">0</span>].posH.y)/(target[<span class="number">2</span>].posH.y-target[<span class="number">0</span>].posH.y);</span><br><span class="line">        VertexOut newPoint = lerp(target[<span class="number">0</span>],target[<span class="number">2</span>],weight);</span><br><span class="line">        newPoint.posH.y = target[<span class="number">1</span>].posH.y;</span><br><span class="line">        rasterTopTriangle(target[<span class="number">0</span>], newPoint, target[<span class="number">1</span>]);</span><br><span class="line">        rasterBottomTriangle(newPoint,target[<span class="number">1</span>],target[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="程序结果"><a href="#程序结果" class="headerlink" title="程序结果"></a>程序结果</h1><p>&emsp;&emsp;最终，不借用任何图形接口通过自己实现的光栅化算法画出了三角形：</p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/0.png" alt="0"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/1.png" alt="1"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/2.png" alt="2"></p><p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.6/blog/SoftRenderer-Rasterization/3.png" alt="3"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="https://blog.csdn.net/cppyin/article/details/6232453" target="_blank" rel="noopener">https://blog.csdn.net/cppyin/article/details/6232453</a></p><p>$[2]$ <a href="https://blog.csdn.net/y1196645376/article/details/78937614" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/78937614</a></p><p>$[3]$ <a href="https://blog.csdn.net/y1196645376/article/details/78907914" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/78907914</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Soft Renderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Soft Renderer </tag>
            
            <tag> Rasterization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软渲染器Soft Renderer：3D数学篇</title>
      <link href="/2019/05/01/SoftRenderer-Math/"/>
      <url>/2019/05/01/SoftRenderer-Math/</url>
      
        <content type="html"><![CDATA[<p>本章开始博主将手动搭建一个渲染管线，深入理解3D渲染的整个流程。线性代数中的向量和矩阵是计算机图形学的常客，深入理解和掌握对于图形渲染有着非常重要的意义，本节主要是关于3D数学库的内容。</p><a id="more"></a><ul><li>向量</li><li>矩阵</li></ul><h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><p>&emsp;&emsp;$n$维向量本质就是一个$n$元组，从几何意义上来说，向量是有大小和方向的有向线段。向量的大小就是向量的长度（模）向量有非负的长度，而向量的方向描述了空间中向量的指向。向量的相关内容高中就已涉及，因此不再赘述。若想要重新深入了解相关内容，可以查看这个<a href="http://www.cnblogs.com/msxh/p/6156004.html" target="_blank" rel="noopener">地址</a>。</p><p>&emsp;&emsp;图形渲染中通常使用的向量为$2$到$4$维，如下分别是$2$维、$3$维、$4$维向量类的常用方法，主要是运算操作符重载以及点乘、叉乘、模、标准化、线性插值等基本操作。向量的内容简单，没什么要特别说明的。</p><h2 id="2D向量类"><a href="#2D向量类" class="headerlink" title="2D向量类"></a>2D向量类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vector2D():x(<span class="number">0.0f</span>), y(<span class="number">0.0f</span>) &#123;&#125;</span><br><span class="line">    Vector2D(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY):x(newX), y(newY)&#123;&#125;</span><br><span class="line">    Vector2D(<span class="keyword">const</span> <span class="keyword">float</span> * rhs):x(*rhs), y((*rhs)+<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    Vector2D(<span class="keyword">const</span> Vector2D &amp; rhs):x(rhs.x), y(rhs.y)&#123;&#125;</span><br><span class="line">    ~Vector2D() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY)</span></span>&#123;x=newX;y=newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123;x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123;y = newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normalization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Vector2D <span class="title">getNormalize</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sqrt</span>(x*x + y*y));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getSquaredLength</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(x*x + y*y);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Vector2D <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(x + rhs.x, y + rhs.y);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(x - rhs.x, y - rhs.y);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(x*rhs, y*rhs);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (rhs==<span class="number">0</span>) ? Vector2D(<span class="number">0.0f</span>, <span class="number">0.0f</span>) : Vector2D(x / rhs, y / rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(x,rhs.x) &amp;&amp; equal(y,rhs.y));&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector2D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !((*<span class="keyword">this</span>)==rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector2D &amp;rhs)&#123;x+=rhs.x;y+=rhs.y;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Vector2D &amp;rhs)&#123;x-=rhs.x;y-=rhs.y;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;x*=rhs;y*=rhs;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;<span class="keyword">if</span>(!equal(rhs, <span class="number">0.0</span>))&#123;x/=rhs;y/=rhs;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    Vector2D <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector2D(-x, -y);&#125;</span><br><span class="line">    Vector2D <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// interpolation</span></span><br><span class="line">    <span class="function">Vector2D <span class="title">lerp</span><span class="params">(<span class="keyword">const</span> Vector2D &amp;v2,<span class="keyword">const</span> <span class="keyword">float</span> factor)</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span> - factor) + v2*factor;&#125;</span><br><span class="line">    <span class="function">Vector2D <span class="title">quadraticInterpolate</span><span class="params">(<span class="keyword">const</span> Vector2D &amp; v2, <span class="keyword">const</span> Vector2D &amp; v3, <span class="keyword">const</span> <span class="keyword">float</span> factor)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor)*(<span class="number">1.0f</span>-factor) + v2*<span class="number">2.0f</span>*factor*(<span class="number">1.0f</span>-factor) + v3*factor*factor;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3D向量类"><a href="#3D向量类" class="headerlink" title="3D向量类"></a>3D向量类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector3D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vector3D():x(<span class="number">0.0f</span>), y(<span class="number">0.0f</span>), z(<span class="number">0.0f</span>)&#123;&#125;</span><br><span class="line">    Vector3D(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ):x(newX), y(newY), z(newZ)&#123;&#125;</span><br><span class="line">    Vector3D(<span class="keyword">const</span> <span class="keyword">float</span> * rhs):x(*rhs), y(*(rhs+<span class="number">1</span>)), z(*(rhs+<span class="number">2</span>))&#123;&#125;</span><br><span class="line">    Vector3D(<span class="keyword">const</span> Vector3D &amp;rhs):x(rhs.x), y(rhs.y), z(rhs.z)&#123;&#125;</span><br><span class="line">    ~Vector3D() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ)</span></span>&#123;x=newX;y=newY;z=newZ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123;x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123;y = newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZ</span><span class="params">(<span class="keyword">float</span> newZ)</span> </span>&#123;z = newZ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getZ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> z;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normalization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">getNormalized</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length caculation</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sqrt</span>(x*x+y*y+z*z));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getSquaredLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x*x+y*y+z*z;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// product</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">dotProduct</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x*rhs.x + y*rhs.y + z*rhs.z;&#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">crossProduct</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> Vector3D(y*rhs.z - z*rhs.y, z*rhs.x - x*rhs.z, x*rhs.y - y*rhs.x);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// linear interpolation</span></span><br><span class="line">    <span class="function">Vector3D <span class="title">lerp</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;v2, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor) + v2*factor;&#125;</span><br><span class="line">    <span class="function">Vector3D <span class="title">QuadraticInterpolate</span><span class="params">(<span class="keyword">const</span> Vector3D &amp;v2, <span class="keyword">const</span> Vector3D &amp;v3, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor)*(<span class="number">1.0f</span>-factor) + v2*<span class="number">2.0f</span>*factor*(<span class="number">1.0f</span>-factor) + v3*factor*factor;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Vector3D <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(x + rhs.x, y + rhs.y, z + rhs.z);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(x - rhs.x, y - rhs.y, z - rhs.z);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(x*rhs, y*rhs, z*rhs);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(rhs,<span class="number">0.0f</span>))?Vector3D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>):Vector3D(x/rhs, y/rhs, z/rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(x,rhs.x) &amp;&amp; equal(y,rhs.y) &amp;&amp; equal(z,rhs.z));&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector3D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !((*<span class="keyword">this</span>)==rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector3D &amp;rhs) &#123;x+=rhs.x;y+=rhs.y;z+=rhs.z;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Vector3D &amp; rhs) &#123;x-=rhs.x;y-=rhs.y;z-=rhs.z;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;x*=rhs;y*=rhs;z*=rhs;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;<span class="keyword">if</span>(!equal(rhs,<span class="number">0.0f</span>))&#123;x/=rhs; y/=rhs; z/=rhs;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    Vector3D <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector3D(-x, -y, -z);&#125;</span><br><span class="line">    Vector3D <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4D向量类"><a href="#4D向量类" class="headerlink" title="4D向量类"></a>4D向量类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector4D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y,z,w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vector4D():x(<span class="number">0.0f</span>), y(<span class="number">0.0f</span>), z(<span class="number">0.0f</span>), w(<span class="number">0.0f</span>)&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ, <span class="keyword">float</span> newW):x(newX), y(newY), z(newZ), w(newW)&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">const</span> <span class="keyword">float</span> * rhs):x(*rhs), y(*(rhs+<span class="number">1</span>)), z(*(rhs+<span class="number">2</span>)), w(*(rhs+<span class="number">3</span>))&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">const</span> Vector4D &amp;rhs):x(rhs.x), y(rhs.y), z(rhs.z), w(rhs.w)&#123;&#125;</span><br><span class="line">    Vector4D(<span class="keyword">const</span> Vector3D &amp; rhs):x(rhs.x), y(rhs.y), z(rhs.z), w(<span class="number">1.0f</span>)&#123;&#125;</span><br><span class="line">    ~Vector4D() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">float</span> newX, <span class="keyword">float</span> newY, <span class="keyword">float</span> newZ, <span class="keyword">float</span> newW)</span></span>&#123;x=newX;y=newY;z=newZ;w=newW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123;x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123;y = newY;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZ</span><span class="params">(<span class="keyword">float</span> newZ)</span> </span>&#123;z = newZ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setW</span><span class="params">(<span class="keyword">float</span> newW)</span> </span>&#123;w = newW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getZ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> z;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getW</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> w;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// product</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">dotProduct</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x*rhs.x + y*rhs.y + z*rhs.z + w*rhs.w;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// linear interpolation</span></span><br><span class="line">    <span class="function">Vector4D <span class="title">lerp</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;v2, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor) + v2*factor;&#125;</span><br><span class="line">    <span class="function">Vector4D <span class="title">QuadraticInterpolate</span><span class="params">(<span class="keyword">const</span> Vector4D &amp;v2, <span class="keyword">const</span> Vector4D &amp;v3, <span class="keyword">float</span> factor)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span>)*(<span class="number">1.0f</span>-factor)*(<span class="number">1.0f</span>-factor)+v2*<span class="number">2.0f</span>*factor*(<span class="number">1.0f</span>-factor)+v3*factor*factor;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Vector4D <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(x+rhs.x, y+rhs.y, z+rhs.z, w+rhs.w);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(x-rhs.x, y-rhs.y, z-rhs.z, w-rhs.w);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(x*rhs, y*rhs, z*rhs, w*rhs);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> (equal(rhs,<span class="number">0.0f</span>))?Vector4D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>):Vector4D(x/rhs, y/rhs, z/rhs, w/rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (equal(x,rhs.x)&amp;&amp;equal(y,rhs.y)&amp;&amp;equal(z,rhs.z)&amp;&amp;equal(w,rhs.w));&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector4D &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !((*<span class="keyword">this</span>)==rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector4D &amp;rhs) &#123;x+=rhs.x;y+=rhs.y;z+=rhs.z;w+=rhs.w;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Vector4D &amp; rhs) &#123;x-=rhs.x;y-=rhs.y;z-=rhs.z;w-=rhs.w;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;x*=rhs;y*=rhs;z*=rhs;w*=rhs;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs)&#123;<span class="keyword">if</span>(!equal(rhs,<span class="number">0.0f</span>))&#123;x/=rhs; y/=rhs; z/=rhs; w/=rhs;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    Vector4D <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Vector4D(-x, -y, -z, -w);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>&emsp;&emsp;矩阵本质就是向量的进一步扩展的，一个$n\times m$的矩阵可看成$n$个$m$维行向量组成或者$m$个$n$维列向量组成，关于矩阵的基本概念、操作请看<a href="https://blog.csdn.net/AutisticPatient/article/details/62892100" target="_blank" rel="noopener">这里</a>。通常我们采用方阵来描述线性变换。所谓线性变换，即变换之后保留了直线而不被弯曲，平行线依然平行，原点没有变化，但其他的几何性质如长度、角度、面积和体积可能被变换改变了。直观来说，线性变换可能“拉伸”坐标系，但不会“弯曲”或“卷折”坐标系。</p><p>&emsp;&emsp;矩阵在计算机中有行主序存储、列主序存储两种方式，行主序存储即按照顺序逐行存储，列主序存储则按照顺序逐列存储。图形学渲染中我们通常采用的是列主序的方式，<strong>以下的讨论都是列主序的矩阵存储方式。</strong>那么矩阵是如何变换向量的？</p><p>&emsp;&emsp;<strong>向量在几何上能被解释成一系列与轴平行的位移</strong>，一般来说，任意向量$\vec v$都能写成如下的形式：</p><script type="math/tex; mode=display">\vec v=\left[\begin{matrix}x\\y\\z\end{matrix}\right]=\left[\begin{matrix}x\\0\\0\end{matrix}\right]+\left[\begin{matrix}0\\y\\0\end{matrix}\right]+\left[\begin{matrix}0\\0\\z\end{matrix}\right]=x\left[\begin{matrix}1\\0\\0\end{matrix}\right]+y\left[\begin{matrix}0\\1\\0\end{matrix}\right]+z\left[\begin{matrix}0\\0\\1\end{matrix}\right] \tag {1}</script><p>&emsp;&emsp;公式$(1)$右边的单位向量就是$x$、$y$、$z$轴方向的向量，<strong>向量的每个坐标都表明了平行于相应坐标轴的有向位移</strong>。我们记$\vec p$、$\vec q$、$\vec r$分别为公式$(1)$中右边的$x$、$y$、$z$轴的单位列向量，则有：</p><script type="math/tex; mode=display">\vec v=x\vec p+y\vec q+z\vec r=\left[\begin{matrix}\vec p &\vec q&\vec r\end{matrix}\right]\left[\begin{matrix}x \\y\\z\end{matrix}\right] \tag {2}</script><p>&emsp;&emsp;向量$\vec v$就变成了向量$\vec p$、$\vec q$、$\vec r$的线性表示，向量$\vec p$、$\vec q$、$\vec r$称作基向量。以上仅仅讨论的是笛卡尔坐标系，但更通用的情况是，一个$3$维坐标系能用任意$3$个线性无关的基向量表示，以列向量$\vec p$、$\vec q$、$\vec r$构建$3\times 3$的矩阵$M$：</p><script type="math/tex; mode=display">M=\left[\begin{matrix}\vec p &\vec q&\vec r\end{matrix}\right]=\left[\begin{matrix}p_x &q_x&r_x\\p_y &q_y&r_y\\p_z &q_z&r_z\end{matrix}\right] \tag {3}</script><p>&emsp;&emsp;结合公式$(2)$和公式$(3)$，即有：</p><script type="math/tex; mode=display">\vec v=M\left[\begin{matrix}x \\y\\z\end{matrix}\right] \tag{4}</script><p>&emsp;&emsp;坐标系变换矩阵的每一列（如果是行主序，就是每一行）都是该坐标系的基向量，一个点$v$右乘该矩阵就相当于执行了一次坐标系转换。<strong>求解线性变换矩阵的关键就是根据当前的坐标系求解变换之后的坐标系的基向量，然后将基向量填入向量位置！</strong></p><p>&emsp;&emsp;一个矩阵类通常有如下方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix4x4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> entries[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Matrix4x4()&#123;loadIdentity();&#125;</span><br><span class="line">    Matrix4x4(<span class="keyword">float</span> e0, <span class="keyword">float</span> e1, <span class="keyword">float</span> e2, <span class="keyword">float</span> e3,</span><br><span class="line">              <span class="keyword">float</span> e4, <span class="keyword">float</span> e5, <span class="keyword">float</span> e6, <span class="keyword">float</span> e7,</span><br><span class="line">              <span class="keyword">float</span> e8, <span class="keyword">float</span> e9, <span class="keyword">float</span> e10,<span class="keyword">float</span> e11,</span><br><span class="line">              <span class="keyword">float</span> e12,<span class="keyword">float</span> e13,<span class="keyword">float</span> e14,<span class="keyword">float</span> e15);</span><br><span class="line">    Matrix4x4(<span class="keyword">const</span> <span class="keyword">float</span> *rhs);</span><br><span class="line">    Matrix4x4(<span class="keyword">const</span> Matrix4x4 &amp;rhs);</span><br><span class="line">    ~Matrix4x4() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter,getter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEntry</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getEntry</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector4D <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Vector4D <span class="title">getColumn</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadIdentity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadZero</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded operators</span></span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>-(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">float</span> rhs) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Matrix4x4 &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Matrix4x4 &amp; rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> Matrix4x4 &amp; rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> Matrix4x4 &amp; rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">float</span> rhs);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">float</span> rhs);</span><br><span class="line"></span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">    Matrix4x4 <span class="keyword">operator</span>+() <span class="keyword">const</span> &#123;<span class="keyword">return</span> (*<span class="keyword">this</span>);&#125;</span><br><span class="line">    Vector4D <span class="keyword">operator</span>*(<span class="keyword">const</span> Vector4D rhs) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inverse, transpose</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inverted</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getInverse</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getTranspose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invertTranspose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Matrix4x4 <span class="title">getInverseTranspose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operation on space</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTranslation</span><span class="params">(<span class="keyword">const</span> Vector3D &amp; translation)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setScale</span><span class="params">(<span class="keyword">const</span> Vector3D &amp; scaleFactor)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationAxis</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle, <span class="keyword">const</span> Vector3D &amp; axis)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationX</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationY</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationZ</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationEuler</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> angleX, <span class="keyword">const</span> <span class="keyword">double</span> angleY, <span class="keyword">const</span> <span class="keyword">double</span> angleZ)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPerspective</span><span class="params">(<span class="keyword">float</span> fovy, <span class="keyword">float</span> aspect, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPerspective</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOrtho</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="线性变换、仿射变换"><a href="#线性变换、仿射变换" class="headerlink" title="线性变换、仿射变换"></a>线性变换、仿射变换</h2><p>&emsp;&emsp;满足$F(a+b)=F(a)+F(b)$和$F(ka)=kF(a)$的映射$F(a)$就是线性的。对于映射$F(a)=Ma$，当$M$为任意方阵时，也可以说明$F$映射是一个线性变换。在计算机图形学中，缩放、旋转的变换操作都是线性的，但是<strong>平移不是线性变换</strong>。</p><p>&emsp;&emsp;具有$v’=Mv’+b$形式的变换都是仿射变换。平移作为最常用的变换之一，然而却不是线性变换；所以为了包括平移变换提出了仿射变换。仿射变换是指线性变换后接着平移。因此，仿射变换的集合是线性变换的超集，任何线性变换都是仿射变换，但不是所有的仿射变换都是线性变换。<strong>为了统一用矩阵表示低维度的仿射变换，我们可以通过高维度的线性变换来完成，为此引入了$4$维齐次坐标。</strong>（当然引入第$4$维$w$还有其他的用途，如当$w=0$时，可解释为无穷远的“点”，其意义是描述方向），关于齐次坐标的更多内容请查看<a href="https://www.cnblogs.com/J1ac/p/9340622.html" target="_blank" rel="noopener">这里</a>。</p><p>&emsp;&emsp;从而，对于高维度来说只是经历了一次切变+投影变换就可以实现低维度的平移（更多内容查看<a href="https://www.matongxue.com/madocs/244.html#/madoc" target="_blank" rel="noopener">这里</a>），在$3D$渲染中，我们采用$4\times 4$的矩阵做相应的变换。关于平移和缩放不再赘述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setTranslation(<span class="keyword">const</span> Vector3D &amp;translation)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">12</span>] = translation.x;</span><br><span class="line">    entries[<span class="number">13</span>] = translation.y;</span><br><span class="line">    entries[<span class="number">14</span>] = translation.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4x4::setScale(<span class="keyword">const</span> Vector3D &amp;scaleFactor)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  = scaleFactor.x;</span><br><span class="line">    entries[<span class="number">5</span>]  = scaleFactor.y;</span><br><span class="line">    entries[<span class="number">10</span>] = scaleFactor.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绕任意轴旋转"><a href="#绕任意轴旋转" class="headerlink" title="绕任意轴旋转"></a>绕任意轴旋转</h2><p>&emsp;&emsp;在3D中，绕坐标轴旋转，而不是绕点旋转，此时首先需要定义的是何为旋转正方向： 左手坐标系中定义此方向的规则为左手法则。首先，要明确旋转轴指向哪个方向。当然，旋转轴在理论上是无限延伸的，但我们还是要认为它有正端点和负端点。与笛卡尔坐标轴定义坐标系相同，左手法则是这样的:伸出左手，大拇指向上，其余手指弯曲。大拇指指向旋转轴的正方向，此时，四指弯曲的方向就是旋转的正方向。<strong>右手坐标系则根据右手法则利用右手判断旋转正方向，本文讨论的是常见的右手坐标系。</strong></p><p> &emsp;&emsp;在旋转变换中，一个常见的特殊情况就是绕$x$轴、绕$y$轴、绕$z$轴旋转，这类的旋转矩阵求解比较简单，只需牢牢记住<strong>列主序矩阵的列向量就是变换后的坐标系的基向量</strong>即可快速推导出相应的旋转矩阵：</p><script type="math/tex; mode=display">R_x(\theta)=\left[\begin{matrix}1&0&0\\0&cos\theta&-sin\theta\\0&sin\theta&cos\theta \end{matrix}\right]\\R_y(\theta)=\left[\begin{matrix}cos\theta&0&sin\theta\\0&1&0\\-sin\theta&0&cos\theta \end{matrix}\right]\\R_z(\theta)=\left[\begin{matrix}cos\theta&-sin\theta&0\\sin\theta&cos\theta&0\\0&0&1\end{matrix}\right] \tag {5}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationX(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">5</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">6</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">9</span>]  = -entries[<span class="number">6</span>];</span><br><span class="line">    entries[<span class="number">10</span>] =  entries[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationY(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">2</span>]  = -<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">8</span>]  = -entries[<span class="number">2</span>];</span><br><span class="line">    entries[<span class="number">10</span>] =  entries[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationZ(<span class="keyword">const</span> <span class="keyword">double</span> angle)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">1</span>]  =  <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    entries[<span class="number">4</span>]  = -entries[<span class="number">1</span>];</span><br><span class="line">    entries[<span class="number">5</span>]  =  entries[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是更一般的情况是绕任意轴进行旋转，构建这样的矩阵稍微有点麻烦，我们接下来就做一些绕任意轴旋转的矩阵构建推到。在这里我们不考虑平移，因而围绕旋转的轴一定是通过原点的。如下图1所示，将$\vec v$旋转到$\vec v ‘$，任意轴用单位向量$\vec n$表示，绕$\vec n$旋转$\theta$角度的矩阵记为$R(\vec n, \theta)$，$\vec v’$是向量绕轴$\vec n$旋转后的向量，即$\vec v’=R(\vec n,\theta)\vec v$。</p><p><img src="https://img-my.csdn.net/uploads/201304/08/1365419995_7039.png" alt="img"></p><center>图1 绕任意轴旋转</center><p>&emsp;&emsp;<strong>我们的目标就是用$\vec v$、$\vec n$和$\theta$来表示$\vec v’$，从而构造出$R(\vec n, \theta)$。</strong>首先将$\vec v$分解成平行于$\vec n$的向量$\vec v_{||}$和垂直于$\vec n$的分量$\vec v_{h}$，而$\vec v’_{h}$是垂直于$\vec n$的分向量。注意，$\vec n$是单位向量，但$\vec v$不是单位向量，可得$\vec v$在$\vec n$方向的投影向量$\vec v_{||}$为：</p><script type="math/tex; mode=display">\vec v_{||}=(\vec v\cdot\vec n)\vec n \tag {6}</script><p>&emsp;&emsp;从而根据$\vec v_{||}$和$\vec v$可知$\vec v_{h}$和$w$，$w$是垂直于$\vec n$和$\vec v_{h}$的向量：</p><script type="math/tex; mode=display">\vec v_{h}=\vec v-\vec v_{||} \tag {7}</script><script type="math/tex; mode=display">w=\vec n \times \vec v_{h} = \vec n\times (\vec v-\vec v_{||})\\=\vec n\times\vec v-\vec n\times\vec v_{||}=\vec n\times\vec v-0=\vec n\times \vec v \tag{8}</script><p>&emsp;&emsp;$\vec w$和$\vec v_{h}$相互垂直，$\vec w$、$\vec v_{h}$和$\vec v’_{h}$在同一个平面上，$\vec v’_{h}$和$\vec v_{h}$的夹角为$\theta$，从而$\vec v’_{h}$可由$\vec w$和$\vec v_{h}$线性表示为：</p><script type="math/tex; mode=display">\vec v'_{h}=cos\theta\vec v_{h}+sin\theta\vec w\\=cos\theta(\vec v-(\vec v\cdot\vec n)\vec n)+sin\theta(\vec n\times\vec v)\tag {9}</script><p>&emsp;&emsp;最后，根据公式$(6)$和公式$(9)$我们已知$\vec v_{||}$和$\vec v’_{h}$，从而可以得出$\vec v’$：</p><script type="math/tex; mode=display">\vec v'=\vec v_{||}+\vec v'_{h}\\=cos\theta(\vec v-(\vec v\cdot\vec n)\vec n)+sin\theta(\vec n\times\vec v)+(\vec v\cdot\vec n)\vec n \tag {10}</script><p>&emsp;&emsp;由公式$(10)$可知，我们已经用$\vec v$、$\vec n$和$\theta$表示$\vec v’$，那如何根据上述的公式$(10)$构建旋转矩阵$R(\vec n, \theta)$？还是那个思路：<strong>列主序变换矩阵的列向量就是变换后的坐标系的基向量</strong>。我们只需求出笛卡尔坐标系的$\vec x$、$\vec y$、$\vec z$三个轴方向上的基向量按照公式$(10)$旋转之后的基向量$\vec x’$、$\vec y’$、$\vec z’$，然后填入矩阵$R(\vec n, \theta)$即可，以$\vec x=[1\ \ 0 \ \ 0]^T$为例：</p><script type="math/tex; mode=display">\vec x'=cos\theta(\vec x-(\vec x\cdot\vec n)\vec n)+sin\theta(\vec n\times\vec x)+(\vec x\cdot\vec n)\vec n=\left[\begin{matrix}n^2_x(1-cos\theta)+cos\theta \\n_xn_y(1-cos\theta)+n_zsin\theta \\n_xn_z(1-cos\theta)-n_ysin\theta) \end{matrix}\right] \tag {11}</script><p>&emsp;&emsp;$\vec y=[0\ \  1\ \  0]^T$和$\vec z=[0\ \  0\ \  1]^T$同理：</p><script type="math/tex; mode=display">\vec y'=\left[\begin{matrix}n_xn_y(1-cos\theta)-n_zsin\theta\\n^2_y(1-cos\theta)+cos\theta\\n_yn_z(1-cos\theta)+n_xsin\theta\end{matrix}\right] \tag {12}</script><script type="math/tex; mode=display">\vec z'=\left[\begin{matrix}n_xn_z(1-cos\theta)+n_ysin\theta\\n_yn_z(1-cos\theta)-n_xsin\theta\\n^2_z(1-cos\theta)+cos\theta\end{matrix}\right] \tag {13}</script><p>&emsp;&emsp;将$\vec x’$、$\vec y’$、$\vec z’$合并到$R(\vec n, \theta)$中：</p><script type="math/tex; mode=display">R(\vec n, \theta)=\left[\begin{matrix}\vec x'&\vec y'&\vec z'\end{matrix}\right]\\=\begin{bmatrix}{n_x}^2(1-cos\theta)+cos\theta&n_xn_y(1-cos\theta)-n_zsin\theta&n_xn_z(1-cos\theta)+n_ysin\theta\\n_xn_y(1-cos\theta)+n_zsin\theta&n^2_y(1-cos\theta)+cos\theta&n_yn_z(1-cos\theta)-n_xsin\theta\\n_xn_z(1-cos\theta)-n_ysin\theta)&n_yn_z(1-cos\theta)+n_xsin\theta&n^2_z(1-cos\theta)+cos\theta\end{bmatrix} \tag {14}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setRotationAxis(<span class="keyword">const</span> <span class="keyword">double</span> angle, <span class="keyword">const</span> Vector3D &amp;axis)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3D u = axis.getNormalized();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sinAngle = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    <span class="keyword">float</span> cosAngle = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(M_PI*angle/<span class="number">180</span>));</span><br><span class="line">    <span class="keyword">float</span> oneMinusCosAngle = <span class="number">1.0f</span> - cosAngle;</span><br><span class="line"></span><br><span class="line">    loadIdentity();</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">0</span>]  = (u.x)*(u.x) + cosAngle*(<span class="number">1</span>-(u.x)*(u.x));</span><br><span class="line">    entries[<span class="number">4</span>]  = (u.x)*(u.y)*(oneMinusCosAngle) - sinAngle*u.z;</span><br><span class="line">    entries[<span class="number">8</span>]  = (u.x)*(u.z)*(oneMinusCosAngle) + sinAngle*u.y;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">1</span>]  = (u.x)*(u.y)*(oneMinusCosAngle) + sinAngle*u.z;</span><br><span class="line">    entries[<span class="number">5</span>]  = (u.y)*(u.y) + cosAngle*(<span class="number">1</span>-(u.y)*(u.y));</span><br><span class="line">    entries[<span class="number">9</span>]  = (u.y)*(u.z)*(oneMinusCosAngle) - sinAngle*u.x;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">2</span>]  = (u.x)*(u.z)*(oneMinusCosAngle) - sinAngle*u.y;</span><br><span class="line">    entries[<span class="number">6</span>]  = (u.y)*(u.z)*(oneMinusCosAngle) + sinAngle*u.x;</span><br><span class="line">    entries[<span class="number">10</span>] = (u.z)*(u.z) + cosAngle*(<span class="number">1</span>-(u.z)*(u.z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="透视投影、正交投影"><a href="#透视投影、正交投影" class="headerlink" title="透视投影、正交投影"></a>透视投影、正交投影</h2><p>&emsp;&emsp;$3D$空间中的物体最终都要通过投影显示到$2D$的屏幕上，这一过程就是投影变换。投影变换矩阵将视图空间中的顶点数据变换到裁剪空间，裁剪空间中的顶点最后通过透视除法被变换到标准化设备坐标（$NDC$）。通常由两类投影：透视投影、正交投影。</p><h3 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h3><p>&emsp;&emsp;关于透视投影矩阵的前世今生我不过多说，直接上透视投影矩阵的推导过程。一个视锥体我们目前用六个参数表示：$left$，$right$，$bottom$，$top$，$near$，$far$，简写为$l$、$r$、$b$、$t$、$n$和$f$，即视锥体的六个面。<strong>我们的目标就是将视图空间中在视锥体内的点变换到标准化设备坐标中的立方体内。</strong>即$x$轴方向从$[l,r]$映射到$[-1,1]$，$y$轴方向从$[b,t]$映射到$[-1,1]$，$z$轴方向从$[-n,-f]$映射到$[-1,1]$。</p><p>&emsp;&emsp;<strong>可能你会觉得奇怪，$z$轴方向为什么是从$[-n,-f]$映射到$[-1,1]$？这是因为摄像机空间的坐标系是右手坐标系，在视图空间中摄像机是朝向视图坐标系的$z$轴的负方向，如下图左边所示，$+Y$、$+Z$、$+X$标准摄像机坐标系的三个轴，而摄像机的观察视锥体是朝向$-Z$方向的。而$NDC$又是左手坐标系，朝向$+Z$方向，所以我们要取负。</strong></p><p><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix01.png" alt="OpenGL Perspective Frustum and NDC"></p><center>图2 透视投影视锥和标准化设备坐标</center><p><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix03.png" alt="Top View of Frustum"></p><center>图3 从-Y方向看去的视锥横截面</center><p><img src="http://www.songho.ca/opengl/files/gl_projectionmatrix04.png" alt="Side View of Frustum"></p><center>图4 从-X方向看去的视锥横截面</center><p>&emsp;&emsp;在视锥体中的顶点$(x_e,y_e,z_e)$被投影到视锥体的近平面，近平面上的点我们记为$(x_p,y_p,-n)$。如图3和图4所示，根据三角形相似的原理，我们有：</p><script type="math/tex; mode=display">\frac{x_p}{x_e}=\frac{-n}{z_e}\ \rightarrow\ x_p=\frac{-n\cdot x_e}{z_e}=\frac{n\cdot x_e}{-z_e} \tag {15}</script><script type="math/tex; mode=display">\frac{y_p}{y_e}=\frac{-n}{y_e}\ \rightarrow\ y_p=\frac{-n\cdot y_e}{z_e}=\frac{n\cdot y_e}{-z_e} \tag {16}</script><p>&emsp;&emsp;注意到公式$(15)$和$(16)$中分母都是一个$-z_e$，这与我们将裁剪空间中的顶点做透视除法相对应，透视投影然后做透视除法如下公式$(17)$、$(18)$所示：</p><script type="math/tex; mode=display">\left(\begin{matrix}x_{clip}\\y_{clip}\\z_{clip}\\w_{clip}\end{matrix}\right)=M_{projection}\cdot\left(\begin{matrix}x_{eye}\\y_{eye}\\z_{eye}\\w_{eye}\end{matrix}\right) \tag {17}</script><script type="math/tex; mode=display">\left(\begin{matrix}x_{ndc}\\y_{ndc}\\z_{ndc}\end{matrix}\right)=\left(\begin{matrix}x_{clip}/w_{clip}\\y_{clip}/w_{clip}\\z_{clip}/w_{clip}\end{matrix}\right) \tag {18}</script><p>&emsp;&emsp;为了便于构建矩阵（$x_e$和$y_e$均与$-z_e$相除，不好构建矩阵），我们令裁剪空间中的$w_{clip}$为$-z_e$，将除以$-z_e$的这一步挪到了透视除法去做。故目前的透视矩阵就变为：</p><script type="math/tex; mode=display">\left(\begin{matrix}x_{c}\\y_{c}\\z_{c}\\w_{c}\end{matrix}\right)=\left(\begin{matrix}.&.&.&.\\.&.&.&.\\.&.&.&.\\0&0&-1&0\end{matrix}\right)    \left(\begin{matrix}x_{e}\\y_{e}\\z_{e}\\w_{e}\end{matrix}\right) \tag  {19}</script><p>&emsp;&emsp;其中”$.$”均表示未知。得到在近平面的$x_p$和$y_p$之后，我们还要将$x_p$映射到$[-1,1]$范围，同理$y_p$也是。以$x_p$为例，我们知道其值域为$[l,r]$。为了将$x_p$其映射到$[-1,1]$，我们首先将其映射到$[0,1]$，不难得到如下式子：</p><script type="math/tex; mode=display">\frac{x_p-l}{r-l}\in[0,1] \tag {20}</script><p>&emsp;&emsp;式$(20)$乘上一个$2$再减去$1$就映射到了$[-1,1]$，映射之后记为$x_n$：</p><script type="math/tex; mode=display">x_n=2\frac{x_p-l}{r-l}-1=\frac{2x_p}{r-l}-\frac{r+l}{r-l}\in[-1,1] \tag {21}</script><p>&emsp;&emsp;同理$y_p$到$y_n$的映射：</p><script type="math/tex; mode=display">y_n=\frac{2y_p}{r-l}-\frac{t+b}{t-b}\in[-1,1] \tag {22}</script><p>&emsp;&emsp;然后将公式$(15)$中的$x_p$带入公式$(21)$，将公式$(16)$中的$y_p$带入公式$(22)$，以$x_p$为例：</p><script type="math/tex; mode=display">x_n=\frac{2x_p}{r-l}-\frac{r+l}{r-l}=\frac{2\frac{n\cdot x_e}{-z_e}}{r-l}-\frac{r+l}{r-l}\\=\frac{2n\cdot x_e}{(r-l)(-z_e)}-\frac{r+l}{r-l}=\frac{\frac{2n}{r-l}\cdot x_e}{-z_e}-\frac{r+l}{r-l}\\=\frac{\frac{2n}{r-l}\cdot x_e}{-z_e}+\frac{\frac{r+l}{r-l}\cdot z_e}{-z_e}=\underbrace{(\frac{2n}{r-l}\cdot x_e+\frac{r+l}{r-l}\cdot z_e)}_{x_c}/-z_e \tag {23}</script><p>&emsp;&emsp;其中$x_c$即公式$(19)$中的裁剪空间中的$x$轴坐标值。$y_p$同理可得$y_c$:</p><script type="math/tex; mode=display">y_n=\underbrace{(\frac{2n}{t-b}\cdot y_e+\frac{t+b}{t-b}\cdot z_e)}_{y_c}/-z_e \tag {24}</script><p>&emsp;&emsp;现在我们已经知道了$x_c$和$y_c$分辨关于$x_e$、$y_e$以及$z_e$的表达形式，我们可以填充式$(19)$中的投影矩阵第一行与第二行：</p><script type="math/tex; mode=display">\left(\begin{matrix}x_{c}\\y_{c}\\z_{c}\\w_{c}\end{matrix}\right)=\left(\begin{matrix}\frac{2n}{r-l}&0&\frac{r+l}{r-l}&0\\0&\frac{2n}{t-b}&\frac{t+b}{t-b}&0\\0&0&A&B\\0&0&-1&0\end{matrix}\right)    \left(\begin{matrix}x_{e}\\y_{e}\\z_{e}\\w_{e}\end{matrix}\right) \tag  {25}</script><p>&emsp;&emsp;现在我们还剩下投影矩阵的第三行还不知道。因为我们知道$z$的投影与$x_e$和$y_e$无关，只与$z_e$、$w_e$有关，故可以假设投影矩阵的第三行如上式$(25)$所示，$A$和$B$就是我们假设的要求解的未知表达式。此外，在视图空间中的$w_e$是等于$1$的，$w_c$即前面提到的$-z_e$，从而有：</p><script type="math/tex; mode=display">z_n=z_c/w_c=\frac{Az_e+Bw_e}{-z_e}=\frac{Az_e+B}{-z_e} \tag {26}</script><p>&emsp;&emsp;为了求出公式$(26)$中的$A$和$B$，我们取两个极端的例子：在$-n$处的$z$值被映射到$-1$，在$-f$处的$z$值被映射到$1$，将$(z_n,z_e)=(-1,-n)$和$(z_n,z_e)=(1,-f)$带入式$(26)$中，可得方程组：</p><script type="math/tex; mode=display">\begin{cases}\frac{-An+B}{n}=-1\\\frac{-Af+B}{f}=1\\\end{cases}\ \rightarrow\ \begin{cases}{-An+B}=-n\\{-Af+B}=f\\\end{cases} \tag {27}</script><p>&emsp;&emsp;求解方程$(27)$，可得$A$与$B$如下所示：</p><script type="math/tex; mode=display">A=-\frac{f+n}{f-n}\\B=-\frac{2fn}{f-n} \tag {28}</script><p>&emsp;&emsp;将公式$(28)$带入公式$(26)$中：</p><script type="math/tex; mode=display">z_n=\underbrace{(-\frac{f+n}{f-n}z_e-\frac{2fn}{f-n})}_{z_c}/{-z_e} \tag {29}</script><p>&emsp;&emsp;我们最终得到了$z_c$关于$z_e$的表达式，将$A$与$B$填入式$(25)$的投影矩阵即可，$M_{projection}$就是我们一直在寻求的透视投影矩阵：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2n}{r-l}&0&\frac{r+l}{r-l}&0\\0&\frac{2n}{t-b}&\frac{t+b}{t-b}&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)     \tag {30}</script><p>&emsp;&emsp;公式$(30)$中的透视投影矩阵只是一个通用的形式，在视图空间中的视锥体通常都是关于$x$轴和$y$轴对称的，从而有$r=-l$、$t=-b$，将式$(30)$简化成如下形式：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2n}{r-l}&0&0&0\\0&\frac{2n}{t-b}&0&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)     \tag {31}</script><p>&emsp;&emsp;&emsp;但是通常我们传入构建透视矩阵函数的参数是$fovy$（$y$轴方向的视域角）、$aspect$（屏幕的宽高比）、$near$（近平面）以及$far$（远平面），如何根据这些参数构造式$(31)$的透视投影矩阵呢？注意到$r-l=width$即近平面宽度，$t-b=height$即近平面的高度，我们可以根据$fovy$和$aspect$得出$width$和$height$，具体细节不再赘述：</p><script type="math/tex; mode=display">r-l=width=2*near*aspect*tan(fovy/2)\\t-b=height=2*near*tan(fovy/2)</script><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{1}{aspect*tan(fovy/2)}&0&0&0\\0&\frac{1}{tan(fovy/2)}&0&0\\0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\0&0&-1&0\end{matrix}\right)     \tag {32}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setPerspective(<span class="keyword">float</span> fovy, <span class="keyword">float</span> aspect, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span><br><span class="line">&#123;</span><br><span class="line">    loadZero();</span><br><span class="line">    <span class="comment">// convert fov from degrees to radians</span></span><br><span class="line">    <span class="keyword">float</span> rFovy = fovy*M_PI/<span class="number">180</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> tanHalfFovy = tanf(<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(rFovy*<span class="number">0.5f</span>));</span><br><span class="line">    entries[<span class="number">0</span>]         = <span class="number">1.0f</span>/(aspect*tanHalfFovy);</span><br><span class="line">    entries[<span class="number">5</span>]         = <span class="number">1.0f</span>/(tanHalfFovy);</span><br><span class="line">    entries[<span class="number">10</span>]        = -(far+near)/(far-near);</span><br><span class="line">    entries[<span class="number">11</span>]        = <span class="number">-1.0f</span>;</span><br><span class="line">    entries[<span class="number">14</span>]        = (<span class="number">-2.0f</span>*near*far)/(far-near);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h3><p>&emsp;&emsp;理解了透视投影矩阵的构造之后，正交投影就简单太多了，正交投影只需做简单的线性映射就行了。只需将$x$轴方向从$[l,r]$映射到$[-1,1]$，$y$轴方向从$[b,t]$映射到$[-1,1]$，$z$轴方向从$[-n,-f]$映射到$[-1,1]$，而这个映射的过程很简单，正如前面公式$(20)$和$(21)$那样，先映射到$[0,1]$，再映射到$[0,2]$，最后映射到$[-1,1]$，这个过程我也不细说了，直接上结果：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2}{r-l}&0&0&-\frac{r+l}{r-l}\\0&\frac{2}{t-b}&0&-\frac{t+b}{t-b}\\0&0&\frac{-2}{f-n}&-\frac{f+n}{f-n}\\0&0&0&1\end{matrix}\right)     \tag {33}</script><p>&emsp;&emsp;然后又因为视锥体关于$x$轴、$y$轴对称，简化的正交投影矩阵就为：</p><script type="math/tex; mode=display">M_{projection}=\left(\begin{matrix}\frac{2}{r-l}&0&0&0\\0&\frac{2}{t-b}&0&0\\0&0&\frac{-2}{f-n}&-\frac{f+n}{f-n}\\0&0&0&1\end{matrix}\right)     \tag {33}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setOrtho(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span><br><span class="line">&#123;</span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>]     =  <span class="number">2.0f</span>/(right-left);</span><br><span class="line">    entries[<span class="number">5</span>]     =  <span class="number">2.0f</span>/(top-bottom);</span><br><span class="line">    entries[<span class="number">10</span>]    = <span class="number">-2.0f</span>/(far-near);</span><br><span class="line">    entries[<span class="number">12</span>]    = -(right+left)/(right-left);</span><br><span class="line">    entries[<span class="number">13</span>]    = -(top+bottom)/(top-bottom);</span><br><span class="line">    entries[<span class="number">14</span>]    = -(far+near)/(far-near);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lookAt函数构造视图矩阵"><a href="#lookAt函数构造视图矩阵" class="headerlink" title="lookAt函数构造视图矩阵"></a>lookAt函数构造视图矩阵</h2><p>&emsp;&emsp;视图矩阵的工作目标是将世界坐标系中的所有物体的顶点的坐标从世界坐标系转换到摄像机坐标系。这是因为摄像机坐标系的原点不一定与世界坐标系重合，同时由于自身的旋转，坐标轴也一定不与世界坐标系的坐标轴平行。为完成工作任务，需要分为两步走：首先整体平移，将摄像机平移至世界坐标系原点，然后将顶点从世界坐标系变换至摄像机坐标系。</p><p>&emsp;&emsp;lookAt函数的输入参数分别为：$eye$摄像机的位置，$target$摄像机目标点，$up$世界空间的上向量,。首先我们要根据这些参数确定摄像机坐标系的三个轴向量，<strong>其中需要非常注意的就是变换到视图空间中时摄像机是朝向视图空间的$-Z$方向的，所以求视图空间中的$Z$轴时是摄像机的位置减去目标点的位置</strong>：</p><script type="math/tex; mode=display">Z = normalize(eye - target)\\X = normalize(cross(up, Z))\\Y = normalize(cross(Z,X))</script><p>&emsp;&emsp;通过以上的方式我们就求出了视图空间的三条轴向量，再加上摄像机的位置我们就可以求出将世界坐标变换到与视图坐标重合的矩阵了，记为$M=T\cdot R$，其中$T$是平移到摄像机位置$eye$的变换矩阵，$R$是旋转到摄像机坐标轴方向的旋转矩阵：</p><script type="math/tex; mode=display">M=T\cdot R=\left[\begin{matrix}1&0&0&eye_x\\0&1&0&eye_x\\0&0&1&eye_x\\0&0&0&1\end{matrix}\right]\cdot\left[\begin{matrix}X_x&Y_x&Z_x&0\\X_y&Y_y&Z_y&0\\X_z&Y_z&Z_z&0\\0&0&0&1\end{matrix}\right] \tag {34}</script><p>&emsp;&emsp;<strong>然而公式$(34)$并不是我们要求的视图矩阵，上式中的矩阵$M$仅仅是将世界坐标轴变换到摄像机坐标轴。摄像机只是一个虚拟的物品，我们不能将上述的矩阵$M$作用于摄像机，因为摄像机根本不存在！我们视图矩阵最终作用的世界空间中的物体，这就涉及到了一个相对运动的概念！</strong></p><p>&emsp;&emsp;<strong>当我们向前移动摄像机的时候，可以看成是摄像机不动，而物体朝着与摄像机朝向相反的方向移动。当我们向右旋转摄像机时，相当于摄像机不动而物体朝着摄像机的左边移动。摄像机的构造得益于相对于运动的理论，计算机图形学中的虚拟$3D$摄像机实际上是通过物体的移动来实现的，所以我们要构造的视图矩阵是公式$(34)$中的逆矩阵。</strong></p><script type="math/tex; mode=display">viewMatrix = M^{-1}=(T\cdot R)^{-1}=R^{-1}\cdot T^{-1}=\left[\begin{matrix}X_x&Y_x&Z_x&0\\X_y&Y_y&Z_y&0\\X_z&Y_z&Z_z&0\\0&0&0&1\end{matrix}\right]^{-1}\cdot\left[\begin{matrix}1&0&0&eye_x\\0&1&0&eye_x\\0&0&1&eye_x\\0&0&0&1\end{matrix}\right]^{-1} \tag {35}</script><p>&emsp;&emsp;由上式可知，构造视图矩阵涉及到$R$和$T$的求逆，其中的平移矩阵$T$的求逆则是直接取平移量的相反数即可：</p><script type="math/tex; mode=display">T^{-1}=\left[\begin{matrix}1&0&0&eye_x\\0&1&0&eye_x\\0&0&1&eye_x\\0&0&0&1\end{matrix}\right]^{-1}=\left[\begin{matrix}1&0&0&-eye_x\\0&1&0&-eye_x\\0&0&1&-eye_x\\0&0&0&1\end{matrix}\right] \tag {36}</script><p>&emsp;&emsp;至于旋转矩阵$R$，我们知道旋转矩阵都是正交矩阵，正交矩阵的一个特点就是它的逆等于它的转置：</p><script type="math/tex; mode=display">R^{-1}=\left[\begin{matrix}X_x&Y_x&Z_x&0\\X_y&Y_y&Z_y&0\\X_z&Y_z&Z_z&0\\0&0&0&1\end{matrix}\right]^{-1}=\left[\begin{matrix}X_x&X_y&X_z&0\\Y_x&Y_y&Y_z&0\\Z_x&Z_y&Z_z&0\\0&0&0&1\end{matrix}\right] \tag {37}</script><p>&emsp;&emsp;最后，我们得到视图矩阵：</p><script type="math/tex; mode=display">viewMatrix=R^{-1}\cdot T^{-1}=\left[\begin{matrix}X_x&X_y&X_z&0\\Y_x&Y_y&Y_z&0\\Z_x&Z_y&Z_z&0\\0&0&0&1\end{matrix}\right]\cdot\left[\begin{matrix}1&0&0&-eye_x\\0&1&0&-eye_x\\0&0&1&-eye_x\\0&0&0&1\end{matrix}\right]\\=\left[\begin{matrix}X_x&X_y&X_z&-(\vec X\cdot \vec {eye})\\Y_x&Y_y&Y_z&-(\vec Y\cdot \vec {eye})\\Z_x&Z_y&Z_z&-(\vec Z\cdot \vec {eye})\\0&0&0&1\end{matrix}\right] \tag {38}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4x4::setLookAt(Vector3D cameraPos, Vector3D target, Vector3D worldUp)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3D zAxis = cameraPos - target;</span><br><span class="line">    zAxis.normalize();</span><br><span class="line">    Vector3D xAxis = worldUp.crossProduct(zAxis);</span><br><span class="line">    xAxis.normalize();</span><br><span class="line">    Vector3D yAxis = zAxis.crossProduct(xAxis);</span><br><span class="line">    yAxis.normalize();</span><br><span class="line"></span><br><span class="line">    loadIdentity();</span><br><span class="line">    entries[<span class="number">0</span>] = xAxis.x;</span><br><span class="line">    entries[<span class="number">4</span>] = xAxis.y;</span><br><span class="line">    entries[<span class="number">8</span>] = xAxis.z;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">1</span>] = yAxis.x;</span><br><span class="line">    entries[<span class="number">5</span>] = yAxis.y;</span><br><span class="line">    entries[<span class="number">9</span>] = yAxis.z;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">2</span>] = zAxis.x;</span><br><span class="line">    entries[<span class="number">6</span>] = zAxis.y;</span><br><span class="line">    entries[<span class="number">10</span>] = zAxis.z;</span><br><span class="line"></span><br><span class="line">    entries[<span class="number">12</span>] = -(xAxis.dotProduct(cameraPos));</span><br><span class="line">    entries[<span class="number">13</span>] = -(yAxis.dotProduct(cameraPos));</span><br><span class="line">    entries[<span class="number">14</span>] = -(zAxis.dotProduct(cameraPos));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>$[1]$ <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank" rel="noopener">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></p><p>$[2]$ <a href="https://blog.csdn.net/zsq306650083/article/details/8773996" target="_blank" rel="noopener">https://blog.csdn.net/zsq306650083/article/details/8773996</a></p><p>$[3]$ <a href="https://blog.csdn.net/y1196645376/article/details/78463248" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/78463248</a></p><p>$[4]$ <a href="https://www.cnblogs.com/J1ac/p/9340622.html" target="_blank" rel="noopener">https://www.cnblogs.com/J1ac/p/9340622.html</a></p><p>$[5]$ <a href="https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Soft Renderer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Soft Renderer </tag>
            
            <tag> 3D Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流体模拟基础</title>
      <link href="/2019/05/01/fluidSimulation/"/>
      <url>/2019/05/01/fluidSimulation/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。</p><a id="more"></a><ul><li>矢量微积分</li><li>Naiver-Stokes偏微分方程组</li><li>N-S方程的分步求解</li><li>对流算法</li></ul><h2 id="一、矢量微积分"><a href="#一、矢量微积分" class="headerlink" title="一、矢量微积分"></a>一、矢量微积分</h2><p>&emsp;&emsp;高等数学中太多数讨论的是一维的微积分，而矢量微积分则是一维微积分的高维扩展。矢量微积分的三个基础算子：<strong>梯度</strong>（符号为$∇$），<strong>散度</strong>（符号为$∇\cdot$)，<strong>旋度</strong>（符号为$∇\times$），在此基础上流体力学中经常用到的还有拉普拉斯算子。</p><h3 id="1、梯度（Gradient）"><a href="#1、梯度（Gradient）" class="headerlink" title="1、梯度（Gradient）"></a>1、梯度（Gradient）</h3><p>&emsp;&emsp;梯度实际上就是矢量的空间偏导数，且结果依然是一个矢量，$2$维的梯度如下：</p><script type="math/tex; mode=display">∇f(x,y)=(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}) \tag {1.1}</script><p>&emsp;&emsp;依此类推，$3$维的梯度有如下形式：</p><script type="math/tex; mode=display">∇f(x,y,z)=(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y},\frac{\partial f}{\partial z}) \tag {1.2}</script><p>&emsp;&emsp;有时也会采用如下形式来表示梯度：</p><script type="math/tex; mode=display">∇f=\frac{\partial f}{\partial \vec x} \tag {1.3}</script><p>&emsp;&emsp;梯度通常用来近似计算函数值（实际上就是一维形式的推广)：</p><script type="math/tex; mode=display">f(\vec x+\Delta \vec x)\approx f(\vec x)+∇f(\vec x)\cdot \Delta \vec x \tag {1.4}</script><p>&emsp;&emsp;同样的，多个函数的梯度就构成了一个矩阵：</p><script type="math/tex; mode=display">∇\vec F=∇(f,g,h)=\left(   \begin{matrix}   \frac{\partial f}{\partial x} & \frac{\partial f}{\partial y} & \frac{\partial f}{\partial z} \\   \frac{\partial g}{\partial x} & \frac{\partial g}{\partial y} & \frac{\partial g}{\partial z} \\   \frac{\partial h}{\partial x} & \frac{\partial h}{\partial y} & \frac{\partial h}{\partial z} \\  \end{matrix}  \right)  =\left( \begin{matrix}∇f\\ ∇g\\ ∇h\\ \end{matrix}  \right) \tag {1.5}</script><h3 id="2、散度（Divergence）"><a href="#2、散度（Divergence）" class="headerlink" title="2、散度（Divergence）"></a>2、散度（Divergence）</h3><p>&emsp;&emsp;散度算子仅仅应用于向量场，它衡量在某一点出相应的矢量聚集或者发散程度，测量方向为<strong>径向</strong>，结果为标量。$2$维、$3$维形式的散度算子如下所示：</p><script type="math/tex; mode=display">∇\cdot \vec u=∇\cdot (u,v)=\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}</script><script type="math/tex; mode=display">∇\cdot \vec u=∇\cdot (u,v,w)=\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}+\frac{\partial w}{\partial z} \tag {1.6}</script><p>&emsp;&emsp;输入是矢量，而输出为标量。类比梯度，散度符号$∇\cdot \vec u$可以理解为梯度$∇$与矢量$\vec u$的点乘：</p><script type="math/tex; mode=display">∇\cdot \vec u=(\frac{\partial}{\partial x},\frac{\partial}{\partial y},\frac{\partial}{\partial z})\cdot (u,v,w)=\frac{\partial}{\partial x}u+\frac{\partial}{\partial y}v+\frac{\partial}{\partial z}w \tag {1.7}</script><p>&emsp;&emsp;若矢量场散度为$0$，则称该矢量场<strong>无散度</strong>。</p><h3 id="3、旋度（Curl）"><a href="#3、旋度（Curl）" class="headerlink" title="3、旋度（Curl）"></a>3、旋度（Curl）</h3><p>&emsp;&emsp;旋度衡量围绕某一点的旋转速度，测量方向为<strong>切向</strong>，三维形式的旋度是一个向量：</p><script type="math/tex; mode=display">∇\times \vec u=∇\times (u,v,w)=(\frac{\partial w}{\partial y}-\frac{\partial v}{\partial z},\frac{\partial u}{\partial z}-\frac{\partial w}{\partial x},\frac{\partial v}{\partial x}-\frac{\partial u}{\partial y}) \tag {1.8}</script><p>&emsp;&emsp;倒推到$2$维，我们取上式中的$w=0$，即矢量场为$(u,v,0)$，$2$维向量场的旋度是一个标量：</p><script type="math/tex; mode=display">∇\times \vec u=∇\times (u,v)=\frac{\partial v}{\partial x}-\frac{\partial u}{\partial y} \tag {1.9}</script><p>&emsp;&emsp;同样地，旋度符号$∇\times \vec u$我们可以理解为梯度$∇$与矢量场$\vec u$的叉乘：</p><script type="math/tex; mode=display">∇\times \vec u=(\frac{\partial }{\partial x},\frac{\partial }{\partial y},\frac{\partial }{\partial z})\times(u,v,w) \tag {1.10}</script><p>&emsp;&emsp;若矢量场旋度为$0$，则称该矢量场<strong>无旋度</strong>。</p><h3 id="4、拉普拉斯算子（Laplacian）"><a href="#4、拉普拉斯算子（Laplacian）" class="headerlink" title="4、拉普拉斯算子（Laplacian）"></a>4、拉普拉斯算子（Laplacian）</h3><p>&emsp;&emsp;拉普拉斯算子定义为梯度的散度，符号表示为$∇\cdot∇$，显然$∇\cdot$是散度，而后面的$∇$则为梯度，故拉普拉斯算子即梯度的散度，是一个二阶微分算子。$2$维、$3$维形式分别如下：</p><script type="math/tex; mode=display">∇\cdot∇f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}</script><script type="math/tex; mode=display">∇\cdot∇f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}+\frac{\partial^2f}{\partial z^2} \tag {1.11}</script><p>&emsp;&emsp;简言之，拉普拉斯算子定义如下：</p><script type="math/tex; mode=display">∇\cdot∇f=\Sigma_{i=1}^n\frac{\partial^2f}{\partial x_i^2} \tag {1.12}</script><p>&emsp;&emsp;偏微分方程$∇\cdot ∇f=0$被称为拉普拉斯方程；而如果右边为某个非$0$常数，即$∇\cdot ∇f=q$，我们称之为泊松方程。更一般地，如果梯度再乘上一个标量$a$（如$1/\rho$)，即$∇\cdot (a∇f)=q$，我们依旧称之为泊松问题。</p><h2 id="二、-Naiver-Stokes-偏微分方程组"><a href="#二、-Naiver-Stokes-偏微分方程组" class="headerlink" title="二、$Naiver-Stokes$偏微分方程组"></a>二、$Naiver-Stokes$偏微分方程组</h2><p>&emsp;&emsp;流体模拟器的构建主要围绕著名的不可压缩$Navier-Stokes$方程展开，它是一个流体力学领域的偏微分方程，方程形式如下：</p><script type="math/tex; mode=display">\frac{\partial \vec u}{\partial t}+\vec u\cdot ∇\vec u+\frac1\rho∇p=\vec g+\nu∇\cdot∇\vec u \tag {2.1}</script><script type="math/tex; mode=display">∇\cdot\vec u=0 \tag {2.2}</script><p>&emsp;&emsp;这个方程组看起非常地复杂，接下来我们就把它剖析成一个个比较简单的部分来理解。</p><h3 id="1、符号标记"><a href="#1、符号标记" class="headerlink" title="1、符号标记"></a>1、符号标记</h3><p>&emsp;&emsp;我们有必要定义一些物理量的符号用以标记：</p><p>&emsp;&emsp;符号$\vec u$在流体力学中通常表示为流体的速度矢量，记$3$维的速度矢量$\vec u=(u,v,w)$；</p><p>&emsp;&emsp;希腊字符$\rho$是流体的密度，对于水，该值大约为$1000kg/m^3$，而空气则大约为$1.3kg/m^3$；</p><p>&emsp;&emsp;字符$p$代表压力，流体对任何物体施加的单位面积力；</p><p>&emsp;&emsp;字符$\vec g$则是我们熟悉的重力加速度，通常取$(0,-9.81,0)m/s^2$。我们约定$y$轴向上，而$x$轴和$z$轴在水平面上。另外补充一点，我们把其他的一些类似的力都累加到$\vec g$上，也就是我们统一用$\vec g$表示所有类似力之和，这类力我们称之为<strong>体积力</strong>（称之为体积力是因为它们的力是作用到整个流体而不只是流体的表面）；</p><p>&emsp;&emsp;希腊字符$\nu$是流体的运动粘度，它衡量流体的黏滞性。糖蜜之类的流体有非常高的粘度，而像酒精之类的流体有很低的粘度；</p><p>&emsp;&emsp;其它一些矢量微积分的符号算子前面已经提到过，不再赘述。</p><h3 id="2、动量方程"><a href="#2、动量方程" class="headerlink" title="2、动量方程"></a>2、动量方程</h3><p>&emsp;&emsp;偏微分方程$(2.1)$我们称之为<strong>动量方程</strong>，它本质上就是我们熟悉的牛顿定律$\vec F=m\vec a$的形式，描述了施加在流体上的力是如何影响流体的运动。</p><p>&emsp;&emsp;假设我们用粒子系统来模拟流体，每个粒子代表流体的一小滴，每个粒子有各自的质量$m$、体积$V$和速度$\vec u$。为了让整个粒子系统运作起来，我们必须弄清楚每个粒子所承受的力的作用。牛顿第二定律告诉我们：$\vec F=m\vec a$，而根据加速度定义，我们有：</p><script type="math/tex; mode=display">\vec a=\frac{D\vec u}{Dt} \tag {2.3}</script><p>&emsp;&emsp;符号$D$是指<strong>物质导数</strong>，所谓物质导数，就是对流体质点求导数，而且是针对流体质点（在这里就是流体粒子）而不是空间的固定点。因而牛顿第二定律就变成：</p><script type="math/tex; mode=display">m\frac{D\vec u}{Dt}=\vec F \tag {2.4}</script><p>&emsp;&emsp;那么流体粒子承受的力有哪些呢？一个最简单的力就是重力：$m\vec g$。而其他的流体质点（或其他流体粒子）也会对当前的流体粒子产生作用力。流体内部的相互作用力之一便是压力，较大压力的区域会向较低压力区域产生作用力。值得注意的是，我们只关注施加在粒子上的压力的净合力。例如，若施加在粒子上压力在每个方向上都相等，那么它的压力的合力便为0。我们用压力的负梯度（取负是因为方向是由压力大的区域指向压力小的区域）来衡量在当前流体粒子处压力的不平衡性，即取$-∇p$。那么流体粒子所承受的压力就是对$-∇p$在整个流体粒子的体积上进行积分，为了简化，我们简单地将$V$与$-∇p$相乘，故粒子压力部分为$-V∇p$。</p><p>&emsp;&emsp;其他的流体相互作用力则是由流体的黏性产生的，我们直观地把这种力理解为尽可能使得粒子以周围区域的平均速度移动的力，也就是使得粒子的速度与周围区域粒子速度的差距最小化。拉普拉斯算子是衡量一个量与之周围区域该量平均值之差的算符，因而$∇\cdot∇\vec u$是当前粒子速度矢量与周围区域平均速度矢量之差。为了计算粘滞力，我们同样对$∇\cdot∇\vec u$在整个粒子体积$V$上进行积分，与前面类似，我们简单取$V∇\cdot∇\vec u$。除此之外，我们还引进一个称为动力粘度系数的物理量，符号为$\mu$。因而粘滞力为$V\mu∇\cdot∇\vec u$。</p><p>&emsp;&emsp;把重力、压力和粘滞力综合一起，我们可得：</p><script type="math/tex; mode=display">m\frac{D\vec u}{Dt}=\vec F=m\vec g-V∇p+V\mu∇\cdot∇\vec u \tag {2.5}</script><p>&emsp;&emsp;当粒子系统中的粒子数量趋于无穷大，而每个粒子大小趋于$0$时，会产生一个问题：此时每个粒子的质量$m$和体积$V$变为$0$，此时上式变得没有意义。为此，我们把$(2.5)$式调整一下，两边同除以体积$V$，又因$\rho=m/V$，故有：</p><script type="math/tex; mode=display">\rho\frac{D\vec u}{Dt}=\rho\vec g-∇p+\mu∇\cdot∇\vec u \tag {2.6}</script><p>&emsp;&emsp;两边同除以$\rho$，移项调整：</p><script type="math/tex; mode=display">\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g+\frac\mu\rho∇\cdot∇\vec u \tag {2.7}</script><p>&emsp;&emsp;为了进一步简化，定义运动粘度为$\nu=\mu/\rho$，式$(2.7)$变为：</p><script type="math/tex; mode=display">\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g+\nu∇\cdot∇\vec u \tag {2.8}</script><p>&emsp;&emsp;我们已经快把动量方程推导出来，现在我们要把物质导数$\frac{D\vec u}{Dt}$弄清楚，为此，我们需要了解两种描述方法：<strong>拉格朗日描述</strong>和<strong>欧拉描述</strong>。</p><h3 id="3、拉格朗日描述与欧拉描述"><a href="#3、拉格朗日描述与欧拉描述" class="headerlink" title="3、拉格朗日描述与欧拉描述"></a>3、拉格朗日描述与欧拉描述</h3><p>&emsp;&emsp;当我们尝试研究流体或可变形固体的运动的时候，通常有两种方法来描述：<strong>拉格朗日描述</strong>（ Lagrangian viewpoint）、<strong>欧拉描述</strong>（Eulerian viewpoint）。</p><p>&emsp;&emsp;拉格朗日描述方法是我们比较熟悉的方法，这种描述方法把物体看成是由类似于粒子系统的形式组成，固体或流体的每个点看作一个独立的粒子，粒子有各自相应的位置$\vec x$和速度$\vec u$。我们可以把粒子理解为组成物体的分子。对于我们通常采用拉格朗日描述法进行建模模拟，即用一系列离散的粒子集来构建，粒子之间通过网格相联系。</p><p>&emsp;&emsp;欧拉描述方法则采用了完全不同的角度，它常被用于流体力学中。与拉格朗日描述追踪每个物体粒子的方法不同，欧拉描述关注点是空间中的一个固定点，并考察在这个固定点上流体性质（如密度、速度、温度等）是如何随着时间变化的。流体流动经过这个固定点可能会导致这个固定点的物理性质发生一些变化（如一个温度较高的流体粒子流经这个固定点，后面紧跟着一个温度较低的流体粒子流过固定点，那么这个固定点的温度会降低，但是并没有任何一个流体粒子的温度发生了变化）。</p><p>&emsp;&emsp;用天气测量举个简单的例子：拉格朗日描述方法就是你乘坐在一个随风而飘的热气球上，测量周围空气的压力、密度和浑浊度等天气指标；而欧拉描述方法就是你固定在地面上，测量流过的空气的天气指标。</p><p>&emsp;&emsp;欧拉描述法似乎看起来带来了一些不必要的复杂度，但是目前大多数的流体模拟器都是基于欧拉描述法，这是因为欧拉描述法相比于拉格朗日描述法有一些不可比拟的优点：欧拉描述法能够更加方便地计算一些物理量的空间导数（例如压力梯度和粘度）；而如果用粒子方法的话（即拉格朗日描述法），那么计算物理量相对于空间位置的变化是比较难的。</p><p>&emsp;&emsp;把拉格朗日描述法和欧拉描述法联系起来的关键点就是物质导数。首先从拉格朗日描述法出发，假设有一群粒子，每个粒子都有各自的位置$\vec x$和速度$\vec u$。记$q$为通用的物理量（如密度、速度和温度等），每个粒子有其对应的$q$值。方程$q(t,\vec x)$描述在时间点$t$而位置为$\vec x$的粒子对应的物理量值$q$。则一个粒子的物理量$q$随时间$t$的变化率是多少？这是一个拉格朗日描述角度下的问题，我们取对时间$t$的导数（注意用到了求导链式法则，以及$\frac{\partial q}{\partial \vec x}=∇q$和$\vec u=\frac{d\vec x}{dt}）$：</p><script type="math/tex; mode=display">\frac d{dt}q(t,\vec x)=\frac{\partial q}{\partial t}+∇q\cdot\frac{d\vec x}{dt}=\frac{\partial q}{\partial t}+∇q\cdot\vec u\equiv\frac{Dq}{Dt} \tag {2.9}</script><p>&emsp;&emsp;这就是物质导数。把式$(2.9)$代入式$(2.8)$我们就得到了流体动量方程$(2.1)$。物质导数针对的是流体质点（在这里就是流体粒子）而不是空间的固定点。式$(2.9)$写完整一点就是：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}+v\frac{\partial q}{\partial y}+w\frac{\partial q}{\partial z} \tag {2.10}</script><p>&emsp;&emsp;对于给定的速度场$\vec u$， 流体的物理性质如何在这个速度场$\vec u$下变化的计算我们称之为<strong>对流</strong>（advection）。一个最简单的对流方程，就是其物理量的物质导数为$0$，如下所示：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=0\implies\frac{\partial q}{\partial t}+\vec u\cdot ∇q = 0 \tag {2.11}</script><p>&emsp;&emsp;公式$(2.11)$的意义即在拉格朗日视角观察下，每个流体粒子的物理量保持不变。</p><h3 id="4、不可压缩性"><a href="#4、不可压缩性" class="headerlink" title="4、不可压缩性"></a>4、不可压缩性</h3><p>&emsp;&emsp;关于流体的压缩性在此不做过多的物理细节描述，只需知道一点：通常情况下流体的体积变化非常小（除开一些极端的情况，而且这些极端情况我们日常生活中较少出现）。可压缩流体的模拟涉及到非常复杂的情况，往往需要昂贵的计算资源开销，为此在计算机流体模拟中我们通常把所有的流体当作是不可压缩的，即它们的体积不会发生变化。</p><p>&emsp;&emsp;任取流体的一部分，设其体积为$\Omega$而其边界闭合曲面为$\partial\Omega$，我们可以通过围绕边界曲面$\partial\Omega$对流体速度$\vec  u$在曲面法线方向上的分量进行积分来衡量这块部分流体的体积变化速率：</p><script type="math/tex; mode=display">\frac d{dt}Volume(\Omega)=\int\int_{\partial\Omega}\vec u\cdot n \tag{2.12}</script><p>&emsp;&emsp;对于不可压缩的流体，其体积保持为某个常量，故其体积变化速率为$0$：</p><script type="math/tex; mode=display">\int\int_{\partial\Omega}\vec u\cdot n=0 \tag {2.13}</script><p>&emsp;&emsp;由高斯散度定理，我们可以把式$(2.13)$转换为体积分：</p><script type="math/tex; mode=display">\int\int_{\partial\Omega}\vec u\cdot n=\int\int\int_\Omega∇\cdot \vec u=0 \tag{2.14}</script><p>&emsp;&emsp;式$(13)$应该对任意的$\Omega$成立，意即无论$\Omega$取何值，积分值均为$0$。这种情况下只有令积分函数值取$0$方可成立，即对$0$积分无论$\Omega$取何值结果均为$0$。所以有：</p><script type="math/tex; mode=display">∇\cdot \vec u=0 \tag{2.15}</script><p>&emsp;&emsp;这就是$Navier-Stokes$方程中的不可压缩条件$(2.2)$。满足不可压缩条件的速度场被称为是<strong>无散度</strong>的，即在该速度场下流体体积既不膨胀也不坍缩，而是保持在一个常量。模拟不可压缩流体的关键部分就是使得流体的速度场保持无散度的状态，这也是流体内部压力的来源。</p><p>&emsp;&emsp;为了把压力与速度场的散度联系起来，我们在动量方程$(2.1)$两边同时取散度：</p><script type="math/tex; mode=display">∇\cdot\frac{\partial \vec u}{\partial t}+∇\cdot(\vec u\cdot ∇\vec u)+∇\cdot\frac1\rho∇p=∇\cdot(\vec g+\nu∇\cdot∇\vec u) \tag {2.16}</script><p>&emsp;&emsp;对于上式$(2.16)$第一项，我们转变一下求导次序：</p><script type="math/tex; mode=display">\frac {\partial}{\partial t}∇\cdot\vec u \tag {2.17}</script><p>&emsp;&emsp;如果满足流体不可压缩条件，那么式$(2.17)$取值$0$（因为无散度），然后我们调整一下式$(2.16)$可得关于压力的方程：</p><script type="math/tex; mode=display">∇\cdot\frac1\rho∇p=∇\cdot(-\vec u\cdot ∇\vec u+\vec g+\nu∇\cdot∇\vec u) \tag{2.18}</script><h3 id="5、丢弃粘度项"><a href="#5、丢弃粘度项" class="headerlink" title="5、丢弃粘度项"></a>5、丢弃粘度项</h3><p>&emsp;&emsp;在某些流体如蜂蜜、小水珠等的模拟中，粘滞力起着非常重要的作用。但是在大多数流体动画模拟中，粘滞力的影响微乎其微，为此秉持着方程组越简单越好的原则，我们常常丢弃粘度项。当然这也不可避免地带来一些误差，事实上，在计算流体力学中尽可能地减少丢弃粘度项带来的误差是一个非常大的挑战。下面的叙述都是基于丢弃粘度项的前提。</p><p>&emsp;&emsp;丢弃了粘度项的$Navier-Stokes$方程被称为<strong>欧拉方程</strong>，而这种理想的流体则是<strong>无粘度</strong>的。丢弃了粘度项的欧拉方程如下：</p><script type="math/tex; mode=display">\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g \tag {2.19}</script><script type="math/tex; mode=display">∇\cdot\vec u=0 \tag{2.20}</script><p>&emsp;&emsp;<strong>大多数的流体模拟的计算方程都是欧拉方程。</strong></p><h3 id="6、边界条件"><a href="#6、边界条件" class="headerlink" title="6、边界条件"></a>6、边界条件</h3><p>&emsp;&emsp;目前为止我们讨论的都是流体内部的情况，然而边界部分也是流体模拟非常关键的部分。在流体模拟中我们仅仅关注两种边界条件：<strong>固体墙</strong>（solid walls）、<strong>自由面</strong>（free surfaces）。</p><p>&emsp;&emsp;<strong>固体墙</strong>顾名思义就是流体与固体接触的边界，用速度来描述很简单：流体既不会流进固体内部也不会从固体内部流出，因此流体在固体墙法线方向上的分量为$0$：</p><script type="math/tex; mode=display">\vec u\cdot n=0 \tag {2.21}</script><p>&emsp;&emsp;当然，上述是固体自身不移动的情况下。通常来说，流体速度在法线方向上的分量与固体的移动速度在法线方向上的分量应该保持一致：</p><script type="math/tex; mode=display">\vec u\cdot n=\vec u_{solid}\cdot n \tag{2.22}</script><p>&emsp;&emsp;上述的两个公式都是仅对流体速度在法线方向上的分量做了限制，对于无粘度的流体，切线方向上的流体速度与固体的移动速度无必然的联系。</p><p>&emsp;&emsp;<strong>自由面</strong>是另外一个非常重要的边界条件，它通常就是与另外一种流体相接壤的边界部分。例如在模拟水花四溅时，水流表面不与固体接触的都是自由面（如与空气这种流体接触）。因空气密度远小于水导致空气对水体的仿真影响非常小，为了简化模拟，我们将空气所占的空间设为某个固定大气压的区域，设为$0$是最方便的方案，此时自由面就是压强$p=0$的水体表面。</p><p>&emsp;&emsp;在小规模的流体仿真中，自由面的表面张力占据着非常重要的地位。在微观分子层面下，表面张力的存在是因为不同的分子相互吸引产生的力。从几何的角度来解释就是，表面张力就是促使流体的表面积尽可能小的一种力。物理学上，两种不同的流体之间实际上存在着与表面平均曲率成正比的压力骤变：</p><script type="math/tex; mode=display">[p]=\lambda k. \tag {2.23}</script><p>&emsp;&emsp;公式$(2.23)$中的$[p]$记为压力之差。$\lambda$是表面张力系数，可以根据模拟的流体类型查找对应的张力系数（例如空气与水在室温下张力系数为$\lambda \approx 0.073N/m$）。而$k$就是平均曲率，单位为$m^{-1}$。又因为我们常常设空气的压力为$0$，因此水与空气交界的自由面的压力为：</p><script type="math/tex; mode=display">p=\lambda k \tag {2.24}</script><p>​        </p><h2 id="三、N-S方程的分步求解"><a href="#三、N-S方程的分步求解" class="headerlink" title="三、N-S方程的分步求解"></a>三、N-S方程的分步求解</h2><p>&emsp;&emsp;有了对以上对$Navier-Stokes$方程的理论支撑，接下来我们就要如何用计算机来对该组偏微分方程进行离散化求解。为了程序的松耦合性以及使计算尽可能地高效、简单，在流体模型领域，我们将流体方程分成几个独立的步骤，然后按顺序先后推进。对于不可压缩的无粘度流体方程（即前面的欧拉方程$(2.19)$和$(2.20)$，我们将其离散化成对流项（advection）如公式$(3.1)$、体积力项（body force）如公式$(3.2)$、压力/不可压缩项如公式$(3.3)$：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=0 \tag {3.1}</script><script type="math/tex; mode=display">\frac{\partial \vec u}{\partial t}=\vec g \tag {3.2}</script><script type="math/tex; mode=display">\begin{cases}\frac{\partial \vec u}{\partial t}+\frac{1}{\rho}∇p=0\\∇\cdot\vec u=0\end{cases} \tag {3.3}</script><p>&emsp;&emsp;需要注意的是，在对流项公式$(3.1)$中我们用了一个通用量的符号$q$是因为我们不仅仅要对流体的速度进行对流，还需要对其他物理量进行对流。我们记对流项公式$(3.1)$的对流计算算法为$advect(\vec u, \Delta t, q)$，即对于给定的时间步长$\Delta t$和速度场$\vec u$，对物理量q进行对流。</p><p>&emsp;&emsp;对于体积力项$(3.2)$，我们采用简单的前向欧拉法即可：$\vec u \leftarrow \vec u + g\Delta t$。</p><p>&emsp;&emsp;对于压力/不可压缩项$(3.3)$，我们用一个称为$project(\Delta t, \vec u)$的算法，通过$project(\Delta t, \vec u)$计算出正确的压力以确保速度场$\vec u$的无散度性质。欧拉方案不会着重研究具体粒子间的作用力，因而不会正向去求解$\frac{1}{\rho}∇p$，它是利用流体不可压缩的特性，将速度场$\vec u$投影到散度为$0$的空间上，间接地解算了压力项。这种思想相当于，已知一个中间量$\vec u_{temp}$，对这个中间量的唯一一个操作（如正向求解压力$\frac{1}{\rho}∇p$）不可行，但是直到最终量$\vec u_{fianl}$符号的一个性质（散度为$0$），于是只要将$\vec u_{temp}$投影到符合散度为$0$的特性平面上，即可间接地还原正向求解压力的操作，得到最终的速度场$\vec u_{temp}$。</p><p>&emsp;&emsp;对流项$advect(\vec u, \Delta t, q)$的输入速度场$\vec u$要确保为无散度的状态，投影项$project(\Delta t, \vec u)$确保了流体体积保持不变，因而投影项输出的速度场必然是无散度的。所以我们只要确保投影项$project(\Delta t, \vec u)$输出的速度场$\vec u$作为对流项$advect(\vec u, \Delta t, q)$的输入即可，这时我们的分步求解流体方程的优势就体现出来了，其伪代码如下所示。</p><hr><p><strong>算法1 Fluid Simulation($\vec u_n$, $\Delta t$):</strong></p><hr><p><strong>1:  初始化速度场$\vec u_n$,使得$\vec u_n$无散度 </strong></p><p><strong>2:  对于每个时间步$n = 0,1,2,…$</strong></p><p><strong>3: &emsp;&emsp;决定一个合理的时间步长$\Delta t = t_{n+1}-t_n$ </strong></p><p><strong>4: &emsp;&emsp;对流项计算$\vec u_A=advect(\vec u_n,\Delta t,\vec q)$ </strong></p><p><strong>5: &emsp;&emsp;体积力项计算$\vec u_B=\vec u_A+\Delta t\vec g$</strong></p><p><strong>6:  &emsp;&emsp;无散度投影$\vec u_{n+1}=project(\Delta t,\vec u_B)$ </strong></p><hr><h3 id="1、时间步长"><a href="#1、时间步长" class="headerlink" title="1、时间步长"></a>1、时间步长</h3><p>&emsp;&emsp;在流体模拟算法中，确定适当的时间步长是算法的第一步。因为计算流体模拟的最后结果是呈现在屏幕上的，所以$\Delta t$的选取与屏幕的刷新率有重要的关系。若选取的$\Delta t$有$t_n+\Delta t &gt; t_{frame}$，那么必须做一个截断使$\Delta t=t_{frame}-t_n$。此外，流体模拟的三个步骤即对流项、体积力项、无散度投影项对时间步长$\Delta t$的要求不尽相同，要选择一个满足所有要求的最小时间步长能确保计算的收敛性。此外，一方面为了流体模拟的真实性，我们可能需要选取一个足够小的时间步长来复现流体的高质量细节。另一方面，有时高性能的需求又使得我们不能选取太小的时间步长去渲染一帧。假设一帧至少要进行三个时间步的模拟，那么$\Delta t$应该至少设成帧间隔时间的三分之一。</p><h3 id="2、网格结构"><a href="#2、网格结构" class="headerlink" title="2、网格结构"></a>2、网格结构</h3><p>&emsp;&emsp;欧拉法的整个流程都是基于网格的，所以合理的网格结构是算法高效的关键点。$Harlow$和$Welch$提出了一种经典的$MAC$（marker and cell）网格结构，许多不可压缩流体模拟的算法都在这个网格结构上呈现出了良好的效率。$MAC$网格是一种交叉排列的网格，不同类型的物理量被存储于网格的不同位置。以二维的网格为例，如图3-1左图所示，流体粒子的压力数据存储于网格的中心点$P_{i,j}$，而速度则沿着笛卡尔坐标被分成了两部分。水平方向的$u$成分被存储在了网格单元竖直边的中心处，例如网格单元$(i,j)$和$(i+1,j)$之间的水平速度记为$u_{i+1/2,j}$。垂直方向的$v$成分则被存储在了网格单元水平面的中心上。这样的存储方案十分有利于估算流体流进/流出某个网格单元的量。</p><p><figure class="half">    <img src="assets/1555851524585.png">    <img src="assets/1555851793961.png"></figure></p><center>图3-1 MAC网格,左图二维,右图三维</center><p>&emsp;&emsp;扩展到三维的情况，$MAC$网格同样是交错排列的结构网格，如图3-1右图所示。压力数值存储在立方体网格单元的中心，三个速度分量分别被记录在立方体网格单元的三个表面的中心点上。在数值计算时，这样的分配方式使得我们可以准确地采用中心差分法计算压力梯度和速度的散度，同时克服了中心差分法的一个普遍的缺点。一维的情况为例，在网格顶点位置$…,q_{i-1},q_i,q_{i+1}…$上估算量场$q$的导数，为了无偏（所谓无偏，就是不偏向左边或者右边）估计网格顶点$i$处的$\frac{\partial q}{\partial x}$，一种比较自然的方式就是采用一阶中心差分法：</p><script type="math/tex; mode=display">(\frac{\partial q}{\partial x})_i\approx \frac{q_{i+1}-q_{i-1}}{2\Delta x} \tag {3.4}</script><p>&emsp;&emsp;公式$(3.4)$是无偏的，且精确度为$O(\Delta x^2)$。而前向欧拉差分法偏向右边且精确度只有$O(\Delta x)$：</p><script type="math/tex; mode=display">(\frac{\partial q}{\partial x})_i\approx \frac{q_{i+1}-q_i}{\Delta x} \tag {3.5}</script><p>&emsp;&emsp;然而，公式$(3.4)$存在着一个非常严重的问题：网格点$i$的估算导数完全忽略了$q_i$的值。数学上，只有常数函数的一阶导数为零。但是公式$(3.4)$遇到了锯齿函数如$q_i=(-1)^i$时，它错误地将该类函数的导数估算为$0$，这种问题被称为零空间问题（null-space problem）。</p><p>&emsp;&emsp;交叉错排的$MAC$网格完美地克服了中心差分法的零空间问题，同时也保持了它的无偏二阶精度。在$MAC$网格上运用中心差分法，网格点$i$处的估算导数公式如下所示：</p><script type="math/tex; mode=display">(\frac{\partial q}{\partial x})_i\approx\frac{q_{i+1/2}-q_{i-1/2}}{\Delta x} \tag {3.6}</script><p>&emsp;&emsp;$MAC$网格确实给流体的压力计算和不可压缩性的处理带来了很大的便利，但与此同时也带来了一些其他方面的麻烦。如果我们要估算某个地方的速度向量，即便采样点恰好在网格点上我们也要做一些插值才能获取相应的速度向量。在网格点处，我们通常采用平均法，以二维为例：</p><script type="math/tex; mode=display">\vec u_{i,j}=(\frac{u_{i-1/2,j}+u_{i+1/2,j}}{2},\frac{v_{i,j-1/2}+v_{i,j+1/2}}{2}),\\\vec u_{i+1/2,j}=(u_{i+1/2,j},\frac{v_{i,j-1/2}+v_{i,j+1/2}+v_{i+1,j-1/2}+v_{i+1,j+1/2}}{4}),\\\vec u_{i,j+1/2}=(\frac{u_{i-1/2,j}+u_{i+1/2,j}+u_{i-1/2,j+1}+u_{i+1/2,j+1}}{4},v_{i,j+1/2}).\tag {3.7}</script><p>&emsp;&emsp;最后，在实现中下标索引一般没有浮点数之说，前面直接采用$i+1/2$的记法是为了便于叙述。一般约定如下：</p><script type="math/tex; mode=display">p(i,j,k)=p_{i,j,k},\\u(i,j,k)=u_{i-1/2,j,k},\\v(i,j,k)=v_{i,j-1/2,k},\\w(i,j,k)=w_{i,j,k-1/2}. \tag{3.8}</script><p>&emsp;&emsp;因而对于$nx\times ny\times nz$分辨率的网格，压力数值存储在$nx\times ny\times nz$的数组中，速度的$u$成分存储在$(nx+1)\times ny\times nz$数组中，速度的$v$成分存储在$nx\times (ny+1)\times nz$数组中，速度的$w$成分存储在$nx\times ny\times (nz+1)$数组中。</p><h2 id="四、对流算法"><a href="#四、对流算法" class="headerlink" title="四、对流算法"></a>四、对流算法</h2><p>&emsp;&emsp;求解如下所示的对流方程是流体模拟的关键一步：</p><script type="math/tex; mode=display">\frac{Dq}{Dt}=0 \tag {4.1}</script><p>&emsp;&emsp;我们把这个对流数值计算的算法记为：</p><script type="math/tex; mode=display">q^{n+1}=advect(\vec u,\Delta t,q^n) \tag {4.2}</script><p>&emsp;&emsp;公式$(4.2)$中的各个符号含义：</p><p>&emsp;&emsp;$\vec u$：在$MAC$网格上的离散化的速度场；</p><p>&emsp;&emsp;$\Delta t$：时间步长；</p><p>&emsp;&emsp;$q^n$：当前的物理量场$q$（如流体密度、速度、燃烧物浓度等）；</p><p>&emsp;&emsp;$q^{n+1}$：经过对流后得到的新的量场。</p><p>&emsp;&emsp;在这里要特别注意，输入对流算法的速度场$\vec u$必须是无散度的，否则模拟结果会出现一些奇怪的失真现象。</p><h3 id="1、半拉格朗日对流算法（Semi-Lagrangian-Advection）"><a href="#1、半拉格朗日对流算法（Semi-Lagrangian-Advection）" class="headerlink" title="1、半拉格朗日对流算法（Semi-Lagrangian Advection）"></a>1、半拉格朗日对流算法（Semi-Lagrangian Advection）</h3><p>&emsp;&emsp;一维情况下，对流方程$(4.1)$写成偏微分的形式如下：</p><script type="math/tex; mode=display">\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=0 \tag {4.3}</script><p>&emsp;&emsp;分别采用前向欧拉差分法计算对时间的偏导和中心差分法计算对空间的偏导，我们有：</p><script type="math/tex; mode=display">\frac{q^{n+1}_{i}-q^n_i}{\Delta t}+u^n_i\frac{q^n_{i+1}-q^n_{i-1}}{2\Delta x}=0 \tag {4.4}</script><p>&emsp;&emsp;转成以$q^{n+1}_i$为计算目标的显式公式，得：</p><script type="math/tex; mode=display">q^{n+1}_i=q^n_i-\Delta t u^n_i\frac{q^n_{i+1}-q^n_{i-1}}{2\Delta x} \tag {4.5}</script><p>&emsp;&emsp;公式$(4.5)$看起来没什么问题，但是却存在非常严重的漏洞。首先，前向欧拉法被证明是无条件不稳定的空间离散方法：无论取多么小Δ𝑡，随着时间步的推进，累积误差终将发散。即使使用更稳定的时间积分方法来取代前向欧拉方法，解决了时间上的PDE（Partial Differential Equation，偏微分方程）计算，空间上的PDE计算还是会带来重大的麻烦。标准中心差分方法不可避免地会出现的零空间问题，具有高频震荡性质的速度场对空间的导数被错误地计算为$0$或几乎为$0$，低离速度分量被分离出来，从而导致模拟效果中出现许多奇怪的高频摆动和震荡。</p><p>&emsp;&emsp;针对这些问题，研究者们提出了一个解然不同的、更加简单和更具物理直观意义的半拉格朗日法。之所以叫半拉格朗日法，是因为这种方法是以拉格朗日视角去解决欧拉视角的对流方程（“半”字的由来）。假设我们的目标是求解网格点$\vec x_G$的在第$n+1$个时间步时关于物理量$q$的新值，记为$q^{n+1}_G$。在拉格朗日的视角下，我们可以寻找在第$n+1$时间步之前，是空间中的哪一个点上的流体粒子在速度场$\vec u$的作用下“流向”了$\vec x_G$，我们记这个粒子在第$n$个时间步时的网格位置为$\vec x_P$，则第$n+1$个时间步时$\vec x_G$的$q^{n+1}_G$即为第$n$个时间步时$\vec x_P$的$q^{n}_P$。如下图4-1为半拉格朗日对流法的示意图。</p><p><img src="assets/1555901521756.png" alt="1555901521756"></p><center>图4-1 半拉格朗日对流法</center><p>&emsp;&emsp;半拉格朗日对流法的第一步就是要找出$\vec x_P$，为此我们根据$\vec x_G$做反向的追踪。粒子位置对时间的导数就是速度场：</p><script type="math/tex; mode=display">\frac{d\vec x}{dt}=\vec u(\vec x) \tag {4.6}</script><p>&emsp;&emsp;经过一个时间步长$\Delta t$之后，粒子由$\vec x_P$移动到$\vec x_G$。为了得到$\vec x_P$，最简单的方法就是采用前向欧拉法进行倒推：</p><script type="math/tex; mode=display">\vec x_P=\vec x_G-\Delta t\vec u(\vec x_G) \tag {4.7}</script><p>&emsp;&emsp;然而前向欧拉法只有一阶的精度，若在不改变$\Delta t$的情况下提高精度，我们可以采用高阶的龙格库塔法（Runge-Kutta method）。采用二阶的龙格库塔法如下所示：</p><script type="math/tex; mode=display">\vec x_{mid}=\vec x_G-\frac12\Delta t\vec u(\vec x_G),\\\vec x_P=\vec x_G-\Delta t\vec u(\vec x_{mid}). \tag {4.7}</script><p>&emsp;&emsp;倒推得到$\Delta  t$之前的网格位置$\vec x_P$一般不会恰好在网格顶点上，为此我们需要做些插值。三维模拟通常采用三线性插值，而二维的则采用双线性插值。</p><script type="math/tex; mode=display">q^{n+1}_G=interpolate(q_n,\vec x_P) \tag {4.8}</script><h3 id="2、边界情况"><a href="#2、边界情况" class="headerlink" title="2、边界情况"></a>2、边界情况</h3><p>&emsp;&emsp;若我们倒推得到的$\vec x_P$仍然在流体的内部，那么做插值是完全没问题的。但若$\vec x_P$在流体的边界之外呢？这种情况的出现的原因通常有两个：一个是$\vec x_P$确确实实在流体的外部且即将流入流体内部，另一个是由前向欧拉法或龙格库塔法的数值计算方法带来的误差导致。</p><p>&emsp;&emsp;在一种情况下，我们应该知道当流体流入时其携带的物理量，此时我们将这个外部流入的物理量作为返回值即可。例如，第$n$个时间步时的外部流体以速度$\vec U$和温度$T$在第$n+1$个时间步时注入流体内部$\vec x_G$的位置，那么$\vec T^{n+1}_G$的值就为$T$。</p><p>&emsp;&emsp;在第二种由误差导致的情况下，一个适当的策略就是根据边界上的最近点外推出所求得物理量。在模拟某些流体时，外推变得很简单。例如，在模拟烟雾时我们简单地假设烟雾流体外部即空气的速度风场为某个常数$\vec U$（可能为$0$），这样边界上的速度场都取$\vec U$。但还有一些必须根据流体内部的已知量外推出未知量，这时情况就变得比较复杂了。具体如何外推将在后面介绍，目前我们只需要知道大概的步骤：首先寻找边界上的最近点，然后在最近点的领域内插值获取相应的物理量场。</p><h3 id="3、时间步长大小"><a href="#3、时间步长大小" class="headerlink" title="3、时间步长大小"></a>3、时间步长大小</h3><p>&emsp;&emsp;对任何一种数值计算方法的主要的考虑点就是它是否稳定。幸运的是，<strong>半拉格朗日对流法已经被证明是一种无条件稳定的算法</strong>：无论$\Delta t$取多大，它永远不会出现数值爆炸的现象。因为每一个新值$q$的确定，都是通过对旧值得插值，无论是线性插值、双线性插值还是三线性插值，$q$的大小都是处于插值点之间，不会得到比原来插值点更大或者更小的值，因而$q$是有上下界的。这使得我们可以尽情地根据所需的模拟质量和模拟效率去调整时间步长。</p><p>&emsp;&emsp;但是在实践中，时间步长的大小也不能选得太过极端，否则会产生一些奇观的现象。Foster和Fekiw提出了一个对$\Delta t$的限制：流体粒子在$\Delta t$内的倒推轨迹最多经过某个常数个网格单元为宜，例如5个：</p><script type="math/tex; mode=display">\Delta t \leq \frac{5\Delta x}{u_{max}} \tag {4.9}</script><p>&emsp;&emsp;公式$(4.9)$中，$u_{max}$是速度场的最大值，我们可以简单地取 存储在网格中的最大速度值。一个更鲁棒的方法考虑了体积力（如重力、浮力等）对最大速度的影响：</p><script type="math/tex; mode=display">u_{max}=max(|u^n|)+\Delta t|g| \tag {4.10}</script><p>&emsp;&emsp;将不等式$(4.9)$的最大值带入公式$(4.10)$，我们有：</p><script type="math/tex; mode=display">u_{max}=max(|u^n|)+\frac{5\Delta x}{u_{max}}|g| \tag {4.11}</script><p>&emsp;&emsp;取一个简单的速度上界（简化了公式$(4.11)$），$u_{max}$：</p><script type="math/tex; mode=display">u_{max}=max(|u^n|)+\sqrt{5\Delta xg} \tag {4.12}</script><p>&emsp;&emsp;这样确保了$u_{max}$始终为正，且避免公式$(4.9)$的除$0$错误。</p><p>&emsp;&emsp;关于时间步长的讨论离不开$CFL$（以Courant、Friedrichs、Lewy三人的名字命名）条件。$CFL$条件是一个简单而直观的判断计算是否收敛的必要条件。它的直观物理解释就是时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。满足$CFL$条件意味着当$\Delta x$和$\Delta t$趋于取极限$0$时，数值计算所求的解就会收敛到原微分方程的解。</p><p>&emsp;&emsp;对于半拉格朗日对流法，其满足$CFL$条件当且仅当在极限情况下，追踪得到的粒子轨迹足够逼近真实的轨迹。足够逼近的意思是经过正确的网格插值能够得到正确的依赖域（即差分格式的依赖域包含了原微分方程的依赖域），追踪的轨迹就会收敛到正确真实的轨迹。</p><p>&emsp;&emsp;因而，对于采用标准的显式有限差分法的对流方程求解，为了保证收敛，我们要求$q^{n+1}$的新值是由以当前网格点为中心、以$C\Delta x$（$C$是一个小的整数常量）为半径的邻域范围内插值得到：</p><script type="math/tex; mode=display">\Delta t \leq C\frac{\Delta x}{|\vec u|} \tag {4.13}</script><p>&emsp;&emsp;公式$(4.13)$中的$C$被称为$CFL$数，因而不等式$(4.9)$可以看成是公式$(4.13)$取$CFL$数为$5$得到。</p><h3 id="4、数值耗散"><a href="#4、数值耗散" class="headerlink" title="4、数值耗散"></a>4、数值耗散</h3><p>&emsp;&emsp;对流算法在对流获取新的物理量场$q^{n+1}_i$时会进行一些插值操作，插值不可避免地会平滑物理量场，这带来了一些数值耗散。一次两次的数值耗散不会由太大的影响，但是在流体模拟中我们会在每个时间步都进行对流运算，反反复复的平滑操作将数值耗散不断扩大，损失大量的流体细节。</p><p>&emsp;&emsp;以一维的对流项计算为例，流体速度为常量$u&gt;0$：</p><script type="math/tex; mode=display">\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=0 \tag {4.14}</script><p>&emsp;&emsp;假设$\Delta t &lt; \frac{\Delta x}{u}$，即单个时间步长内粒子追踪轨迹长度小于单个网格单元的大小。我们的目标点是$x_i$，则倒推得到的粒子位置就落在了$[x_{i-1},x_i]$上的$x_i-\Delta tu$，然后进行线性插值得到$q^{n+1}_i$：</p><script type="math/tex; mode=display">q^{n+1}=\frac{\Delta tu}{\Delta x}q^n_{i-1}+(1-\frac{\Delta tu}{\Delta x})q^n_i \tag {4.15}</script><p>&emsp;&emsp;将公式$(4.15)$整理一下，有：</p><script type="math/tex; mode=display">q^{n+1}_i=q^n_i-\Delta tu\frac{q^n_i-q^n_{i-1}}{\Delta x} \tag {4.16}</script><p>&emsp;&emsp;公式$(4.16)$实际上正好就是采用时间上的前向欧拉差分法和空间上的单向有限差分法的欧拉方案，把$q^n_i$看成是$q^n$关于$x_i$的函数，对$q^n_{i-1}$进行泰勒级数展开：</p><script type="math/tex; mode=display">q^n_{i-1}=q^n_i-(\frac{\partial q}{\partial x})^n_i\Delta x+(\frac{\partial^2q}{\partial x^2})^n_i\frac{\Delta x^2}{2}+O(\Delta x^3) \tag {4.17}</script><p>&emsp;&emsp;将公式$(4.17)$代入公式$(4.16)$，并做一些变量消去，可得：</p><script type="math/tex; mode=display">q^{n+1}_i=q^n_i-\Delta tu(\frac{\partial q}{\partial x})^n_i+\Delta tu\Delta x(\frac{\partial^2q}{\partial x^2})^n_i+O(\Delta x^2) \tag {4.18}</script><p>&emsp;&emsp;在二阶截断误差的情况下，结合公式$(4.18)$和公式$(4.14)$，有：</p><script type="math/tex; mode=display">\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=u\Delta x(\frac{\partial^2q}{\partial x^2}) \tag {4.19}</script><p>&emsp;&emsp;右边就是对流方程计算时引入的额外类似粘度乘上系数$u\Delta x$的项。<strong>这也就是说，当我们采用简单的半拉格朗日法去求解无粘度的对流方程时，模拟的结果却看起来我们像时在模拟有粘度的流体。这就是数值耗散！</strong>当然，当$\Delta x\to 0$时，这个数值耗散系数也会趋于$0$，所以取时间步无穷小时能够得到正确的模拟结果，但这需要耗费巨额的计算资源开销。我们通常模拟的流体大多数都是无粘度的，所以如何减少这个数值耗散是个至关重要的难题。</p><p>&emsp;&emsp;一个简单有效的修复数值耗散的方法就是采用更加锐利的插值方法，从而尽可能地减少由插值带来的数值耗散。在一维的情况时，我们采用三次插值（cubic interpolant）如下公式$(4.21)$，而不是简单的一次线性插值$(4.20)$：</p><script type="math/tex; mode=display">q\approx(1-s)x_i+sx_{i+1} \tag {4.20}</script><script type="math/tex; mode=display">q\approx[-\frac13s+\frac12s^2-\frac16s^3]q_{i-1}+[1-s^2+\frac12(s^3-s)]q_i\\+[s+\frac12(s^2-s^3)]q_{i+1}+[\frac16(s^3-s)]q_{i+2} \tag {4.21}</script><p>&emsp;&emsp;扩展到二维或者三维就是双三次插值（bicubic interpolation）或三三次插值（tricubic interpolation）。以二维情况为例，我们可以先沿着$x$轴做第一遍的三次插值如公式$(4.22)$，然后再沿着$y$轴做第二遍插值如公式$(4.23)$：</p><script type="math/tex; mode=display">q_{j-1}=w_{-1}(s)q_{i-1,j-1}+w_0(s)+q_{i,j-1}+w_1(s)q_{i+1,j-1}+w_2(s)q_{i+2,j-1},\\q_{j}=w_{-1}(s)q_{i-1,j}+w_0(s)+q_{i,j}+w_1(s)q_{i+1,j}+w_2(s)q_{i+2,j},\\q_{j+1}=w_{-1}(s)q_{i-1,j+1}+w_0(s)+q_{i,j+1}+w_1(s)q_{i+1,j+1}+w_2(s)q_{i+2,j+1},\\q_{j+2}=w_{-1}(s)q_{i-1,j+2}+w_0(s)+q_{i,j+2}+w_1(s)q_{i+1,j+2}+w_2(s)q_{i+2,j+2}. \tag {4.22}</script><script type="math/tex; mode=display">q=w_{-1}(t)q_{j-1}+w_0(t)q_j+w_1(t)q_{j+1}+w_2(t)q_{j+2} \tag {4.23}</script><p>&emsp;&emsp;当然也可以先沿着$y$轴，然后再沿着$x$轴做插值操作。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Fluid Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Naiver-Stokes Equations </tag>
            
            <tag> Fluid Simulation </tag>
            
            <tag> Advection </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
