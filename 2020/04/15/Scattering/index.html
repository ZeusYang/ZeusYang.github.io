<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Physically Based Rendering：散射模型 | YangWC&#39;s Blog</title>
  
  
  <meta name="description" content="Personal blog website.">
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/logo.ico">
  

  
    <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fdf716664defeee80e01568ddbeb2425";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
  
</head>
<body>
  
  
  <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          YangWC's Blog
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
									<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/" id="home">
									<i class="fas fa-grin fa-fw"></i>&nbsp;博客
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
									<i class="fas fa-tag fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-grin fa-fw"></i>&nbsp;博客
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
								<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
								<i class="fas fa-tag fa-fw"></i>&nbsp;标签
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      <div class="l_main">
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2020/04/15/Scattering/">
        Physically Based Rendering：散射模型
      </a>
    </h1>
  


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="https://yangwc.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2020-04-15</p>
  </a>
</div>

          
        
          
            
  
  <div class="new-meta-item category">
    <a href="/categories/Ray-Tracer/" rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Computer Graphics&nbsp;/&nbsp;Ray Tracer</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p>光线散射模型描述了光线碰撞到物体表面时以什么方式、什么方向进行反射、折射，在这里暂时不考虑次表面散射现象。光线的反射用BRDF函数描述，而透射则用BTDF函数描述，两者统一起来称为BSDF函数（双线散射分布函数）。</p>
<a id="more"></a>
<p>&emsp;&emsp;以下的内容大部分整理自pbrt第三版的第八章——REFLECTION MODELS。</p>
<h2 id="一、相关术语"><a href="#一、相关术语" class="headerlink" title="一、相关术语"></a>一、相关术语</h2><p>&emsp;&emsp;物体的表面反射模型主要来源以下几个：</p>
<ul>
<li>测量数据模型：通过真实世界的实验测量得到，以数据库的形式使用；</li>
<li>现象学模型：用经验公式来拟合现实世界物体表面的定性特性；</li>
<li>模拟：有时候表面组成的底层信息可以获取到，例如我们知道颜料由带颜色的附着于某些介质的粒子组成，每种粒子的反射特性我们可以知道。这种情况下我们可以模拟微观层面的光散射来模拟产生反射数据。这个过程既可以在渲染过程完成也可以作为预处理；</li>
<li><strong>波动光学模型</strong>：将光当作波来看待，求解麦克斯韦方程；</li>
<li><strong>几何光学模型</strong>：如果知道了表面的底层散射和几何属性，反射模型可以直接从描述中构造出来。几何光学使得光和表面的交互可追踪，许多情况下都是非常好的选择。</li>
</ul>
<p>&emsp;&emsp;目前大部分渲染算法都是基于几何光学，波动光学的复杂度相当高，其结果也未必优于几何光学。目前表面反射可以分成下图所示的四大类，从(a)到(d)分别是<strong>漫反射（diffuse）</strong>、<strong>粗糙镜面反射（glossy specular）</strong>、<strong>完美镜面反射（perfect specular）</strong>以及<strong>回归反射（retro-reflective）</strong>。大部分真实物体是这些反射类型的组合。这几种反射的区别主要在于它们的反射波瓣分布（下图中的网格描述的范围）。漫反射在半球方向上均匀地反射，这是一种理想的漫反射模型；粗糙镜面反射的反射波瓣在完美镜面反射基础上扩大了一些，用于描述金属等没那么光滑表面的反射；完美镜面反射即在非常光滑的表面上发生的反射；回归反射用于描述天鹅绒、月球等向入射方向反射的行为。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.35/blog/Scattering/1.png" width="60%"></div></p>
<p>&emsp;&emsp;给定一类特定的反射，反射的分布函数还可以分成<strong>各向同性</strong>（isotropic）和<strong>各向异性</strong>（anisotropic）。大部分物体的表面反射都是各项同性的，这里所谓的各向同性就是指：对于物体表面上的一点和该点对应的法线，将表面绕着该法线进行旋转，光线反射的分布情况不变（即反射波瓣保持不变）。而如果反射波瓣发生了改变，则该物体表面就是反射各向异性的，织物、光盘和拉丝金属等都属于各向异性材质。</p>
<p>&emsp;&emsp;由于通常是具体到物体表面上的一个点对散射现象进行描述，因此我们的BRDF和BTDF的计算基本上都是在物体表面上的局部坐标系下进行，这个局部坐标系我们称之为着色坐标系。该坐标系如下图所示，以切线、副切线和法线向量分别作为$x$、$y$和$z$轴。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.35/blog/Scattering/2.png" width="40%"></div></p>
<p>&emsp;&emsp;除了笛卡尔坐标系，有时还会用到球面坐标系。一个方向向量可以用球面坐标系$(\theta,\phi)$表示，如下图所示。笛卡尔坐标和球面坐标的相互转换比较简单，这里就不赘述了。在BRDF和BTDF函数中，用$\omega_i$表示入射方向向量，而$\omega_o$表示出射方向向量，默认均已经归一化为单位向量。而且$\omega_i$和$\omega_o$默认从着色点朝向入射、出射的方向。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.35/blog/Scattering/3.png" width="40%"></div></p>
<h2 id="二、散射函数接口"><a href="#二、散射函数接口" class="headerlink" title="二、散射函数接口"></a>二、散射函数接口</h2><p>&emsp;&emsp;首先定义一个接口类<code>BxDF</code>用于作为BRDF和BTDF的接口类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BxDF</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// BxDF Interface</span></span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BxDF Public Data</span></span><br><span class="line">    <span class="keyword">const</span> BxDFType type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该接口类中的<code>type</code>用于子类指明当前是反射还是透射，同时又属于哪类反射模型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BxDFType &#123;</span><br><span class="line">    BSDF_REFLECTION = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    BSDF_TRANSMISSION = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    BSDF_DIFFUSE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    BSDF_GLOSSY = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    BSDF_SPECULAR = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    BSDF_ALL = BSDF_DIFFUSE | BSDF_GLOSSY | BSDF_SPECULAR | BSDF_REFLECTION |</span><br><span class="line">               BSDF_TRANSMISSION,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面的<code>f</code>函数是BSDF的核心，它要求输入入射方向和反射方向（默认着色点是着色坐标系下的原点），返回相应的BSDF函数值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Spectrum <span class="title">f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但有时我们想仅仅输入出射方向，然后根据出射方向计算入射方向并返回相应的BSDF函数值。这在完美镜面反射和粗糙镜面反射中非常有用，因为此时它们的反射波瓣很窄，只占整个半球方向很小一部分，我们不想盲目暴力地遍历所有的入射方向，而是直接根据向量的反射特性获取入射方向（对于完美镜面反射，除了此方向其他方向上的贡献均为$0$，这时的BRDF是一个狄拉克函数），省去了很大部分的计算。为此，亦声明了如下的接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Spectrum <span class="title">Sample_f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, Vector3f *wi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> Point2f &amp;sample, Float *pdf,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BxDFType *sampledType = <span class="literal">nullptr</span>)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;函数的其他参数我们暂时先忽略。用球面坐标系$(\theta,\phi)$表示方向向量，BSDF函数本质上是关于入射方向和散射方向的4D函数，在某些特殊情况下，我们可以将其中的入射的两个维度砍掉。一种特殊情况就是<strong>半球-方向反射率（hemispherical-directional reflectance）</strong>，此时它假定半球方向的入射光强度为一个常量，即入射辐射率是一个常量函数，因此可以将反射方程中的入射辐射率$L_i$提取到半球积分外面，剩下的部分就是半球-方向反射率（即下面的公式$(1)$）。对于给定的出射方向$\omega_o$，可以直接计算入射辐照度在该方向上的反射比率如下：</p>
<script type="math/tex; mode=display">
\rho_{hd}(\omega_o)=\int_{H^2(n)} f_r(p,\omega_o, \omega_i)|cos\theta_i|d\omega_i \tag {1}</script><p>&emsp;&emsp;上述的公式也可以被解读为：来自某个给定方向上的入射光向整个半球方向反射的总反射比率（此时$\omega_o$就变成了入射方向而非反射方向）。之所以能够这样解读，是因为基于物理的BRDF有个隐性的假设，即对称性，关于入射和反射的对称性。但需要注意BTDF并没有此类对称性。我们定义下面的<code>rho</code>函数接口用于计算半球-方向反射率，参数<code>nSamples</code>和<code>samples</code>用于辅助计算公式$(1)$的积分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Spectrum <span class="title">rho</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">int</span> nSamples, <span class="keyword">const</span> Point2f *samples)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除了上面的半球-方向反射率之外，还有一种反射率叫做<strong>半球-半球反射率（hemispherical-hemispherical reflectance）</strong>。它计算的是：半球上所有的入射方向入射进来的辐射率都一样（即是一个常量）的情况下，表面接收到这些全部入射进来的辐照度，再向整个半球出射出去的辐照度比例（即表面出射的总能量/表面接收的总能量）：</p>
<script type="math/tex; mode=display">
\rho_{hh}=\frac{1}{\pi}\int_{H^2(n)} \int_{H^2(n)}f_r(p,\omega_o,\omega_i)|cos\theta_o cos\theta_i| d\omega_o d\omega_i \tag {2}</script><p>&emsp;&emsp;可以理解为在公式$(1)$的基础上，再削减出射方向的维度，因此上述的公式$(2)$没有输入参数。为此，定义下面的接口用以计算公式$(2)$：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Spectrum <span class="title">rho</span><span class="params">(<span class="keyword">int</span> nSamples, <span class="keyword">const</span> Point2f *samples1,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Point2f *samples2)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在此基础上，我们再定义创建<code>ScaledBxDF</code>类，它本质上就是将<code>BxDF</code>函数的返回值再乘上一个光谱值（RGB或者基于采样的光谱向量），这很常见（例如反射方程中的入射辐射率$L_i$和$f_r$的相乘）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScaledBxDF</span> :</span> <span class="keyword">public</span> BxDF &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ScaledBxDF Public Methods</span></span><br><span class="line">    ScaledBxDF(BxDF *bxdf, <span class="keyword">const</span> Spectrum &amp;scale)</span><br><span class="line">        : BxDF(BxDFType(bxdf-&gt;type)), bxdf(bxdf), scale(scale) &#123;&#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">rho</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;w, <span class="keyword">int</span> nSamples,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> Point2f *samples)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scale * bxdf-&gt;rho(w, nSamples, samples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">rho</span><span class="params">(<span class="keyword">int</span> nSamples, <span class="keyword">const</span> Point2f *samples1,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> Point2f *samples2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scale * bxdf-&gt;rho(nSamples, samples1, samples2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Spectrum <span class="title">Sample_f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, Vector3f *wi, <span class="keyword">const</span> Point2f &amp;sample,</span></span></span><br><span class="line"><span class="function"><span class="params">                      Float *pdf, BxDFType *sampledType)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Float <span class="title">Pdf</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    BxDF *bxdf;</span><br><span class="line">    Spectrum scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三、镜面反射和透射"><a href="#三、镜面反射和透射" class="headerlink" title="三、镜面反射和透射"></a>三、镜面反射和透射</h2><p>&emsp;&emsp;我们首先来看完美光滑表面上发生的镜面反射和镜面透射。完美的镜面反射和透射非常特殊，给定一个入射方向$\omega_i$，则该表面散射的方向有且仅有一个$\omega_o$，而非遍布整个半球方向。给定入射方向$\omega_i$，我们可以很容易地求出相应的完美镜面反射方向$\omega_o$，而透射方向的计算则稍微要麻烦一点。Snell定律给出介质透射指数和透射角度的关系，透射指数描述了相对于真空情况下光线在介质中的速度降低了多少，用$\eta$标记：</p>
<script type="math/tex; mode=display">
\eta_i sin\theta_i = \eta_t sin \theta_t \tag {3}</script><p>&emsp;&emsp;实际情况下，折射系数通常与光的波长有关，随着光波的变化而变化。由此，入射光将在两种不同介质之间的边界上向多个方向发生透射，而非仅仅一个方向，这被称为色散现象（dispersion）。例如一束白光透过三棱镜将产生七彩光带，这七彩光带具有一定的范围。但在计算机图形学中，我们通常忽略这个现象，假定折射系数与波长无关，因为此种现象对于人类视觉来说不是很关键。</p>
<p>&emsp;&emsp;除了散射方向的计算，我们还要计算光能的反射比例和折射比例，这通过菲涅尔方程联系起来。</p>
<h3 id="1、菲涅尔反射方程"><a href="#1、菲涅尔反射方程" class="headerlink" title="1、菲涅尔反射方程"></a>1、菲涅尔反射方程</h3><p>&emsp;&emsp;菲涅尔方程（Fresnel equations）描述了一束光照射到表面上时反射的比例。值得一提的是，在完美光滑的表面上，菲涅尔方程就是麦克斯韦方程的解。给定折射系数和入射方向与法线的夹角，菲涅尔方程给出了在物体表面上产生两种不同偏振状态的反射率，两种偏振状态分别是平行偏振光和垂直偏振光。但我们忽略光的偏振现象，假定光是无偏振的，因此菲涅尔反射率应该是两种偏振状态的反射率的平均值。</p>
<p>&emsp;&emsp;根据是否存在能够导电的自由电子，可以将物体的材质分成以下的三大类：</p>
<ul>
<li>绝缘体（dielectric）：此类材质不导电，其介质的折射指数均为实数值，会透射一定量的入射光，此类材质有玻璃、矿物油、水和空气等；    </li>
<li>导电体（conductor）：此类材质能够导电，因其具有自由移动的电子，此类材质不透明（一般透射进入内部的光被转换成了热能，厚度很薄的极端情况不考虑），仅发生反射。其介质的折射指数是复数值$\overline \eta=\eta + ik$；</li>
<li>半导体（semiconductor）：例如硅或锗都属于此类，在这里我们不考虑。</li>
</ul>
<p>&emsp;&emsp;绝缘体和导电体的反射率都有菲涅尔反射方程给出，但考虑到导电体的折射指数为复数的情况，有必要分类情况讨论。在此创建一个<code>Fresnel</code>接口类如下，<code>Evaluate</code>接口输入$cos\theta_i$，返回菲涅尔反射率，反射率是$[0,1]$之间的一个浮点数值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fresnel</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Fresnel Interface</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Fresnel();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Spectrum <span class="title">Evaluate</span><span class="params">(Float cosI)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先来看入射介质与折射介质均为绝缘体的情况，此时折射指数均为实数值。设入射介质的折射指数为$\eta_i$，折射介质的折射指数为$\eta_t$，$\theta_i$和$\theta_t$分别是入射方向$\omega_i$和折射方向$\omega_t$与法线的夹角，则菲涅尔反射率计算如下：</p>
<script type="math/tex; mode=display">
r_{||}=\frac{\eta_t cos\theta_i-\eta_icos\theta_t}{\eta_tcos\theta_i+\eta_icos\theta_t} \tag {4}</script><script type="math/tex; mode=display">
r_{\perp}=\frac{\eta_i cos\theta_i-\eta_tcos\theta_t}{\eta_icos\theta_i+\eta_tcos\theta_t} \tag {5}</script><p>&emsp;&emsp;其中$r_{||}$是平行偏振光的反射率，$r_{\perp}$是垂直偏振光的反射率。对于无偏振光，则菲涅尔反射率是两者的综合平均：</p>
<script type="math/tex; mode=display">
F_r=\frac12(r_{||}^2+r_{\perp}^2) \tag {6}</script><p>&emsp;&emsp;因此，根据能量守恒定律，绝缘体的透射率为$1-F_r$。下图列出了一些常见的绝缘体的折射系数：</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.35/blog/Scattering/4.png" width="60%"></div></p>
<p>&emsp;&emsp;根据以上讨论，可实现<code>FrDielectric</code>函数如下，输入参数分别为$\eta_i$、$\eta_t$和$cos\theta_i$，返回绝缘体的反射率：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Float <span class="title">FrDielectric</span><span class="params">(Float cosThetaI, Float etaI, Float etaT)</span> </span>&#123;</span><br><span class="line">    cosThetaI = Clamp(cosThetaI, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Potentially swap indices of refraction</span></span><br><span class="line">    <span class="keyword">bool</span> entering = cosThetaI &gt; <span class="number">0.f</span>;</span><br><span class="line">    <span class="keyword">if</span> (!entering) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(etaI, etaT);</span><br><span class="line">        cosThetaI = <span class="built_in">std</span>::<span class="built_in">abs</span>(cosThetaI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute _cosThetaT_ using Snell's law</span></span><br><span class="line">    Float sinThetaI = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="built_in">std</span>::max((Float)<span class="number">0</span>, <span class="number">1</span> - cosThetaI * cosThetaI));</span><br><span class="line">    Float sinThetaT = etaI / etaT * sinThetaI;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle total internal reflection</span></span><br><span class="line">    <span class="keyword">if</span> (sinThetaT &gt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Float cosThetaT = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="built_in">std</span>::max((Float)<span class="number">0</span>, <span class="number">1</span> - sinThetaT * sinThetaT));</span><br><span class="line">    Float Rparl = ((etaT * cosThetaI) - (etaI * cosThetaT)) /</span><br><span class="line">                  ((etaT * cosThetaI) + (etaI * cosThetaT));</span><br><span class="line">    Float Rperp = ((etaI * cosThetaI) - (etaT * cosThetaT)) /</span><br><span class="line">                  ((etaI * cosThetaI) + (etaT * cosThetaT));</span><br><span class="line">    <span class="keyword">return</span> (Rparl * Rparl + Rperp * Rperp) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这里略提以下上面的代码，在计算之前我们首先根据$cos\theta_i$的符号判断当前是处于介质内部还是外部，如果是在内部向外部透射，则应该交换一下折射系数。此外，我们还考虑了全反射的情况，根据Snell定律计算出来的$sin\theta_t$是否大于等于$1$来判断，如果大于$1$，则返回$1.0$的反射率（即全部反射了）。由此，绝缘体的<code>Fresnel</code>类实现如下，直接调用<code>FrDielectric</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FresnelDielectric</span> :</span> <span class="keyword">public</span> Fresnel &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// FresnelDielectric Public Methods</span></span><br><span class="line">    <span class="function">Spectrum <span class="title">Evaluate</span><span class="params">(Float cosThetaI)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    FresnelDielectric(Float etaI, Float etaT) : etaI(etaI), etaT(etaT) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Float etaI, etaT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Spectrum FresnelDielectric::Evaluate(Float cosThetaI) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> FrDielectric(cosThetaI, etaI, etaT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;紧接着来考虑导电体的介质反射率。我们仅考虑入射是绝缘体介质，透射是导电体的情况（从导电体到绝缘体的透射不考虑，因为光能被完全吸收了转化成热能，几乎很少见）。导电体的折射指数为复数值$\overline \eta=\eta+ik$，虚数部分的$k$被称为吸收系数（absorption coefficient），导电体的折射系数和吸收系数均匀波长有关。绝缘体和导电体边界上的菲涅尔反射率计算公式如下：</p>
<script type="math/tex; mode=display">
r_\perp=\frac{a^2+b^2-2a cos\theta + cos^2\theta}{a^2+b^2+2acos\theta+cos^2\theta} \tag {7}</script><script type="math/tex; mode=display">
r_{||}=r_{\perp}\frac{cos^2\theta(a^2+b^2)-2acos\theta sin^2\theta + sin^4\theta}{cos^2\theta(a^2+b^2)+2acos\theta sin^2\theta+sin^4\theta} \tag {8}</script><p>&emsp;&emsp;其中：</p>
<script type="math/tex; mode=display">
a^2+b^2=\sqrt{(\eta^2-k^2-sin^2\theta)^2+4\eta^2k^2}</script><p>&emsp;&emsp;而上式中的$\eta+ik=\overline \eta_t/\overline \eta_i$。由此实现导电体的<code>FrConductor</code>，输入$cos\theta_i$、$\overline\eta_i$、$\overline \eta_t = \eta_t+ik$，返回导电体的菲涅尔反射率，输入折射指数是一个光谱值<code>Spectrum</code>，因为导体的折射指数与波长有关：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Spectrum <span class="title">FrConductor</span><span class="params">(Float cosThetaI, <span class="keyword">const</span> Spectrum &amp;etai,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> Spectrum &amp;etat, <span class="keyword">const</span> Spectrum &amp;k)</span> </span>&#123;</span><br><span class="line">    cosThetaI = Clamp(cosThetaI, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    Spectrum eta = etat / etai;</span><br><span class="line">    Spectrum etak = k / etai;</span><br><span class="line"></span><br><span class="line">    Float cosThetaI2 = cosThetaI * cosThetaI;</span><br><span class="line">    Float sinThetaI2 = <span class="number">1.</span> - cosThetaI2;</span><br><span class="line">    Spectrum eta2 = eta * eta;</span><br><span class="line">    Spectrum etak2 = etak * etak;</span><br><span class="line"></span><br><span class="line">    Spectrum t0 = eta2 - etak2 - sinThetaI2;</span><br><span class="line">    Spectrum a2plusb2 = Sqrt(t0 * t0 + <span class="number">4</span> * eta2 * etak2);</span><br><span class="line">    Spectrum t1 = a2plusb2 + cosThetaI2;</span><br><span class="line">    Spectrum a = Sqrt(<span class="number">0.5f</span> * (a2plusb2 + t0));</span><br><span class="line">    Spectrum t2 = (Float)<span class="number">2</span> * cosThetaI * a;</span><br><span class="line">    Spectrum Rs = (t1 - t2) / (t1 + t2);</span><br><span class="line"></span><br><span class="line">    Spectrum t3 = cosThetaI2 * a2plusb2 + sinThetaI2 * sinThetaI2;</span><br><span class="line">    Spectrum t4 = t2 * sinThetaI2;</span><br><span class="line">    Spectrum Rp = Rs * (t3 - t4) / (t3 + t4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * (Rp + Rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;因此，导电体的菲涅尔反射类<code>FresnelConductor</code>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FresnelConductor</span> :</span> <span class="keyword">public</span> Fresnel &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// FresnelConductor Public Methods</span></span><br><span class="line">    <span class="function">Spectrum <span class="title">Evaluate</span><span class="params">(Float cosThetaI)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    FresnelConductor(<span class="keyword">const</span> Spectrum &amp;etaI, <span class="keyword">const</span> Spectrum &amp;etaT,</span><br><span class="line">                     <span class="keyword">const</span> Spectrum &amp;k)</span><br><span class="line">        : etaI(etaI), etaT(etaT), k(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Spectrum etaI, etaT, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Spectrum FresnelConductor::Evaluate(Float cosThetaI) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> FrConductor(<span class="built_in">std</span>::<span class="built_in">abs</span>(cosThetaI), etaI, etaT, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来就根据这些接口和函数实现完美的镜面反射和完美的镜面透射。</p>
<h3 id="2、完美镜面反射"><a href="#2、完美镜面反射" class="headerlink" title="2、完美镜面反射"></a>2、完美镜面反射</h3><p>&emsp;&emsp;对于完美的镜面反射，给定入射辐射率$L_i(\omega_i)$，菲涅尔反射率已经给出了反射辐射率的比值，因此我们现在寻找一个完美镜面反射的BRDF函数（双向反射分布函数），使得：</p>
<script type="math/tex; mode=display">
L_o(\omega_o)=\int f_r(\omega_o, \omega_i) L_i(\omega_i)|cos\theta_i|d\omega_i
=F_r(\omega_r)L_i(\omega_r)</script><p>&emsp;&emsp;其中$\omega_r$是$\omega_o$关于表面法线$n$的反射向量。上式的意思就是，给定出射方向$\omega_o$，反射方程计算的结果应当是$\omega_o$的反射向量$\omega_r$方向上入射进来的辐射率$L_i(\omega_r)$再乘上菲涅尔反射率。这表明BRDF函数即$f_r$应当为一个狄拉克函数，仅在$\omega_r$方向取值不为零。这里说的狄拉克函数就是采样理论的冲激函数$\delta (x_0)$，$\delta(x_0)$仅在$x=x_0$上取值不为零，而且具备取样特性$\int f(x)\delta(x-x_0)dx=f(x_0)$。经过一些简单的推导，可得完美镜面反射的BRDF函数如下：</p>
<script type="math/tex; mode=display">
f_r(p,\omega_o,\omega_i)=F_r(\omega_r)\frac{\delta(\omega_i-\omega_r)}{|cos\theta_r|} \tag {10}</script><p>&emsp;&emsp;由此，可以实现镜面反射的BRDF函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Spectrum SpecularReflection::Sample_f(<span class="keyword">const</span> Vector3f &amp;wo, Vector3f *wi,</span><br><span class="line">                                      <span class="keyword">const</span> Point2f &amp;sample, Float *pdf,</span><br><span class="line">                                      BxDFType *sampledType) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// Compute perfect specular reflection direction</span></span><br><span class="line">    *wi = Vector3f(-wo.x, -wo.y, wo.z);</span><br><span class="line">    *pdf = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fresnel-&gt;Evaluate(CosTheta(*wi)) * R / AbsCosTheta(*wi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;因为镜面反射的BRDF是一个狄拉克函数，因此仅使用<code>Sample_f</code>计算BRDF值，而不是使用<code>f</code>接口。<code>SpecularReflection</code>还接收一个光谱值<code>R</code>，这个是物体的反照率：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecularReflection</span> :</span> <span class="keyword">public</span> BxDF &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// SpecularReflection Public Methods</span></span><br><span class="line">    SpecularReflection(<span class="keyword">const</span> Spectrum &amp;R, Fresnel *fresnel)</span><br><span class="line">        : BxDF(BxDFType(BSDF_REFLECTION | BSDF_SPECULAR)),</span><br><span class="line">          R(R),</span><br><span class="line">          fresnel(fresnel) &#123;&#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spectrum(<span class="number">0.f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">Sample_f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, Vector3f *wi, <span class="keyword">const</span> Point2f &amp;sample,</span></span></span><br><span class="line"><span class="function"><span class="params">                      Float *pdf, BxDFType *sampledType)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Float <span class="title">Pdf</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// SpecularReflection Private Data</span></span><br><span class="line">    <span class="keyword">const</span> Spectrum R;</span><br><span class="line">    <span class="keyword">const</span> Fresnel *fresnel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、完美镜面透射"><a href="#3、完美镜面透射" class="headerlink" title="3、完美镜面透射"></a>3、完美镜面透射</h3><p>&emsp;&emsp;给定折射方向$\omega_o$和入射方向$\omega_i$，描述折射光的能量占据入射光的能量分布的函数就是BTDF函数（双向透射分布函数）。根据能量守恒，透射的能量占比应为菲涅尔反射之后剩余的能量占比，即$\tau = 1-F_r(\omega_i)$，透射的辐射功率为$d\Phi_o=\tau d\Phi_i$，根据辐射率的定义，我们有：</p>
<script type="math/tex; mode=display">
L_ocos\theta_o dA d\omega_o = \tau(L_i cos\theta_i dA d\omega_i)</script><p>&emsp;&emsp;将立体角$\omega$转换成用球面坐标系$(\theta,\phi)$表示，上述公式可写成：</p>
<script type="math/tex; mode=display">
L_o cos\theta_o dA sin\theta_o d\theta_o d\phi_o = \tau(L_i cos\theta_i dA sin\theta_i d\theta_i d\phi_i) \tag {11}</script><p>&emsp;&emsp;然后对Snell定律即$\eta_i sin\theta_i = \eta_o sin \theta_o$得两边求关于$\theta$的微分：</p>
<script type="math/tex; mode=display">
\eta_o cos\theta_o d\theta_o = \eta_i cos\theta_i d\theta_i 
\to \frac{cos\theta_o d\theta_o}{cos\theta_i d\theta_i}=\frac{\eta_i}{\eta_o} \tag {12}</script><p>&emsp;&emsp;联立$(11)$、$(12)$和Snell定律， 可得：</p>
<script type="math/tex; mode=display">
L_o \eta_i^2 d\phi_o = \tau L_i \eta_o^2 d\phi_i</script><p>&emsp;&emsp;又因为$\phi_i=\phi_o+\pi$，故$d\phi_i=d\phi_o$，可最终简化为：</p>
<script type="math/tex; mode=display">
L_o=\tau L_i \frac{\eta_o^2}{\eta_i^2} \tag {13}</script><p>&emsp;&emsp;由此便给出了入射辐射率与出射辐射率之间的关系。正如完美镜面反射的BRDF一样，BTDF可以得到类似的狄拉克函数形式：</p>
<script type="math/tex; mode=display">
f_t(\omega_o,\omega_i)=\frac{\eta_o^2}{\eta_i^2}(1-F_r(\omega_i))\frac{\delta(\omega_i-T(\omega_o,n))}{|cos\theta_i|} \tag {14}</script><p>&emsp;&emsp;其中$T(\omega_o,n)$表示$\omega_o$对应的入射向量（经过完美透射）。因此实现完美镜面透射的BTDF函数如下，<code>SpecularTransmission</code>只考虑绝缘体的透射，因此需要借用绝缘体的菲涅尔函数<code>FresnelDielectric</code>，<code>etaA</code>和<code>etaB</code>分别保存了当前介质外部、内部的折射指数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecularTransmission</span> :</span> <span class="keyword">public</span> BxDF &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// SpecularTransmission Public Methods</span></span><br><span class="line">    SpecularTransmission(<span class="keyword">const</span> Spectrum &amp;T, Float etaA, Float etaB,</span><br><span class="line">                         TransportMode mode)</span><br><span class="line">        : BxDF(BxDFType(BSDF_TRANSMISSION | BSDF_SPECULAR)),</span><br><span class="line">          T(T),</span><br><span class="line">          etaA(etaA),</span><br><span class="line">          etaB(etaB),</span><br><span class="line">          fresnel(etaA, etaB),</span><br><span class="line">          mode(mode) &#123;&#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spectrum(<span class="number">0.f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">Sample_f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, Vector3f *wi, <span class="keyword">const</span> Point2f &amp;sample,</span></span></span><br><span class="line"><span class="function"><span class="params">                      Float *pdf, BxDFType *sampledType)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Float <span class="title">Pdf</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// SpecularTransmission Private Data</span></span><br><span class="line">    <span class="keyword">const</span> Spectrum T;</span><br><span class="line">    <span class="keyword">const</span> Float etaA, etaB;</span><br><span class="line">    <span class="keyword">const</span> FresnelDielectric fresnel;</span><br><span class="line">    <span class="keyword">const</span> TransportMode mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Sample_f</code>的实现基本上对应的就是前面的公式$(14)$，但要注意是否发生了全反射以及判断是从里向外透射还是从外向里透射，下面中的<code>Refract</code>用于计算折射向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Spectrum SpecularTransmission::Sample_f(<span class="keyword">const</span> Vector3f &amp;wo, Vector3f *wi,</span><br><span class="line">                                        <span class="keyword">const</span> Point2f &amp;sample, Float *pdf,</span><br><span class="line">                                        BxDFType *sampledType) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// Figure out which $\eta$ is incident and which is transmitted</span></span><br><span class="line">    <span class="keyword">bool</span> entering = CosTheta(wo) &gt; <span class="number">0</span>;</span><br><span class="line">    Float etaI = entering ? etaA : etaB;</span><br><span class="line">    Float etaT = entering ? etaB : etaA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute ray direction for specular transmission</span></span><br><span class="line">    <span class="keyword">if</span> (!Refract(wo, Faceforward(Normal3f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), wo), etaI / etaT, wi))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *pdf = <span class="number">1</span>;</span><br><span class="line">    Spectrum ft = T * (Spectrum(<span class="number">1.</span>) - fresnel.Evaluate(CosTheta(*wi)));</span><br><span class="line">    <span class="comment">// Account for non-symmetry with transmission to different medium</span></span><br><span class="line">    <span class="keyword">if</span> (mode == TransportMode::Radiance) ft *= (etaI * etaI) / (etaT * etaT);</span><br><span class="line">    <span class="keyword">return</span> ft / AbsCosTheta(*wi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、综合反射与透射"><a href="#4、综合反射与透射" class="headerlink" title="4、综合反射与透射"></a>4、综合反射与透射</h3><p>&emsp;&emsp;上面讨论的是仅发生完美镜面反射或仅发生完美镜面透射的情况，但现实中更多的是两者的综合作用，发生透射和发生反射的比例通过菲涅尔方程联系起来，$F_r(\omega_i)$是反射率，则$1-F_r(\omega_i)$是透射率。因此我们创建一个两者综合作用的<code>BxDF</code>类如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FresnelSpecular</span> :</span> <span class="keyword">public</span> BxDF &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// FresnelSpecular Public Methods</span></span><br><span class="line">    FresnelSpecular(<span class="keyword">const</span> Spectrum &amp;R, <span class="keyword">const</span> Spectrum &amp;T, Float etaA,</span><br><span class="line">                    Float etaB, TransportMode mode)</span><br><span class="line">        : BxDF(BxDFType(BSDF_REFLECTION | BSDF_TRANSMISSION | BSDF_SPECULAR)),</span><br><span class="line">          R(R),</span><br><span class="line">          T(T),</span><br><span class="line">          etaA(etaA),</span><br><span class="line">          etaB(etaB),</span><br><span class="line">          mode(mode) &#123;&#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spectrum(<span class="number">0.f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">Sample_f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, Vector3f *wi, <span class="keyword">const</span> Point2f &amp;u,</span></span></span><br><span class="line"><span class="function"><span class="params">                      Float *pdf, BxDFType *sampledType)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Float <span class="title">Pdf</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// FresnelSpecular Private Data</span></span><br><span class="line">    <span class="keyword">const</span> Spectrum R, T;</span><br><span class="line">    <span class="keyword">const</span> Float etaA, etaB;</span><br><span class="line">    <span class="keyword">const</span> TransportMode mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;实现的关键就是<code>Sample_f</code>函数，对于菲涅尔方程给定的反射率和透射率，我们以概率的形式进行采样，具体这里暂不展开，因为涉及到了后面的蒙特卡洛的渲染积分方法。</p>
<h2 id="四、Lambertian漫反射"><a href="#四、Lambertian漫反射" class="headerlink" title="四、Lambertian漫反射"></a>四、Lambertian漫反射</h2><p>&emsp;&emsp;Lambertian漫反射是一种理想的漫反射模型，在该光照模型下，入射光能向整个半球方向均匀地反射。尽管该模型现实生活中并不存在，但视觉上足以逼近真实了。Lambertian漫反射的推导非常简单，给定一束光，向整个半球反射的反射率为前面的半球-方向反射率（即前面的公式$(1)$），即：</p>
<script type="math/tex; mode=display">
\rho_{hd}(\omega_o)=\int_{H^2(n)} f_r(p,\omega_o, \omega_i)|cos\theta_i|d\omega_i</script><p>&emsp;&emsp;Lambertian漫反射向这个半球方向均匀地反射，则其BRDF函数是跟$\omega_o$、$\omega_i$无关的常量函数，将$f_r$提出积分外部，则剩余的积分可直接求解：</p>
<script type="math/tex; mode=display">
\int_{H^2(n)} cos\theta_i d\omega_i = \int_{H^2(n)} cos\theta_i sin\theta_i d\theta_i d\phi = \pi</script><p>&emsp;&emsp;理想情况下，不考虑能量损耗，反射到整个半球方向的总反射率$\rho_{hd}=1$，因此有$1=\pi \times f_r$，得$f_r=\frac{1}{\pi}$，Lambertian的BRDF就是这么简单，但通常我们还要考虑物体表面的反照率（可以理解为表面颜色），故Lambertian的BRDF函数为：</p>
<script type="math/tex; mode=display">
f_r(p)=\frac{R}{\pi} \tag {15}</script><p>&emsp;&emsp;其中$R$是物体的光谱反照率。因此实现<code>LambertianReflection</code>如下，<code>f</code>函数就是上面的公式$(15)$：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LambertianReflection</span> :</span> <span class="keyword">public</span> BxDF &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// LambertianReflection Public Methods</span></span><br><span class="line">    LambertianReflection(<span class="keyword">const</span> Spectrum &amp;R)</span><br><span class="line">        : BxDF(BxDFType(BSDF_REFLECTION | BSDF_DIFFUSE)), R(R) &#123;&#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Spectrum <span class="title">rho</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;, <span class="keyword">int</span>, <span class="keyword">const</span> Point2f *)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> R; &#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">rho</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> Point2f *, <span class="keyword">const</span> Point2f *)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> R; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// LambertianReflection Private Data</span></span><br><span class="line">    <span class="keyword">const</span> Spectrum R;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Spectrum LambertianReflection::f(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> R * InvPi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;值得一提的是<code>rho</code>接口，他直接返回了物体的反照率。因为向整个半球方向的总反射率为$1$，因此返回$1\times R$。这是精准的解析解，没有必要用数值方法求解。</p>
<p>&emsp;&emsp;除了Lambertian反射，还有Lambertian透射，两者区别仅在于散射的方向。Lambertian透射向表面的下半球的方向进行均匀的透射，BTDF函数与前面的BRDF函数一样。pbrt中实现了此透射，非常简单，这里不再赘述。</p>
<h2 id="五、基于微平面的散射模型"><a href="#五、基于微平面的散射模型" class="headerlink" title="五、基于微平面的散射模型"></a>五、基于微平面的散射模型</h2><p>&emsp;&emsp;上面讨论的几种BSDF模型都是基于理想状态的物理模型，真实物理世界很少或者可以说没有如此完美的物体表面，大部分物体的表面几乎或多或少地存在着不同程度的粗糙度。为此描述此种材质表面，基于几何光学的渲染方法提出了一种微平面（microfacet）模型，该模型基于这样的设定：任何一个物体的表面，在微观层面上都是由很多个不同朝向的光滑镜面组成，这些光滑的微平面对光的散射属性共同构成了宏观表面上的光线散射性质。</p>
<p>&emsp;&emsp;微平面的法线朝向越与宏观表面的法线一致，则表面越光滑；反之微平面的朝向越混乱，则表面越粗糙。由此，采用微平面模型对物体表面建模涉及到两个重要的点：微平面的分布描述函数、微平面的BSDF模型。这两点共同构成了宏观物体表面的BSDF函数。微平面的排列分布通常由宏观层面的统计概率描述。微平面的光学散射则稍微要麻烦一些，这是因为在微平面的局部模型下，涉及到下图所示的三类光学效应。首先是<strong>Masking</strong>即遮蔽，反射的光线被另外的微平面挡住，从而减弱了反射光线；其次是<strong>Shadowing</strong>即阴影，一个微平面被其他微平面遮挡了，处于阴影之中；最后是<strong>Interreflection</strong>即互反射，光线在微平面之间互相反射多次，最终才抵达人眼。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.35/blog/Scattering/5.png" width="60%"></div></p>
<p>&emsp;&emsp;基于微平面的BSDF模型应当尽量考虑上述三种效应，同时也尽量使得数学表达式简洁，计算量尽可能地少。</p>
<h3 id="1、Oren-Nayar漫反射"><a href="#1、Oren-Nayar漫反射" class="headerlink" title="1、Oren-Nayar漫反射"></a>1、Oren-Nayar漫反射</h3><p>&emsp;&emsp;Oren和Nayar观察到真实世界的物体表面上并不存在完美的Lambertian漫反射，他们提出了一种基于球形高斯分布的V形微平面模型，用以描述粗糙的表面。他们给出的近似拟合BRDF函数如下：</p>
<script type="math/tex; mode=display">
f_r(\omega_i,\omega_o)=\frac R\pi(A+B\ max(0,cos(\phi_i-\phi_o))sin\ \alpha\ tan\ \beta) \tag {16}</script><p>&emsp;&emsp;其中：</p>
<script type="math/tex; mode=display">
A=1-\frac{\sigma^2}{2(\sigma^2+0.33)}\\
B=\frac{0.45\sigma^2}{\sigma^2+0.09}\\
\alpha = max(\theta_i, \theta_o)\\
\beta = min(\theta_i,\theta_o)</script><p>&emsp;&emsp;$\sigma$是微平面法线朝向的标准差，弧度制。为此，实现Oren和Nayar的漫反射BRDF函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrenNayar</span> :</span> <span class="keyword">public</span> BxDF &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// OrenNayar Public Methods</span></span><br><span class="line">    <span class="function">Spectrum <span class="title">f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    OrenNayar(<span class="keyword">const</span> Spectrum &amp;R, Float sigma)</span><br><span class="line">        : BxDF(BxDFType(BSDF_REFLECTION | BSDF_DIFFUSE)), R(R) &#123;</span><br><span class="line">        sigma = Radians(sigma);</span><br><span class="line">        Float sigma2 = sigma * sigma;</span><br><span class="line">        A = <span class="number">1.f</span> - (sigma2 / (<span class="number">2.f</span> * (sigma2 + <span class="number">0.33f</span>)));</span><br><span class="line">        B = <span class="number">0.45f</span> * sigma2 / (sigma2 + <span class="number">0.09f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// OrenNayar Private Data</span></span><br><span class="line">    <span class="keyword">const</span> Spectrum R;</span><br><span class="line">    Float A, B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据三角恒等式，公式$(16)$中的$cos(\phi_i-\phi_o)=cos\phi_i cos\phi_o+sin\phi_i sin\phi_o$，省去了一些角度的计算。而$\alpha$和$\beta$中角度的比较可以通过它们的$cos$值比较：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Spectrum OrenNayar::f(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi) <span class="keyword">const</span> &#123;</span><br><span class="line">    Float sinThetaI = SinTheta(wi);</span><br><span class="line">    Float sinThetaO = SinTheta(wo);</span><br><span class="line">    <span class="comment">// Compute cosine term of Oren-Nayar model</span></span><br><span class="line">    Float maxCos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sinThetaI &gt; <span class="number">1e-4</span> &amp;&amp; sinThetaO &gt; <span class="number">1e-4</span>) &#123;</span><br><span class="line">        Float sinPhiI = SinPhi(wi), cosPhiI = CosPhi(wi);</span><br><span class="line">        Float sinPhiO = SinPhi(wo), cosPhiO = CosPhi(wo);</span><br><span class="line">        Float dCos = cosPhiI * cosPhiO + sinPhiI * sinPhiO;</span><br><span class="line">        maxCos = <span class="built_in">std</span>::max((Float)<span class="number">0</span>, dCos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute sine and tangent terms of Oren-Nayar model</span></span><br><span class="line">    Float sinAlpha, tanBeta;</span><br><span class="line">    <span class="keyword">if</span> (AbsCosTheta(wi) &gt; AbsCosTheta(wo)) &#123;</span><br><span class="line">        sinAlpha = sinThetaO;</span><br><span class="line">        tanBeta = sinThetaI / AbsCosTheta(wi);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sinAlpha = sinThetaI;</span><br><span class="line">        tanBeta = sinThetaO / AbsCosTheta(wo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R * InvPi * (A + B * maxCos * sinAlpha * tanBeta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该模型通过$\sigma$控制表面的粗糙程度。</p>
<h3 id="2、法线分布函数"><a href="#2、法线分布函数" class="headerlink" title="2、法线分布函数"></a>2、法线分布函数</h3><p>&emsp;&emsp;在对glossy specular等表面基于微平面的BSDF进行深入了解之前，我们先来看看描述微平面分布的相关函数。微平面的分布情况主要通过微平面的法线朝向来描述，因此微平面分布函数又被称为法线分布函数，记为$D(\omega_h)$，其中输入的参数是微平面的法线向量$\omega_h$（依旧在着色坐标系下），该函数返回具有$\omega_h$朝向法线的微平面占比。法线分布函数的选取并不是任意的，需要符合物理逻辑。对于一个宏观表面上的微分面$dA$，在该微分面上的所有微平面投影到$dA$上的面积总和应该恰好等于$dA$，从数学上来讲，$D(\omega_h)$应满足如下要求：</p>
<script type="math/tex; mode=display">
\int_{H^2(n)}D(\omega_h)cos\theta_h d\omega_h = 1</script><p>&emsp;&emsp;首先创建一个微平面函数的接口类如下，<code>D</code>就是微平面分布的接口函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MicrofacetDistribution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// MicrofacetDistribution Public Methods</span></span><br><span class="line">    <span class="keyword">virtual</span> ~MicrofacetDistribution();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Float <span class="title">D</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wh)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一个被广泛使用的微平面分布模型是由Beckmann和Spizzichino等人提出的微平面斜率的高斯分布函数，传统的<strong>Beckmann–Spizzichino法线分布函数</strong>定义为：</p>
<script type="math/tex; mode=display">
D(\omega_h)=\frac{e^{-tan^2\theta_h/\alpha^2}}{\pi \alpha^2 cos^4\theta_h}</script><p>&emsp;&emsp;其中$\sigma$是微平面的RMS斜率，而$\alpha=\sqrt2 \sigma$。这是一个各向同性的法线分布函数。可将其扩展到各向异性，使得微平面的法线分布亦随着$\omega_h$的方位角（也就是$\phi_h$）变化而变化。令$\alpha_x$为法线朝向垂直于$x$轴的微平面占比，$\alpha_y$为法线朝向垂直于$y$轴的微平面占比，然后任何介于两者之间通过椭圆插值得到，故可以得到如下的各向异性微平面分布函数：</p>
<script type="math/tex; mode=display">
D(\omega_h)=\frac{e^{-tan^2\theta_h(cos^2\phi_h/\alpha_x^2+sin^2\phi_h/\alpha_y^2)}}{\pi \alpha_x \alpha_y cos^4\theta_h}</script><p>&emsp;&emsp;当$\alpha_x=\alpha_y$时，上式就变成了各向同性函数。下面的函数实现了上述的公式，这里要特别注意$tan^2\theta_h$趋于无穷的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Float BeckmannDistribution::D(<span class="keyword">const</span> Vector3f &amp;wh) <span class="keyword">const</span> &#123;</span><br><span class="line">    Float tan2Theta = Tan2Theta(wh);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::isinf(tan2Theta)) <span class="keyword">return</span> <span class="number">0.</span>;</span><br><span class="line">    Float cos4Theta = Cos2Theta(wh) * Cos2Theta(wh);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">exp</span>(-tan2Theta * (Cos2Phi(wh) / (alphax * alphax) +</span><br><span class="line">                                  Sin2Phi(wh) / (alphay * alphay))) /</span><br><span class="line">           (Pi * alphax * alphay * cos4Theta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除了上面的法线分布函数，还有一个非常有用的微平面分布函数就是<strong>Trowbridge–Reitz法线分布函数</strong>。与Beckmann–Spizzichino函数相比，它两边趋于$0$的速度更加平缓，如下图所示：</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.35/blog/Scattering/6.png" width="40%"></div></p>
<p>&emsp;&emsp;Trowbridge–Reitz法线分布函数定义为：</p>
<script type="math/tex; mode=display">
D(\omega_h)=\frac{1}{\pi \alpha_x \alpha_y cos^4 \theta_h(1+tan^2\theta_h(cos^2\phi_h/\alpha_x^2+sin^2\phi_h/\alpha^2_y))^2}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Float TrowbridgeReitzDistribution::D(<span class="keyword">const</span> Vector3f &amp;wh) <span class="keyword">const</span> &#123;</span><br><span class="line">    Float tan2Theta = Tan2Theta(wh);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::isinf(tan2Theta)) <span class="keyword">return</span> <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">const</span> Float cos4Theta = Cos2Theta(wh) * Cos2Theta(wh);</span><br><span class="line">    Float e =</span><br><span class="line">        (Cos2Phi(wh) / (alphax * alphax) + Sin2Phi(wh) / (alphay * alphay)) *</span><br><span class="line">        tan2Theta;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (Pi * alphax * alphay * cos4Theta * (<span class="number">1</span> + e) * (<span class="number">1</span> + e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们用$\alpha_x$和$\alpha_y$控制微平面的分布情况，这两个参数并不是很直观。为此尝试在粗糙度和这两个参数之间构建联系，下面<code>RoughnessToAlpha</code>就实现了该映射，用户只需输入$[0,1]$的粗糙度，$0$表示绝对光滑，$1$表示极度粗糙，非常直观方便。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Float TrowbridgeReitzDistribution::RoughnessToAlpha(Float roughness) &#123;</span><br><span class="line">    roughness = <span class="built_in">std</span>::max(roughness, (Float)<span class="number">1e-3</span>);</span><br><span class="line">    Float x = <span class="built_in">std</span>::<span class="built_in">log</span>(roughness);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.62142f</span> + <span class="number">0.819955f</span> * x + <span class="number">0.1734f</span> * x * x + <span class="number">0.0171201f</span> * x * x * x +</span><br><span class="line">           <span class="number">0.000640711f</span> * x * x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、几何遮蔽函数"><a href="#3、几何遮蔽函数" class="headerlink" title="3、几何遮蔽函数"></a>3、几何遮蔽函数</h3><p>&emsp;&emsp;前面用法线分布函数对给定粗糙程度的表面的微平面分布进行了描述，对于微平面的Shadowing效应和Masking效应，我们将采用几何遮蔽函数对此进行建模。毫无疑问，几何遮蔽函数应该是跟观察方向$\omega$相关的，给定观察方向，则因为Shadowing和Masking，只有一部分微平面能够被观察到。Smith’s masking-shadowing几何遮蔽函数$G_1(\omega, \omega_h)$给出了从$\omega$方向能够观察到的法线为$\omega_h$的微平面数量比例（因此，$0\leq G_1(\omega,\omega_h)\leq 1$）。通常情况下，几何遮蔽函数与微平面的法线$\omega_h$无关，因此写成$G_1(\omega)$的形式。</p>
<p>&emsp;&emsp;给定观察视角$\omega$和一个微分面$dA$，则从视角$\omega$观察到的$dA$的面积是投影面积$dA cos\theta$，$\theta$是$\omega$与$dA$的法线的夹角。由此给出了下面的关于$G_1$的数学约束：</p>
<script type="math/tex; mode=display">
cos \theta=\int_{H^2(n)} G_1(\omega,\omega_h) max(0,\omega\cdot \omega_h) D(\omega_h) d\omega_h</script><p>&emsp;&emsp;在观察方向$\omega$上，有一些正向朝向的微平面被一些背向朝向的微平面遮挡了。记$A^+(\omega)$是正向朝向$\omega$的微平面的面积和，$A^-(\omega)$是背向朝向$\omega$的微平面面积和，则应该有$cos\theta = A^+(\omega)-A^-(\omega)$，即在正向朝向的微平面中减去被遮挡的部分，则剩余部分应该就是从$\omega$能够观察到的微平面（注意，这里采用高度场表示微平面，因此是可以这样直接减去）。那么根据定义，masking-shadowing函数就应该为可见的正向朝向面积和比上总的正向朝向面积和：</p>
<script type="math/tex; mode=display">
G_1(\omega)=\frac{A^+(\omega)-A^-(\omega)}{A^+(\omega)}</script><p>&emsp;&emsp;但masking-shadowing函数的实现通常定义了如下的辅助函数：</p>
<script type="math/tex; mode=display">
\Lambda(\omega)=\frac{A^-(\omega)}{A^+(\omega)-A^-(\omega)}=\frac{A^-(\omega)}{cos\theta}</script><p>&emsp;&emsp;在<code>MicrofacetDistribution</code>中我们定义如下的接口<code>Lambda</code>以计算$\Lambda$这个辅助函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Float <span class="title">Lambda</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;w)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意观察$\Lambda$和$G_1$的差别，我们可以根据$\Lambda$得到$G_1$：</p>
<script type="math/tex; mode=display">
G_1(\omega)=\frac{1}{1+\Lambda(\omega)}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Float <span class="title">G1</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;w)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + Lambda(w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来的问题就是如何根据前面的法线分布函数$D(\omega_h)$找到合适的符合数学约束的$\Lambda$函数。但实际上满足前面数学约束的$\Lambda$并不唯一，为此人们假定当前微平面的高度和周围微平面的高度不相关，这种假定虽然不符合现实，但也具备一定的准确度。</p>
<p>&emsp;&emsp;基于上述的假设，Beckmann–Spizzichino法线分布函数的各向同性$\Lambda(\omega)$函数为：</p>
<script type="math/tex; mode=display">
\Lambda(\omega)=\frac12(erf(a)-1+\frac{e^{-a^2}}{a\sqrt\pi})</script><p>&emsp;&emsp;其中$a=1/(\alpha tan \theta)$，$erf(x)=2/\sqrt\pi \int_0^x e^{-x’^2}dx’$是误差函数。误差函数$erf$和$exp$函数计算量有点大，pbrt用一个近似的多项式拟合上面$\Lambda(\omega)$函数，虽然带来了一定的误差，但大大提升了计算效率：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Float BeckmannDistribution::Lambda(<span class="keyword">const</span> Vector3f &amp;w) <span class="keyword">const</span> &#123;</span><br><span class="line">    Float absTanTheta = <span class="built_in">std</span>::<span class="built_in">abs</span>(TanTheta(w));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::isinf(absTanTheta)) <span class="keyword">return</span> <span class="number">0.</span>;</span><br><span class="line">    <span class="comment">// Compute _alpha_ for direction _w_</span></span><br><span class="line">    Float alpha =</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">sqrt</span>(Cos2Phi(w) * alphax * alphax + Sin2Phi(w) * alphay * alphay);</span><br><span class="line">    Float a = <span class="number">1</span> / (alpha * absTanTheta);</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= <span class="number">1.6f</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - <span class="number">1.259f</span> * a + <span class="number">0.396f</span> * a * a) / (<span class="number">3.535f</span> * a + <span class="number">2.181f</span> * a * a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里同样用$\alpha_x$和$\alpha_y$使得$\Lambda(\omega)$为各向异性的形式。</p>
<p>&emsp;&emsp;而Trowbridge–Reitz法线分布函数的$\Lambda(\omega)$为：</p>
<script type="math/tex; mode=display">
\Lambda(\omega)=\frac{-1+\sqrt{1+\alpha^2 tan^2\theta}}{2}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Float TrowbridgeReitzDistribution::Lambda(<span class="keyword">const</span> Vector3f &amp;w) <span class="keyword">const</span> &#123;</span><br><span class="line">    Float absTanTheta = <span class="built_in">std</span>::<span class="built_in">abs</span>(TanTheta(w));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::isinf(absTanTheta)) <span class="keyword">return</span> <span class="number">0.</span>;</span><br><span class="line">    <span class="comment">// Compute _alpha_ for direction _w_</span></span><br><span class="line">    Float alpha =</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">sqrt</span>(Cos2Phi(w) * alphax * alphax + Sin2Phi(w) * alphay * alphay);</span><br><span class="line">    Float alpha2Tan2Theta = (alpha * absTanTheta) * (alpha * absTanTheta);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span> + <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">1.f</span> + alpha2Tan2Theta)) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面我们讨论的几何遮蔽函数输入一个参数，即观察方向$\omega$。但要顾及的现象除了Masking，还有Shadowing。Masking是在出射方向$\omega_o$出现了遮挡，而Shadowing则是在入射方向$\omega_i$出现了遮挡。为此，我们定义$G(\omega_o,\omega_i)$函数综合考虑Masking和Shadowing的现象，返回经过Masking和Shadowing之后的可见微平面数量比例。</p>
<p>&emsp;&emsp;一种非常简单的$G(\omega_o,\omega_i)$直接利用前面的$G_1(\omega)$函数，假定$G_1(\omega_o)$和$G_1(\omega_i)$互相独立、互不相关，因此有如下的$G(\omega_o,\omega_i)$：</p>
<script type="math/tex; mode=display">
G(\omega_o,\omega_i)=G_1(\omega_o)G_1(\omega_i)</script><p>&emsp;&emsp;上面的公式不难理解。但在实际情况中，$G_1(\omega_o)$和$G_1(\omega_i)$并不是互相独立的，而是具备一定的相关性。例如当$\omega_i=\omega_o$时，应该有$G(\omega_o,\omega_i)=G_1(\omega_o)=G_1(\omega_i)$，因为$G_1\leq 1$，因此$G_1(\omega_o)G_1(\omega_i)$会造成计算结果偏小。一般情况，$\omega_i$和$\omega_o$越靠近，则相关性越大。</p>
<p>&emsp;&emsp;因此，一种更加准确的$G(\omega_o,\omega_i)$计算公式为：</p>
<script type="math/tex; mode=display">
G(\omega_o,\omega_i)=\frac{1}{1+\Lambda(\omega_o)+\Lambda(\omega_i)}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Float <span class="title">G</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + Lambda(wo) + Lambda(wi));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、Torrance-Sparrow镜面散射"><a href="#4、Torrance-Sparrow镜面散射" class="headerlink" title="4、Torrance-Sparrow镜面散射"></a>4、Torrance-Sparrow镜面散射</h3><p>&emsp;&emsp;Torrance和Sparrow提出了一种早期的、经典的BRDF模型，这类模型对金属表面进行建模。物体的表面是由大量的完美光滑的微平面组成，因此给定入射方向$\omega_i$和反射方向$\omega_o$，只有法线朝向为$\omega_i+\omega_o$的微平面会参与反射。我们称$\omega_i+\omega_o$为半角向量，记为$\omega_h$。接下来就看看Torrance-Sparrow模型是如何推导的。</p>
<p>&emsp;&emsp;首先，根据辐射率的定义，入射到法线朝向为$\omega_h$的微平面上的总微分辐射功率为：</p>
<script type="math/tex; mode=display">
d\Phi_h =L_i(\omega_i)d\omega_i dA^{\perp}(\omega_h)=L_i(\omega_i)d\omega_i cos\theta_h dA(\omega_h)</script><p>&emsp;&emsp;$\theta_h$是向量$\omega_i$与$\omega_h$的夹角。$dA(\omega_h)$是法线朝向为$\omega_h$的微平面总面积，又有$dA(\omega_h)=D(\omega_h)d\omega_h dA$，因此：</p>
<script type="math/tex; mode=display">
d\Phi_h=L_i(\omega_i)d\omega_i cos\theta_hD(\omega_h)d\omega_h dA \tag {17}</script><p>&emsp;&emsp;然后，根据菲涅尔反射率，可以得到出射的辐射功率：</p>
<script type="math/tex; mode=display">
d\Phi_o=F_r(\omega_o)d\Phi_h \tag {18}</script><p>&emsp;&emsp;再根据辐射率的定理，出射辐射率则为：</p>
<script type="math/tex; mode=display">
L(\omega_o)=\frac{d\Phi_o}{d\omega_o cos\theta_o dA}</script><p>&emsp;&emsp;将公式$(18)$和$(17)$带入上面的方程，就有：</p>
<script type="math/tex; mode=display">
L(\omega_o)=\frac{F_r(\omega_o)L_i(\omega_i)d\omega_i D(\omega_h) d\omega_h dA cos\theta_h}{d\omega_o dA cos\theta_o}</script><p>&emsp;&emsp;$\omega_h$和$\omega_o$又存在着函数关系，有$d\omega_h = \frac{d\omega_o}{4cos\theta_h}$（pbrt并没有在此展开，实际上应该就是通过$\omega_h=\omega_i+\omega_o$推导出来的）。带入上式有：</p>
<script type="math/tex; mode=display">
L(\omega_o)=\frac{F_r(\omega_o)L_i(\omega_i)D(\omega_h)d\omega_i}{4cos\theta_o}</script><p>&emsp;&emsp;最后，根据BRDF的定义（即出射辐射率比上入射辐照度），加上几何遮蔽函数$G(\omega_o,\omega_i)$，我们可推得Torrance-Sparrow的BRDF公式为：</p>
<script type="math/tex; mode=display">
f_r(\omega_o,\omega_i)=\frac{D(\omega_h)G(\omega_o,\omega_i)F_r(\omega_o)}{4cos\theta_o cos\theta_i} \tag {19}</script><p>&emsp;&emsp;Torrance-Sparrow模型优势就是它的通用性，它并不依赖于某种特定的法线分布函数以及菲涅尔方程。因此对导电体和绝缘体均适用。下面定义了<code>MicrofacetReflection</code>作为此类BRDF函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MicrofacetReflection</span> :</span> <span class="keyword">public</span> BxDF &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// MicrofacetReflection Public Methods</span></span><br><span class="line">    MicrofacetReflection(<span class="keyword">const</span> Spectrum &amp;R,</span><br><span class="line">                         MicrofacetDistribution *distribution, Fresnel *fresnel)</span><br><span class="line">        : BxDF(BxDFType(BSDF_REFLECTION | BSDF_GLOSSY)),</span><br><span class="line">          R(R),</span><br><span class="line">          distribution(distribution),</span><br><span class="line">          fresnel(fresnel) &#123;&#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Spectrum <span class="title">Sample_f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, Vector3f *wi, <span class="keyword">const</span> Point2f &amp;u,</span></span></span><br><span class="line"><span class="function"><span class="params">                      Float *pdf, BxDFType *sampledType)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Float <span class="title">Pdf</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// MicrofacetReflection Private Data</span></span><br><span class="line">    <span class="keyword">const</span> Spectrum R;</span><br><span class="line">    <span class="keyword">const</span> MicrofacetDistribution *distribution;</span><br><span class="line">    <span class="keyword">const</span> Fresnel *fresnel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中<code>distribution</code>和<code>fresnel</code>用于微平面相关分布函数的计算。下面的<code>f</code>实现了上面的公式$(19)$，这里要特别注意分母的$cos\theta_i$和$cos\theta_o$是否为零：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Spectrum MicrofacetReflection::f(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi) <span class="keyword">const</span> &#123;</span><br><span class="line">    Float cosThetaO = AbsCosTheta(wo), cosThetaI = AbsCosTheta(wi);</span><br><span class="line">    Vector3f wh = wi + wo;</span><br><span class="line">    <span class="comment">// Handle degenerate cases for microfacet reflection</span></span><br><span class="line">    <span class="keyword">if</span> (cosThetaI == <span class="number">0</span> || cosThetaO == <span class="number">0</span>) <span class="keyword">return</span> Spectrum(<span class="number">0.</span>);</span><br><span class="line">    <span class="keyword">if</span> (wh.x == <span class="number">0</span> &amp;&amp; wh.y == <span class="number">0</span> &amp;&amp; wh.z == <span class="number">0</span>) <span class="keyword">return</span> Spectrum(<span class="number">0.</span>);</span><br><span class="line">    wh = Normalize(wh);</span><br><span class="line">    <span class="comment">// For the Fresnel call, make sure that wh is in the same hemisphere</span></span><br><span class="line">    <span class="comment">// as the surface normal, so that TIR is handled correctly.</span></span><br><span class="line">    Spectrum F = fresnel-&gt;Evaluate(Dot(wi, Faceforward(wh, Vector3f(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))));</span><br><span class="line">    <span class="keyword">return</span> R * distribution-&gt;D(wh) * distribution-&gt;G(wo, wi) * F /</span><br><span class="line">           (<span class="number">4</span> * cosThetaI * cosThetaO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面我们推导的是反射，即BRDF公式。扩展到BTDF，关键在于$d\omega_o$和$d\omega_h$之间的关系。在这里，我们考虑的是微平面上的镜面透射（而非前面的镜面反射）。给定入射向量$\omega_i$和折射向量$\omega_o$，我们同样可以得到一个半角向量$\omega_h$，只不过这个半角向量是通过Snell定律获取（对于给定的$\omega_i$和$\omega_o$，只存在法向为$\omega_h$的微平面发生了透射）。$\omega_h$的计算公式如下：</p>
<script type="math/tex; mode=display">
\omega_h=\omega_o + \eta \omega_i\\
\eta=\eta_i/\eta_o</script><p>&emsp;&emsp;因此，$d\omega_h$与$d\omega_o$的关系为：</p>
<script type="math/tex; mode=display">
d\omega_h=\frac{\eta_o^2|\omega_o\cdot \omega_h|d\omega_o}{(\eta_i(\omega_i\cdot \omega_h)+\eta_o(\omega_o\cdot \omega_h))^2}</script><p>&emsp;&emsp;用这个替换调用上面BRDF推导过程中的$d\omega_h$可得BTDF公式如下：</p>
<script type="math/tex; mode=display">
f_t(\omega_o,\omega_i)=\frac{\eta^2 D(\omega_h)G(\omega_o,\omega_i)(1-F_r(\omega_o))}{((\omega_o\cdot \omega_h)+\eta(\omega_i\cdot \omega_h))^2}
\frac{|\omega_i\cdot \omega_h||\omega_o\cdot\omega_h|}{cos\theta_ocos\theta_i} \tag {20}</script><p>&emsp;&emsp;因此，创建一个<code>MicrofacetTransmission</code>，实现公式$(20)$如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Spectrum MicrofacetTransmission::f(<span class="keyword">const</span> Vector3f &amp;wo,</span><br><span class="line">                                   <span class="keyword">const</span> Vector3f &amp;wi) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (SameHemisphere(wo, wi)) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// transmission only</span></span><br><span class="line"></span><br><span class="line">    Float cosThetaO = CosTheta(wo);</span><br><span class="line">    Float cosThetaI = CosTheta(wi);</span><br><span class="line">    <span class="keyword">if</span> (cosThetaI == <span class="number">0</span> || cosThetaO == <span class="number">0</span>) <span class="keyword">return</span> Spectrum(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute $\wh$ from $\wo$ and $\wi$ for microfacet transmission</span></span><br><span class="line">    Float eta = CosTheta(wo) &gt; <span class="number">0</span> ? (etaB / etaA) : (etaA / etaB);</span><br><span class="line">    Vector3f wh = Normalize(wo + wi * eta);</span><br><span class="line">    <span class="keyword">if</span> (wh.z &lt; <span class="number">0</span>) wh = -wh;</span><br><span class="line"></span><br><span class="line">    Spectrum F = fresnel.Evaluate(Dot(wo, wh));</span><br><span class="line"></span><br><span class="line">    Float sqrtDenom = Dot(wo, wh) + eta * Dot(wi, wh);</span><br><span class="line">    Float factor = (mode == TransportMode::Radiance) ? (<span class="number">1</span> / eta) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Spectrum(<span class="number">1.f</span>) - F) * T *</span><br><span class="line">           <span class="built_in">std</span>::<span class="built_in">abs</span>(distribution-&gt;D(wh) * distribution-&gt;G(wo, wi) * eta * eta *</span><br><span class="line">                    AbsDot(wi, wh) * AbsDot(wo, wh) * factor * factor /</span><br><span class="line">                    (cosThetaI * cosThetaO * sqrtDenom * sqrtDenom));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过微平面的完美镜面反射和透射，我们实现了glossy镜面反射和透射。</p>
<h2 id="六、Ashikhmin-Shirley反射"><a href="#六、Ashikhmin-Shirley反射" class="headerlink" title="六、Ashikhmin-Shirley反射"></a>六、Ashikhmin-Shirley反射</h2><p>&emsp;&emsp;接下来要讨论的BRDF是由Ashikhmin和Shirley提出的一种综合了漫反射和镜面反射（glossy镜面反射）的反射模型。Ashikhmin-Shirley模型考虑如下图所示的两层表面，下面一层是漫反射材质，上面一层是glossy镜面反射材质（现实的这类物体有刷了光泽漆的墙、木桌等）。当观察方向接近于法线方向时，看到的主要下面一层的颜色；而当观察方向趋于与法向垂直时，观察道的更多是glossy镜面反射颜色。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.35/blog/Scattering/7.png" width="60%"></div></p>
<p>&emsp;&emsp;这种表面的镜面反射和漫反射通过菲涅尔反射率联系起来。Ashikhmin-Shirley模型推导出了一种近似的Schlick菲涅尔方程如下：</p>
<script type="math/tex; mode=display">
F_r(cos\theta)=R+(1-R)(1-cos\theta)^5</script><p>&emsp;&emsp;其中，$\theta$是观察方向与表面法线的夹角，$R$是镜面反照率光谱值。除了镜面反照率光谱值<code>Rs</code>，我们还有漫反射反照率光谱值<code>Rd</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Spectrum <span class="title">SchlickFresnel</span><span class="params">(Float cosTheta)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pow5 = [](Float v) &#123; <span class="keyword">return</span> (v * v) * (v * v) * v; &#125;;</span><br><span class="line">    <span class="keyword">return</span> Rs + pow5(<span class="number">1</span> - cosTheta) * (Spectrum(<span class="number">1.</span>) - Rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;glossy镜面反射部分的BRDF如下：</p>
<script type="math/tex; mode=display">
f_r(p,\omega_o,\omega_i)=\frac{D(\omega_h)F(\omega_o)}{4(\omega_h\cdot \omega_i)(max((n\cdot \omega_o),(n\cdot \omega_i)))} \tag {21}</script><p>&emsp;&emsp;而漫反射部分的BRDF为：</p>
<script type="math/tex; mode=display">
f_r(p,\omega_i,\omega_o)=\frac{28 R_d}{23\pi}(1-R_s)(1-(1-\frac{(n\cdot\omega_i)}{2})^5)(1-(1-\frac{(n\cdot\omega_o)}{2})^5) \tag {22}</script><p>&emsp;&emsp;因此，Ashikhmin-Shirley模型就是上面公式$(21)$和$(22)$的综合，分别用各自的BRDF计算镜面反射辐射率、漫反射辐射率，最后总的辐射率就是两者的相加：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Spectrum FresnelBlend::f(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> pow5 = [](Float v) &#123; <span class="keyword">return</span> (v * v) * (v * v) * v; &#125;;</span><br><span class="line">    Spectrum diffuse = (<span class="number">28.f</span> / (<span class="number">23.f</span> * Pi)) * Rd * (Spectrum(<span class="number">1.f</span>) - Rs) *</span><br><span class="line">                       (<span class="number">1</span> - pow5(<span class="number">1</span> - <span class="number">.5</span>f * AbsCosTheta(wi))) *</span><br><span class="line">                       (<span class="number">1</span> - pow5(<span class="number">1</span> - <span class="number">.5</span>f * AbsCosTheta(wo)));</span><br><span class="line">    Vector3f wh = wi + wo;</span><br><span class="line">    <span class="keyword">if</span> (wh.x == <span class="number">0</span> &amp;&amp; wh.y == <span class="number">0</span> &amp;&amp; wh.z == <span class="number">0</span>) <span class="keyword">return</span> Spectrum(<span class="number">0</span>);</span><br><span class="line">    wh = Normalize(wh);</span><br><span class="line">    Spectrum specular =</span><br><span class="line">        distribution-&gt;D(wh) /</span><br><span class="line">        (<span class="number">4</span> * AbsDot(wi, wh) * <span class="built_in">std</span>::max(AbsCosTheta(wi), AbsCosTheta(wo))) *</span><br><span class="line">        SchlickFresnel(Dot(wi, wh));</span><br><span class="line">    <span class="keyword">return</span> diffuse + specular;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、傅里叶基下的BSDF查找表"><a href="#七、傅里叶基下的BSDF查找表" class="headerlink" title="七、傅里叶基下的BSDF查找表"></a>七、傅里叶基下的BSDF查找表</h2><p>&emsp;&emsp;上面讨论的BSDF模型足以渲染大部分的物体材质了，但是依旧存在有些材质的BSDF无法与上述的BSDF匹配（例如多层的金属材料）。对于此类材质，一种方法就是真实测量材质的BSDF数据，然后将结果保存到一个三维或四维的查找表上，计算时直接通过查找表查找即可。但直接暴力的存储需要极其庞大的存储空间。为此研究者们提出了一种压缩方法，在傅里叶频域空间压缩存储查找表，此种方法省去了大量的存储空间。</p>
<p>&emsp;&emsp;在这里我们仅考虑各向同性的BSDF模型。BSDF函数有两个输入参数即$\omega_i$和$\omega_o$，这两个参数转换成用球面坐标系$(\theta,\phi)$下表示，则BSDF可转变成如下形式：</p>
<script type="math/tex; mode=display">
f(\omega_i,\omega_o)=f(\mu_i,\phi_i,\mu_o,\phi_o)</script><p>&emsp;&emsp;其中$\mu_i=cos\theta_i$，$\mu_o=cos\theta_o$。又因为BSDF为各向同性，则BSDF的取值应该至于$\phi=\phi_i-\phi_o$有关，因此：</p>
<script type="math/tex; mode=display">
f(\omega_i,\omega_o)=f(\mu_i,\mu_o,\phi_i-\phi_o)=f(\mu_i,\mu_o,\phi)</script><p>&emsp;&emsp;各向同性的BSDF还应该是关于$\phi$的偶函数，即$f(\mu_i,\mu_o,\phi)=f(\mu_i,\mu_o,-\phi)$。根据这些属性，BSDF函数展开成如下的傅里叶级数形式：</p>
<script type="math/tex; mode=display">
f(\mu_i,\mu_o,\phi_i-\phi_o)|\mu_i|=\sum_{k=0}^{m-1}a_k(\mu_i,\mu_o)cos(k(\phi_i-\phi_o)) \tag {23}</script><p>&emsp;&emsp;其中$a_k(\mu_i,\mu_o)$是关于给定的$(\mu_i,\mu_o)$对应的傅里叶系数。为此我们只需存储傅里叶系数$a_k(\mu_i,\mu_o)$即可，对$\mu_i$和$\mu_o$做$n$个离散量化，只需$m$个存储$n\times n$的傅里叶系数矩阵即可。但是对于给定的一对$(\mu_i,\mu_o)$，$m$的数量可以不相同，这是为了考虑空间的压缩。对于一些$(\mu_i,\mu_o)$，需要较大的$m$才能使得BSDF值达到指定的精度，而对于另一些则不需要那么大的$m$。因此我们实际上并不是存储的矩阵形式，而是对于每一对$(\mu_i,\mu_o)$和其对应的$m$，存储$a_0,a_1,…,a_{m-1}$。</p>
<p>&emsp;&emsp;创建如下的<code>FourierBSDFTable</code>保存一张BSDF数据表，这个数据表从指定外部文件中读取输入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FourierBSDFTable</span> &#123;</span></span><br><span class="line">    <span class="comment">// FourierBSDFTable Public Data</span></span><br><span class="line">    Float eta;</span><br><span class="line">    <span class="keyword">int</span> mMax;</span><br><span class="line">    <span class="keyword">int</span> nChannels;</span><br><span class="line">    <span class="keyword">int</span> nMu;</span><br><span class="line">    Float *mu;</span><br><span class="line">    <span class="keyword">int</span> *m;</span><br><span class="line">    <span class="keyword">int</span> *aOffset;</span><br><span class="line">    Float *a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FourierBSDFTable Public Methods</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Read</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;filename, FourierBSDFTable *table)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里提一下上面的成员变量的作用：</p>
<ul>
<li><code>eta</code>：材质内部折射指数和外部折射指数的比值；</li>
<li><code>mMax</code>：公式$(23)$中的$m$的最大值；</li>
<li><code>nChannels</code>：指明保存的傅里叶系数是几通道的，如果是$1$通道则为单色光谱，如果是$3$通道则$a_k$分别存储的是光亮度通道、红色通道和蓝色通道；</li>
<li><code>nMu</code>：$\mu$的离散量化数量；</li>
<li><code>mu</code>：存储$\mu$的<code>nMu</code>个离散量化的值，为数组，从小到大有序，因此对于给定的$u$，可以使用二分查找算法；</li>
<li><code>m</code>：一共有<code>nMu*nMu</code>对$(\mu_i,\mu_o)$，每一对都有各自的$m$值，用该数组保存，大小为<code>nMu*nMu</code>；</li>
<li><code>aOffset</code>：因为对于每一对$(\mu_i,\mu_o)$，$m$的大小不一，因此有必要指出当前$(\mu_i,\mu_o)$的第一个傅里叶系数$a$得起始下标，该数组就保存了对应的起始下标，大小为<code>nMu*nMu</code>；</li>
<li><code>a</code>：保存所有的傅里叶系数。</li>
</ul>
<p>&emsp;&emsp;设$(\mu_i,\mu_o)$对应的离散量化下标为<code>(offsetI,offsetO)</code>，则获取对应的<code>m</code>和傅里叶系数的起始地址的代码如下，从该起始地址开始，后面的<code>m</code>个值均属于该$(\mu_i,\mu_o)$的傅里叶系数（这里说的是单色通道情况，而如果是三通道，则<code>[0,m）</code>为光亮度通道，<code>[m,2m)</code>为红色通道，<code>[2m,3m)</code>为蓝色通道）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Float *<span class="title">GetAk</span><span class="params">(<span class="keyword">int</span> offsetI, <span class="keyword">int</span> offsetO, <span class="keyword">int</span> *mptr)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    *mptr = m[offsetO * nMu + offsetI];</span><br><span class="line">    <span class="keyword">return</span> a + aOffset[offsetO * nMu + offsetI];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;现在有个问题就是对于给定的$\mu$，找到其所在的量化区间后，如何计算其对应的傅里叶系数值（因为$\mu$很少刚刚好等于某个量化值）。这里采用Catmull-Rom样条插值，因此需要计算相应的插值权重，Catmull-Rom样条插值这里就不赘述了，下面的<code>GetWeightsAndOffset</code>实现了插值权重的计算，顺带计算相应的插值点的索引<code>offset</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> FourierBSDFTable::GetWeightsAndOffset(Float cosTheta, <span class="keyword">int</span> *offset,</span><br><span class="line">                                           Float weights[<span class="number">4</span>]) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CatmullRomWeights(nMu, mu, cosTheta, offset, weights);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;利用$\mu_i$和$\mu_o$的双Catmull-Rom样条插值，计算$a_k$如下，以$\mu_i$为例，$o_i$就是上面计算得到的<code>offset</code>，$w_i$就是上面的<code>weights</code>：</p>
<script type="math/tex; mode=display">
a_k=\sum_{a=0}^3\sum_{b=0}^3 a_k(o_i+a,o_o+b)w_i(a)w_o(b)</script><p>&emsp;&emsp;有了以上的铺垫，我们就可以从BSDF查找表中计算傅里叶系数，然后再用公式$(23)$计算BSDF函数值，创建一个<code>FourierBSDF</code>实现该BSDF函数如下，<code>bsdfTable</code>就是BSDF查找表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourierBSDF</span> :</span> <span class="keyword">public</span> BxDF &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// FourierBSDF Public Methods</span></span><br><span class="line">    <span class="function">Spectrum <span class="title">f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    FourierBSDF(<span class="keyword">const</span> FourierBSDFTable &amp;bsdfTable, TransportMode mode)</span><br><span class="line">        : BxDF(BxDFType(BSDF_REFLECTION | BSDF_TRANSMISSION | BSDF_GLOSSY)),</span><br><span class="line">          bsdfTable(bsdfTable),</span><br><span class="line">          mode(mode) &#123;&#125;</span><br><span class="line">    <span class="function">Spectrum <span class="title">Sample_f</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, Vector3f *wi, <span class="keyword">const</span> Point2f &amp;u,</span></span></span><br><span class="line"><span class="function"><span class="params">                      Float *pdf, BxDFType *sampledType)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Float <span class="title">Pdf</span><span class="params">(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// FourierBSDF Private Data</span></span><br><span class="line">    <span class="keyword">const</span> FourierBSDFTable &amp;bsdfTable;</span><br><span class="line">    <span class="keyword">const</span> TransportMode mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在<code>FourierBSDF::f</code>接口中，我们根据输入的<code>wo</code>和<code>wi</code>查找相应的傅里叶系数，然后根据这些系数计算并返回BSDF值。<code>f</code>的实现主要分成以下几步，首先计算$\mu_i$和$\mu_o$以及$\phi=\phi_i-\phi_o$，这里为了效率，仅计算了$cos\phi$：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Spectrum FourierBSDF::f(<span class="keyword">const</span> Vector3f &amp;wo, <span class="keyword">const</span> Vector3f &amp;wi) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// Find the zenith angle cosines and azimuth difference angle</span></span><br><span class="line">    Float muI = CosTheta(-wi), muO = CosTheta(wo);</span><br><span class="line">    Float cosPhi = CosDPhi(-wi, wo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute Fourier coefficients $a_k$ for $(\mui, \muo)$</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine offsets and weights for $\mui$ and $\muo$</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate storage to accumulate _ak_ coefficients</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Accumulate weighted sums of nearby $a_k$ coefficients</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Evaluate Fourier expansion for angle $\phi$</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update _scale_ to account for adjoint light transport</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后，分别查找$\mu_i$和$\mu_o$对应的量化下标<code>offsetI</code>和<code>offsetO</code>以及样条插值权重<code>weightsI</code>和<code>weights</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine offsets and weights for $\mui$ and $\muo$</span></span><br><span class="line"><span class="keyword">int</span> offsetI, offsetO;</span><br><span class="line">Float weightsI[<span class="number">4</span>], weightsO[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span> (!bsdfTable.GetWeightsAndOffset(muI, &amp;offsetI, weightsI) ||</span><br><span class="line">    !bsdfTable.GetWeightsAndOffset(muO, &amp;offsetO, weightsO))</span><br><span class="line">    <span class="keyword">return</span> Spectrum(<span class="number">0.f</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;分配好空间，以保存接下来计算得到的$a_k$系数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate storage to accumulate _ak_ coefficients</span></span><br><span class="line">Float *ak = ALLOCA(Float, bsdfTable.mMax * bsdfTable.nChannels);</span><br><span class="line"><span class="built_in">memset</span>(ak, <span class="number">0</span>, bsdfTable.mMax * bsdfTable.nChannels * <span class="keyword">sizeof</span>(Float));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用前面计算好的样条插值权重计算$a_0,a_1,…,a_{m-1}$：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accumulate weighted sums of nearby $a_k$ coefficients</span></span><br><span class="line"><span class="keyword">int</span> mMax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; <span class="number">4</span>; ++b) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">4</span>; ++a) &#123;</span><br><span class="line">        <span class="comment">// Add contribution of _(a, b)_ to $a_k$ values</span></span><br><span class="line">        Float weight = weightsI[a] * weightsO[b];</span><br><span class="line">        <span class="keyword">if</span> (weight != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m;</span><br><span class="line">            <span class="keyword">const</span> Float *ap = bsdfTable.GetAk(offsetI + a, offsetO + b, &amp;m);</span><br><span class="line">            mMax = <span class="built_in">std</span>::max(mMax, m);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; bsdfTable.nChannels; ++c)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)</span><br><span class="line">                    ak[c * bsdfTable.mMax + k] += weight * ap[c * m + k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据$a_0,a_1,…,a_{m-1}$计算公式$\sum_{k=0}^{m-1}a_k(\mu_i,\mu_o)cos(k(\phi_i-\phi_o))$（即下面的<code>Fourier</code>方法），并乘上一个$1/|\mu_i|$复原BSDF函数值，如果是三通道则要多调用两次<code>Fourier</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Evaluate Fourier expansion for angle $\phi$</span></span><br><span class="line">   Float Y = <span class="built_in">std</span>::max((Float)<span class="number">0</span>, Fourier(ak, mMax, cosPhi));</span><br><span class="line">   Float scale = muI != <span class="number">0</span> ? (<span class="number">1</span> / <span class="built_in">std</span>::<span class="built_in">abs</span>(muI)) : (Float)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update _scale_ to account for adjoint light transport</span></span><br><span class="line">   <span class="keyword">if</span> (mode == TransportMode::Radiance &amp;&amp; muI * muO &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">float</span> eta = muI &gt; <span class="number">0</span> ? <span class="number">1</span> / bsdfTable.eta : bsdfTable.eta;</span><br><span class="line">       scale *= eta * eta;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (bsdfTable.nChannels == <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> Spectrum(Y * scale);</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// Compute and return RGB colors for tabulated BSDF</span></span><br><span class="line">       Float R = Fourier(ak + <span class="number">1</span> * bsdfTable.mMax, mMax, cosPhi);</span><br><span class="line">       Float B = Fourier(ak + <span class="number">2</span> * bsdfTable.mMax, mMax, cosPhi);</span><br><span class="line">       Float G = <span class="number">1.39829f</span> * Y - <span class="number">0.100913f</span> * B - <span class="number">0.297375f</span> * R;</span><br><span class="line">       Float rgb[<span class="number">3</span>] = &#123;R * scale, G * scale, B * scale&#125;;</span><br><span class="line">       <span class="keyword">return</span> Spectrum::FromRGB(rgb).Clamp();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里略提一下<code>Fourier</code>的实现，它本质上就是计算$\sum_{k=0}^m a_kcos(k\phi)$，但是考虑到<code>cos</code>函数的计算量，这里做了一些优化。注意到$cos(k\phi)=(2cos\phi)cos((k-1)\phi)-cos((k-2)\phi)$，那么可以通过动态规划的形式从<code>k=0</code>开始循环，保存上两次的$cos((k-1)\phi)$和$cos((k-2)\phi)$，避免了多次调用<code>cos</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Float <span class="title">Fourier</span><span class="params">(<span class="keyword">const</span> Float *a, <span class="keyword">int</span> m, <span class="keyword">double</span> cosPhi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> value = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// Initialize cosine iterates</span></span><br><span class="line">    <span class="keyword">double</span> cosKMinusOnePhi = cosPhi;</span><br><span class="line">    <span class="keyword">double</span> cosKPhi = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">        <span class="comment">// Add the current summand and update the cosine iterates</span></span><br><span class="line">        value += a[k] * cosKPhi;</span><br><span class="line">        <span class="keyword">double</span> cosKPlusOnePhi = <span class="number">2</span> * cosPhi * cosKPhi - cosKMinusOnePhi;</span><br><span class="line">        cosKMinusOnePhi = cosKPhi;</span><br><span class="line">        cosKPhi = cosKPlusOnePhi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>&emsp;&emsp;在这里我们讨论了完美镜面反射和透射的BSDF模型、Lambertian漫反射BSDF模型、Oren-Nayar漫反射模型、Torrance-Sparrow镜面散射模型、Ashikhmin-Shirley反射模型和基于查找表思想的傅里叶基形式的BSDF模型，其中Oren-Nayar漫反射模型、Torrance-Sparrow镜面散射模型和Ashikhmin-Shirley反射模型都基于微平面理论，实现了诸如glossy镜面反射、更加真实的漫反射等效果。涵盖了绝大部分的BSDF，物体的材质大都是这些BSDF模型的一个或多个的组合。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>$[1]$ M, Jakob W, Humphreys G. Physically based rendering: From theory to implementation[M]. Morgan Kaufmann, 2016.</p>

        </div>
        
          


  <section class="meta" id="footer-meta">
    <hr>
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-04-19T21:53:33+08:00">
  <a class="notlink">
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>最后更新于 2020年4月19日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Computer-Graphics/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Computer Graphics</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Ray-Tracer/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Ray Tracer</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yangwc.com/2020/04/15/Scattering/&title=Physically Based Rendering：散射模型 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=光线散射模型描述了光线碰撞到物体表面时以什么方式、什么方向进行反射、折射，在这里暂时不考虑次表面散射现象。光线的反射用BRDF函数描述，而透射则用BTDF函数描述，两者统一起来称为BSDF函数（双线散射分布函数）。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://yangwc.com/2020/04/15/Scattering/&title=Physically Based Rendering：散射模型 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=光线散射模型描述了光线碰撞到物体表面时以什么方式、什么方向进行反射、折射，在这里暂时不考虑次表面散射现象。光线的反射用BRDF函数描述，而透射则用BTDF函数描述，两者统一起来称为BSDF函数（双线散射分布函数）。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=https://yangwc.com/2020/04/15/Scattering/&title=Physically Based Rendering：散射模型 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=光线散射模型描述了光线碰撞到物体表面时以什么方式、什么方向进行反射、折射，在这里暂时不考虑次表面散射现象。光线的反射用BRDF函数描述，而透射则用BTDF函数描述，两者统一起来称为BSDF函数（双线散射分布函数）。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                            <h4>
                                <a href="/2020/04/19/VolumeScattering/" rel="prev" title="Physically Based Rendering：体积散射">
                                  
                                      Physically Based Rendering：体积散射
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Ray-Tracer/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Ray Tracer</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2020/04/11/Sampling3/" rel="prev" title="Physically Based Rendering：采样和重建（三）">
                                    
                                        Physically Based Rendering：采样和重建（三）
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Ray-Tracer/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Ray Tracer</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
        <section id="comments">
          <div id="lv-container" data-id="city" data-uid="MTAyMC80MzkxOS8yMDQ1NQ==">
            <noscript><div><i class="fas fa-exclamation-triangle">&nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。</i></div></noscript>
          </div>
        </section>
      
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

  <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



  <script>
    window.subData = {
      title: 'Physically Based Rendering：散射模型',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content material">
    
      <div class="avatar">
        <fancybox><img class="avatar" src="/image/avator.jpg"></fancybox>
      </div>
    
    
      <div class="text">
        
          <h2>YangWC</h2>
        
        
          <p>Enjoy Computer Graphics!</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget toc-wrapper">
    
<header class="material">
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class="content material">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、相关术语"><span class="toc-text">一、相关术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、散射函数接口"><span class="toc-text">二、散射函数接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、镜面反射和透射"><span class="toc-text">三、镜面反射和透射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、菲涅尔反射方程"><span class="toc-text">1、菲涅尔反射方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、完美镜面反射"><span class="toc-text">2、完美镜面反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、完美镜面透射"><span class="toc-text">3、完美镜面透射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、综合反射与透射"><span class="toc-text">4、综合反射与透射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Lambertian漫反射"><span class="toc-text">四、Lambertian漫反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、基于微平面的散射模型"><span class="toc-text">五、基于微平面的散射模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、Oren-Nayar漫反射"><span class="toc-text">1、Oren-Nayar漫反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、法线分布函数"><span class="toc-text">2、法线分布函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、几何遮蔽函数"><span class="toc-text">3、几何遮蔽函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、Torrance-Sparrow镜面散射"><span class="toc-text">4、Torrance-Sparrow镜面散射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、Ashikhmin-Shirley反射"><span class="toc-text">六、Ashikhmin-Shirley反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、傅里叶基下的BSDF查找表"><span class="toc-text">七、傅里叶基下的BSDF查找表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、总结"><span class="toc-text">八、总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class="widget plain">
  
<header class="material">
  <div><i class=" fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;欢迎来到YangWC的博客</div>
  
</header>

  <div class="content material">
    <p>本站会记录自己的一些学习内容，如若有错或者乱码，欢迎指正，感谢!</p>

  </div>
</section>

          
        
      
        
          
          
            <section class="widget grid">
  
<header class="material">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content material">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于博主
        </a></li>
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn" rel="nofollow" href="/categories/" title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/2D-Rendering/" href="/categories/2D-Rendering/"><div class="name">2D Rendering</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Computer-Graphics/" href="/categories/Computer-Graphics/"><div class="name">Computer Graphics</div><div class="badge">(36)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-Simulation/" href="/categories/Fluid-Simulation/"><div class="name">Fluid Simulation</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-simulation/" href="/categories/Fluid-simulation/"><div class="name">Fluid  simulation</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Image-processing/" href="/categories/Image-processing/"><div class="name">Image processing</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/N-body/" href="/categories/N-body/"><div class="name">N-body</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physical-simulation/" href="/categories/Physical-simulation/"><div class="name">Physical simulation</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physically-Based-Rendering/" href="/categories/Physically-Based-Rendering/"><div class="name">Physically Based Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Position-Based-Dynamics/" href="/categories/Position-Based-Dynamics/"><div class="name">Position Based Dynamics</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Ray-Tracer/" href="/categories/Ray-Tracer/"><div class="name">Ray Tracer</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Real-time-Rendering/" href="/categories/Real-time-Rendering/"><div class="name">Real-time Rendering</div><div class="badge">(6)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Soft-Renderer/" href="/categories/Soft-Renderer/"><div class="name">Soft Renderer</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Voxelization/" href="/categories/Voxelization/"><div class="name">Voxelization</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class="widget tagcloud">
    
<header class="material">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn" rel="nofollow" href="/tags/" title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <a href="/tags/2D-Rendering/" style="font-size: 14px; color: #bbb">2D Rendering</a> <a href="/tags/3D-Math/" style="font-size: 14px; color: #bbb">3D Math</a> <a href="/tags/3D-pipeline/" style="font-size: 15.67px; color: #c6c6c6">3D pipeline</a> <a href="/tags/Advection/" style="font-size: 14px; color: #bbb">Advection</a> <a href="/tags/Computer-Graphics/" style="font-size: 24px; color: #fff">Computer Graphics</a> <a href="/tags/Fluid-Simulation/" style="font-size: 22.33px; color: #f4f4f4">Fluid Simulation</a> <a href="/tags/Fluid-simulation/" style="font-size: 14px; color: #bbb">Fluid simulation</a> <a href="/tags/Glow-effect/" style="font-size: 14px; color: #bbb">Glow effect</a> <a href="/tags/Image-processing/" style="font-size: 14px; color: #bbb">Image processing</a> <a href="/tags/N-body/" style="font-size: 14px; color: #bbb">N-body</a> <a href="/tags/Naiver-Stokes-Equations/" style="font-size: 14px; color: #bbb">Naiver-Stokes Equations</a> <a href="/tags/Physical-simulation/" style="font-size: 14px; color: #bbb">Physical simulation</a> <a href="/tags/Physically-Based-Rendering/" style="font-size: 15.67px; color: #c6c6c6">Physically Based Rendering</a> <a href="/tags/Position-Based-Dynamics/" style="font-size: 17.33px; color: #d2d2d2">Position Based Dynamics</a> <a href="/tags/Rasterization/" style="font-size: 14px; color: #bbb">Rasterization</a> <a href="/tags/Ray-Tracer/" style="font-size: 22.33px; color: #f4f4f4">Ray Tracer</a> <a href="/tags/Real-time-Rendering/" style="font-size: 20.67px; color: #e8e8e8">Real-time Rendering</a> <a href="/tags/Soft-Renderer/" style="font-size: 19px; color: #ddd">Soft Renderer</a> <a href="/tags/Voxelization/" style="font-size: 14px; color: #bbb">Voxelization</a>
    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
	<script>
		var now = new Date(); 
		function createtime() { 
			var grt= new Date("04/24/2019 18:00:00");//在此处修改你的建站时间
			now.setTime(now.getTime()+250); 
			days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
			hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
			if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
			mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
			seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
			snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
			document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
			document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
		} 
	setInterval("createtime()",250);
   </script>
   
   <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->
	
	
	<script>setLoadingBarProgress(80);</script>
</footer>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>









  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>






  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  
    <!--数字雨背景-->
  <canvas id="canvas" width="1440" height="900" ></canvas>
  <script>
	var s = window.screen;
	var width = canvas.width = s.width;
	var height = canvas.height = s.height;
	var fontSize = 13;
	var colunms = Math.floor(width/fontSize);
	var letters = [];
    for(var i=0;i<colunms;i++){
        letters.push(1);
    }
	var draw = function () {
	    canvas.getContext('2d').fillStyle = "rgba(0,0,0,.08)";//遮盖层
		canvas.getContext('2d').fillRect(0,0,width,height);
		canvas.getContext('2d').font = "700 " + fontSize +"px  微软雅黑";
		letters.map(function(y_pos, index){
		text = String.fromCharCode(34+Math.random()*33);
		x_pos = index * fontSize;
		canvas.getContext('2d').fillText(text, x_pos, y_pos);
		letters[index] = (y_pos > 758 + Math.random() * 1e4) ? 0 : y_pos + 10;
		canvas.getContext('2d').fillStyle='#'+letters[index];
	  });
	};
	setInterval(draw, 33);
  </script>
  
  <!-- 页面点击出现文字 -->
  <script type="text/javascript" src="/js/ClickShowText.js"></script>
  
  <script>setLoadingBarProgress(100);</script>
</body>
</html>
