<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>空间管理Space management：四叉树 &amp; 八叉树 | YangWC&#39;s Blog</title>
  
  
  <meta name="description" content="Personal blog website.">
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/logo.ico">
  

  
    <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fdf716664defeee80e01568ddbeb2425";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
  
</head>
<body>
  
  
  <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          YangWC's Blog
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
									<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/" id="home">
									<i class="fas fa-grin fa-fw"></i>&nbsp;博客
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
									<i class="fas fa-tag fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-grin fa-fw"></i>&nbsp;博客
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
								<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
								<i class="fas fa-tag fa-fw"></i>&nbsp;标签
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      <div class="l_main">
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2020/01/10/Octree/">
        空间管理Space management：四叉树 & 八叉树
      </a>
    </h1>
  


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="https://yangwc.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2020-01-10</p>
  </a>
</div>

          
        
          
            
  
  <div class="new-meta-item category">
    <a href="/categories/Ray-Tracer/" rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Computer Graphics&nbsp;/&nbsp;Ray Tracer</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p>又是好久没更新博客了，最近在写算法分析与设计课程的期末作业，作业的题目随意，我就随兴写了烟花粒子的四叉树可视化程序和光追渲染器的八叉树求交优化。之前写的光追渲染器对每个三角网格模型的求交都是暴力遍历所有的三角形，对于三角形数量很多的模型来说效率非常低，所以我捡起了这个渲染器并为每个三角网格模型构建一颗八叉树加快射线与三角形的求交速度。还真别说，性能提升巨大。所以这篇博客本质上是一个期末作业。最后，新年快乐！</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.30/blog/Octree/header.jpg" width="99%"></div></p>
<a id="more"></a>
<p>&emsp;&emsp;分治算法因其巧妙的算法思想能够将算法的时间复杂度降低到一个非常低的程度，例如广为流传的二分搜索算法将线性搜索时间复杂度$O(n)$降低到了$O(log\ n)$，这是一个极其恐怖的性能提升。诸多的实际应用领域例如计算机图形学、计算机视觉都有着分治算法的身影。在这里我们将重点关注计算机图形学领域非常实用、好用、高效的分治算法——四叉树空间分割算法和八叉树空间分割算法，二分搜索算法本质上处理的是一维的数据，但在图形学领域我们通常面临的是二维或者三维的点和向量，而且在实际应用中这些数据的量都非常庞大（几百万个点的点云、高精度的网格模型等等），因此为了加速这些更高维数据的搜索，一些高效的数据结构算法被提出，其中四叉树和八叉树算法就是其中之一。（当然也有高维的二叉树，例如k-d树）</p>
<h2 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h2><p>&emsp;&emsp;我们先来看一下算法的应用背景，计算机图形学领域研究的主要内容就是关于二维三维空间的图形绘制、物理模拟、几何建模、电脑动画等等可视化课题，目前最为流行的模型表示方法就是采用三角形网格模型，即每个网格面采用一个三角形来表示，如下图1所示：</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.30/blog/Octree/1.jpg" width="36%"></div></p>
<center> 图1 三角网格模型 </center>
&emsp;&emsp;这种表示方法就是采用了有限元的思想，利用很多个三角形去逼近一个曲面，三角形越多，网格精度越高，模型越接近目标物体。在一个大型的场景中，通常有很多个这样的物体模型，因此采用暴力的方法遍历每一个物体送入绘制管线、碰撞检测等等是非常不可行的，特别是对于游戏、虚拟现实等等实时性要求比较高的应用来说这是灾难性的做法，暴力搜索策略的碰撞检测将耗费大部分的时间。除了碰撞检测之外，还有射线与物体的求交运算，即发射一条射线，找到射线与物体相交的一点，这个在射击游戏中非常常见，此外在基于光线追踪的图形渲染技术中亦是如此。暴力、简单的做法就是将射线方程与场景中的每个三角形进行数学上的交点求取运算（其实就是解一个方程），遍历完所有的三角形，取一个最近的交点就是最终结果，算法复杂度为$O(n)$。这种方法不可取，复杂场景中的三角形数量几千万甚至上亿，在每一帧进行这样求交运算带来的后果就是帧率的急剧降低，用户看到的画面将非常卡顿，毫无流畅的游戏体验感。

&emsp;&emsp;事实上，可以很容易理解，射线并不会与场景中所有的三角形相交，暴力遍历的算法有$99.9\%$的计算量都在做无用功，因为在所有的三角形中只有一个三角形才是我们要寻找的会相交的、距离最最近的那个三角形。注意到这些，学者们提出了一些基于分治的空间分割算法思想，将二维空间、三维空间做一个划分，排除点那些不可能相交的三角形，加速整个搜索过程。在众多的空间分割算法中，四叉树和八叉树的算法是其中的一种简单、高效、好用的空间分割算法，其中四叉树对应的是二维的空间划分，而八叉树对应的是三维的空间划分，算法的思想并不难理解，本质上属于二分搜索的高维扩展。 四叉树和八叉树就是$2D$和$3D$的“二分法”，搜索过程与二叉树搜索也类似，二叉树中是将数组排序后存入二叉树中，从而在查找中实现时间复杂度为$log\ n$。而四叉树/八叉树是按平面/空间范围划分有序节点，将所有点/面片/网格模型放入所属节点中，达到类似于排序的结果，进而在搜索时可以快速排除掉那些不符合条件的 点/面片/网格模型。



## 二、四叉树分割算法

&emsp;&emsp;四叉树或四元树也被称为Q树（QuadTree）。四叉树广泛应用于图像处理、空间数据索引、2D中的快速碰撞检测、存储稀疏数据等，而八叉树（Octree）主要应用于3D图形处理。



#### 1、四叉树分割算法——原理

&emsp;&emsp;四叉树索引的基本思想是将地理空间递归划分为不同层次的树结构。它将已知范围的空间等分成四个相等的子空间，如此递归下去，直至树的层次达到一定深度或者满足某种要求（例如数据对象数量少于一定的阈值）后停止分割。四叉树的结构比较简单，并且当空间数据对象分布比较均匀时，具有比较高的空间数据插入和查询效率，因此四叉树是GIS中常用的空间索引之一。常规四叉树的结构如图所示。



<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.30/blog/Octree/2.png" width="60%">

<center> 图2 一颗构建好的四叉树 </center>
&emsp;&emsp;这里划分空间通常是一个轴向包围盒，这个包围盒可以用它的最低点和最高点来表示。总的来说，四叉树的定义是：它的每个节点下至多可以有四个子节点，通常把一部分二维空间细分为四个象限或区域并把该区域里的相关信息存入到四叉树节点中。 四叉树的每一个节点代表一个矩形区域，每一个矩形区域又可划分为四个小矩形区域，这四个小矩形区域作为四个子节点所代表的矩形区域。

&emsp;&emsp;这里的四叉树只有叶子节点才存储数据对象（如点、三角面片、网格模型等等），内部节点不存储数据对象，因而访问数据对象都要根据内部节点走到叶子节点去访问。一般点是没有大小的，因此数据对象是点的时候没有必要考虑跨越了多个区域的情况。而如果数据对象是面片、网格模型等有大小的时，四叉树的构建就需要小心一点。如图2所示，数据对象是一个矩形，每个矩形有一定的大小，图中的$2$、$4$、$8$这三个数据对象跨越了两个区域，为了防止遗漏，在构建四叉树的时候最好把这些跨越了多个区域的数据对象均放入它所涉及到的叶子节点上。一般情况下叶子节点不会直接存储原始的数据对象，而是将原始的数据对象用一个线性表存储，然后四叉树中的叶子节点存储的是数据对象在线性表中的索引，这是为了防止程序代码耦合度过高。

&emsp;&emsp;说了这么多，接下来我们以构建烟花粒子系统的四叉树为例展开相关的算法介绍和实现。烟花粒子系统中的数据对象是粒子点云，即点集，我们为这个系统构建一颗四叉树，并将其可视化出来。首先定义四叉树中的一个节点对象，代码如下所示。一个节点对象可能是内部节点，也可能是外部节点。对于内部节点，它应该有四个子节点的指针；对于叶子节点，它应该有一个存储数据对象的表。对于每一个节点，都应该有一个包围盒指定当前节点所覆盖的矩形空间范围，我们用矩形空间范围的最小点和最大点来表示。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//! 子节点</span></span><br><span class="line">	TreeNode *children[<span class="number">4</span>];</span><br><span class="line">	<span class="comment">//! 包围盒</span></span><br><span class="line">	glm::vec2 bMin, bMax;</span><br><span class="line">	<span class="comment">//! 叶节点的物体列表</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec2&gt; objects;</span><br><span class="line">	<span class="comment">//! 是否是叶节点</span></span><br><span class="line">	<span class="keyword">bool</span> isLeaf;</span><br><span class="line"></span><br><span class="line">	TreeNode() :</span><br><span class="line">		isLeaf(<span class="literal">false</span>), bMin(glm::vec2(<span class="number">0.0f</span>)), bMax(glm::vec2(<span class="number">0.0f</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		children[<span class="number">0</span>] = children[<span class="number">1</span>] = children[<span class="number">2</span>] = children[<span class="number">3</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TreeNode(glm::vec2 min, glm::vec2 max) :</span><br><span class="line">		isLeaf(<span class="literal">false</span>), bMin(min), bMax(max)</span><br><span class="line">	&#123;</span><br><span class="line">		children[<span class="number">0</span>] = children[<span class="number">1</span>] = children[<span class="number">2</span>] = children[<span class="number">3</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

#### 2、四叉树分割算法——构建

&emsp;&emsp;从一颗空树开始，给定粒子系统中所有的粒子点云的线性表，我们采用自顶向下的方式构建一颗四叉树。从根节点往下划分，直到到达给定的树的深度或者当前节点覆盖的数据对象少于一定的数量时不再往下划分。根据数据对象数量、当前节点的深度，自顶向下构建四叉树的过程大致可以分成三类：

- 如果当前数据对象数量为零，代表当前节点覆盖的区域不包含任何数据对象，则返回空指针，表示当前节点是一个不包含任何对象的空指针节点；
- 如果当前数据对象不为零且小于一定的数量，亦或者当前节点的深度达到最大深度，则不再往下划分，将当前的节点构建为叶子节点，并将数据对象添加到叶子节点的存储表中；
- 出去上面的两种情况，剩下的情况就是当前节点为内部节点的情况，对于每一个内部节点，需要往下划分四个区域节点，我们根据当前区域的范围分割成上、下、左、右四个子区域，根据数据对象的位置将数据对象表分成四类，递归调用构建函数，返回子节点的指针，最后再返回当前内部节点的指针。

&emsp;&emsp;以上的步骤递归嵌套地执行，即可完成自顶向下的四叉树构建。详细的代码实现如下所示，这个函数的输入是当前节点的深度，当前节点的矩形范围以及数据对象列表，返回构建的节点指针。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">TreeNode * QuadTree::recursiveBuild(<span class="keyword">unsigned</span> <span class="keyword">int</span> depth, glm::vec2 min, glm::vec2 max,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec2&gt;&amp; objects)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//! if there is no object at all, just return nullptr.</span></span><br><span class="line">	<span class="keyword">if</span> (objects.empty())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! if the number of objects is less than 10 or reach the maxDepth,</span></span><br><span class="line">	<span class="comment">//! just create the node as leaf and return it.</span></span><br><span class="line">	<span class="keyword">if</span> (objects.size() &lt; <span class="number">4</span> || depth == mMaxDepth)</span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode *cur = <span class="keyword">new</span> TreeNode(min, max);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;point : objects)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (isContain(point, min, max))</span><br><span class="line">				cur-&gt;objects.push_back(point);</span><br><span class="line">		&#125;</span><br><span class="line">		cur-&gt;isLeaf = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! otherwise just subdivied into four sub nodes.</span></span><br><span class="line">	glm::vec2 center = (min + max) * <span class="number">0.5f</span>;</span><br><span class="line">	<span class="keyword">float</span> length = <span class="built_in">std</span>::max(max.x - min.x, max.y - min.y);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------</span></span><br><span class="line">	<span class="comment">// | 3 | 2 |</span></span><br><span class="line">	<span class="comment">// ---------</span></span><br><span class="line">	<span class="comment">// | 0 | 1 |</span></span><br><span class="line">	<span class="comment">// ---------</span></span><br><span class="line">	glm::vec2 subMin[<span class="number">4</span>];</span><br><span class="line">	glm::vec2 subMax[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! get the four subnodes' region.</span></span><br><span class="line">	subMin[<span class="number">0</span>] = min;</span><br><span class="line">	subMax[<span class="number">0</span>] = center;</span><br><span class="line">	subMin[<span class="number">1</span>] = center - glm::vec2(<span class="number">0.0f</span>, length / <span class="number">2</span>);</span><br><span class="line">	subMax[<span class="number">1</span>] = center + glm::vec2(length / <span class="number">2</span>, <span class="number">0.0f</span>);</span><br><span class="line">	subMin[<span class="number">2</span>] = center;</span><br><span class="line">	subMax[<span class="number">2</span>] = max;</span><br><span class="line">	subMin[<span class="number">3</span>] = min + glm::vec2(<span class="number">0.0f</span>, length / <span class="number">2</span>);</span><br><span class="line">	subMax[<span class="number">3</span>] = center + glm::vec2(<span class="number">0.0f</span>, length / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! subdivide the objects into four classes according to their positions.</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec2&gt; classes[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;point : objects)</span><br><span class="line">	&#123;s</span><br><span class="line">		<span class="keyword">if</span> (isContain(point, subMin[<span class="number">0</span>], subMax[<span class="number">0</span>]))</span><br><span class="line">			classes[<span class="number">0</span>].push_back(point);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (isContain(point, subMin[<span class="number">1</span>], subMax[<span class="number">1</span>]))</span><br><span class="line">			classes[<span class="number">1</span>].push_back(point);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (isContain(point, subMin[<span class="number">2</span>], subMax[<span class="number">2</span>]))</span><br><span class="line">			classes[<span class="number">2</span>].push_back(point);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (isContain(point, subMin[<span class="number">3</span>], subMax[<span class="number">3</span>]))</span><br><span class="line">			classes[<span class="number">3</span>].push_back(point);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! allocate memory for current node.</span></span><br><span class="line">	TreeNode *cur = <span class="keyword">new</span> TreeNode(min, max);</span><br><span class="line">	cur-&gt;children[<span class="number">0</span>] = recursiveBuild(depth + <span class="number">1</span>, subMin[<span class="number">0</span>], subMax[<span class="number">0</span>], classes[<span class="number">0</span>]);</span><br><span class="line">	cur-&gt;children[<span class="number">1</span>] = recursiveBuild(depth + <span class="number">1</span>, subMin[<span class="number">1</span>], subMax[<span class="number">1</span>], classes[<span class="number">1</span>]);</span><br><span class="line">	cur-&gt;children[<span class="number">2</span>] = recursiveBuild(depth + <span class="number">1</span>, subMin[<span class="number">2</span>], subMax[<span class="number">2</span>], classes[<span class="number">2</span>]);</span><br><span class="line">	cur-&gt;children[<span class="number">3</span>] = recursiveBuild(depth + <span class="number">1</span>, subMin[<span class="number">3</span>], subMax[<span class="number">3</span>], classes[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

&emsp;&emsp;这里需要提一点的是上面代码中的$isContain$函数，它输入一个点和一个矩形包围盒范围，判断这个点是否在这个矩形包围盒之内，这个判断很简单，不再赘述。我们来看一下这种自顶向下构建方法的时间复杂度。四叉树的**每一层**都会处理$O(N)$个数据对象，若数据分布的比较均匀，则树高为$O(log_4 N)$，因此构建的时间复杂度为$O(N log_4 N)$，乍一看比暴力方法的时间复杂度还要高，但我们对每一个数据对象没有做很复杂的数据运算（如射线求交、碰撞检测等等），而且构建只需一次，对于那些检索密集型的应用来说非常划算。



#### 3、四叉树分割算法——销毁

&emsp;&emsp;我们采用四叉链表结构作为四叉树的实现方式，涉及到大量的动态指针，在销毁时需要手动释放这些指针占用堆空间。销毁四叉树并不难，直接采用**后序遍历**方法即可，后序遍历即先销毁子节点，将子节点指针置空，然后再销毁父节点，如此递归下去。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QuadTree::recursiveDestory(TreeNode *node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	recursiveDestory(node-&gt;children[<span class="number">0</span>]);</span><br><span class="line">	recursiveDestory(node-&gt;children[<span class="number">1</span>]);</span><br><span class="line">	recursiveDestory(node-&gt;children[<span class="number">2</span>]);</span><br><span class="line">	recursiveDestory(node-&gt;children[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> node;</span><br><span class="line">	node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 4、四叉树分割算法——插入

&emsp;&emsp;除了前面提到的给定数据对象列表直接自顶向下构建整颗四叉树，还有一种构建方法是动态插入法。即给一个数据对象，将其插入到四叉树的一个叶子节点上，可以称为逐个插入法。逐个插入法就是要找到输入的数据对象所在的四叉树叶子节点，然后将该数据对象添加到该叶子节点的数据对象列表上。插入过程要靠的情况稍微多一点，如果插入的叶子节点的列表长度超过了一定数量，则应该将当前的叶子节点分裂，这时它不再是叶子节点而是内部节点了，递归插入到该内部节点的叶子节点中。总的来说，插入过程分成以下几种情况：

- 若输入的数据对象不在当前节点的覆盖范围之内，直接停止插入过程；
- 如果走到了四叉树的最大深度，则一定不会再分裂，直接将该数据对象添加到节点的数据对象列表当中；
- 如果当前节点是叶子节点，将数据对象添加到该节点的数据对象列表中。然后若数据对象表列长度超过了一定数量，则需要将该叶子节点分裂，往下递归划分，将数据对象列表分散到子节点中，自己不再是叶子节点；
- 如果当前节点是内部节点，则需要确定当前的数据对象落到它的四个子节点中的哪一个，然后递归调用插入过程。

&emsp;&emsp;插入过程也不是很复杂，理清了思路就好，实现的代码如下所示，代码的输入是深度、当前节点指针、当前节点覆盖的范围以及要插入的数据对象：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QuadTree::recursiveInsert(<span class="keyword">unsigned</span> <span class="keyword">int</span> depth, TreeNode * node,</span><br><span class="line">                               glm::vec2 min, glm::vec2 max, glm::vec2 object)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!isContain(object, min, max))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	glm::vec2 center = (max + min) * <span class="number">0.5f</span>;</span><br><span class="line">	<span class="keyword">float</span> length = <span class="built_in">std</span>::max(max.x - min.x, max.y - min.y);</span><br><span class="line">	<span class="comment">//! get the four sub-nodes' region.</span></span><br><span class="line">	glm::vec2 subMin[<span class="number">4</span>];</span><br><span class="line">	glm::vec2 subMax[<span class="number">4</span>];</span><br><span class="line">	subMin[<span class="number">0</span>] = min;</span><br><span class="line">	subMax[<span class="number">0</span>] = center;</span><br><span class="line">	subMin[<span class="number">1</span>] = center - glm::vec2(<span class="number">0.0f</span>, length / <span class="number">2</span>);</span><br><span class="line">	subMax[<span class="number">1</span>] = center + glm::vec2(length / <span class="number">2</span>, <span class="number">0.0f</span>);</span><br><span class="line">	subMin[<span class="number">2</span>] = center;</span><br><span class="line">	subMax[<span class="number">2</span>] = max;</span><br><span class="line">	subMin[<span class="number">3</span>] = min + glm::vec2(<span class="number">0.0f</span>, length / <span class="number">2</span>);</span><br><span class="line">	subMax[<span class="number">3</span>] = center + glm::vec2(<span class="number">0.0f</span>, length / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! reach the max depth.</span></span><br><span class="line">	<span class="keyword">if</span> (depth == mMaxDepth)</span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;objects.push_back(object);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node-&gt;isLeaf)</span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;objects.push_back(object);</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;objects.size() &gt; <span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//! 超过四个就分裂，自己不再是叶子节点</span></span><br><span class="line">			node-&gt;children[<span class="number">0</span>] = <span class="keyword">new</span> TreeNode(subMin[<span class="number">0</span>], subMax[<span class="number">0</span>]);</span><br><span class="line">			node-&gt;children[<span class="number">1</span>] = <span class="keyword">new</span> TreeNode(subMin[<span class="number">1</span>], subMax[<span class="number">1</span>]);</span><br><span class="line">			node-&gt;children[<span class="number">2</span>] = <span class="keyword">new</span> TreeNode(subMin[<span class="number">2</span>], subMax[<span class="number">2</span>]);</span><br><span class="line">			node-&gt;children[<span class="number">3</span>] = <span class="keyword">new</span> TreeNode(subMin[<span class="number">3</span>], subMax[<span class="number">3</span>]);</span><br><span class="line">			node-&gt;isLeaf = <span class="literal">false</span>;</span><br><span class="line">			node-&gt;children[<span class="number">0</span>]-&gt;isLeaf = <span class="literal">true</span>;</span><br><span class="line">			node-&gt;children[<span class="number">1</span>]-&gt;isLeaf = <span class="literal">true</span>;</span><br><span class="line">			node-&gt;children[<span class="number">2</span>]-&gt;isLeaf = <span class="literal">true</span>;</span><br><span class="line">			node-&gt;children[<span class="number">3</span>]-&gt;isLeaf = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;point : node-&gt;objects)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (isContain(point, subMin[<span class="number">0</span>], subMax[<span class="number">0</span>]))</span><br><span class="line">					node-&gt;children[<span class="number">0</span>]-&gt;objects.push_back(point);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (isContain(point, subMin[<span class="number">1</span>], subMax[<span class="number">1</span>]))</span><br><span class="line">					node-&gt;children[<span class="number">1</span>]-&gt;objects.push_back(point);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (isContain(point, subMin[<span class="number">2</span>], subMax[<span class="number">2</span>]))</span><br><span class="line">					node-&gt;children[<span class="number">2</span>]-&gt;objects.push_back(point);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (isContain(point, subMin[<span class="number">3</span>], subMax[<span class="number">3</span>]))</span><br><span class="line">					node-&gt;children[<span class="number">3</span>]-&gt;objects.push_back(point);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec2&gt;().swap(node-&gt;objects);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! 若为内部节点，往下深入搜索</span></span><br><span class="line">	<span class="keyword">if</span> (isContain(object, subMin[<span class="number">0</span>], subMax[<span class="number">0</span>]))</span><br><span class="line">		<span class="keyword">return</span> recursiveInsert(depth + <span class="number">1</span>, node-&gt;children[<span class="number">0</span>], subMin[<span class="number">0</span>], subMax[<span class="number">0</span>], object);</span><br><span class="line">	<span class="keyword">if</span> (isContain(object, subMin[<span class="number">1</span>], subMax[<span class="number">1</span>]))</span><br><span class="line">		<span class="keyword">return</span> recursiveInsert(depth + <span class="number">1</span>, node-&gt;children[<span class="number">1</span>], subMin[<span class="number">1</span>], subMax[<span class="number">1</span>], object);</span><br><span class="line">	<span class="keyword">if</span> (isContain(object, subMin[<span class="number">2</span>], subMax[<span class="number">2</span>]))</span><br><span class="line">		<span class="keyword">return</span> recursiveInsert(depth + <span class="number">1</span>, node-&gt;children[<span class="number">2</span>], subMin[<span class="number">2</span>], subMax[<span class="number">2</span>], object);</span><br><span class="line">	<span class="keyword">if</span> (isContain(object, subMin[<span class="number">3</span>], subMax[<span class="number">3</span>]))</span><br><span class="line">		<span class="keyword">return</span> recursiveInsert(depth + <span class="number">1</span>, node-&gt;children[<span class="number">3</span>], subMin[<span class="number">3</span>], subMax[<span class="number">3</span>], object);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

&emsp;&emsp;插入一个数据对象的时间复杂就是四叉树的高度，理想情况下为$O(log_4 N)$。



#### 5、四叉树分割算法——删除

&emsp;&emsp;有插入就有删除，给定一个数据对象，我们要找到包含这个数据对象的节点，并将其从数据对象列表中删除。与插入的情况相反，删除对象的操作可能导致当前节点的数据对象列表为空，此时需要将当前节点从整颗四叉树中删除，因为它不再包含任何有效的数据。叶子节点的删除可能导致父节点的删除（全部子节点变为空指针），如此递归下去，因此需要仔细斟酌整个删除的过程。总的来说，删除过程需要考虑的情况有如下几种：

- 当前节点为空或者当前节点覆盖的范围不包含输入的数据对象，直接终止删除过程；
- 当前节点为叶子节点或者走到最大四叉树深度了，遍历当前节点的数据对象列表，找到需要删除对象的数组下标，如果没有则不执行删除操作，否则将其从数组中移除。如果移除一个对象之后的数据列表为空，则需要将其删除，返回一个标志告诉父节点将其删除；
- 当前节点为内部节点，找到包含该数据对象的子节点，递归调用删除程序，如果程序返回一个删除标志，则释放该子节点的内存。如果内部节点的四个子节点指针均为空指针，则告诉该内部节点的父节点将其删除，如果递归下去。

&emsp;&emsp;将数据对象从数组中删除一个小小的技巧就是将数组尾部的内容覆盖到该数据对象所在的位置，然后将尾部的数据删除即可，避免数据的大规模移动。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QuadTree::recursiveRemove(<span class="keyword">unsigned</span> <span class="keyword">int</span> depth, TreeNode * node, glm::vec2 min, glm::vec2 max, glm::vec2 object)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! 确保在当前节点的范围之内</span></span><br><span class="line">	<span class="keyword">if</span> (!isContain(object, min, max))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! 达到最大深度或者走到叶子节点了.</span></span><br><span class="line">	<span class="keyword">if</span> (depth == mMaxDepth || node-&gt;isLeaf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//! 找到要删除元素的位置</span></span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; node-&gt;objects.size(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="built_in">std</span>::<span class="built_in">pow</span>(node-&gt;objects[i].x - object.x, <span class="number">2</span>) + <span class="built_in">std</span>::<span class="built_in">pow</span>(node-&gt;objects[i].y - object.y, <span class="number">2</span>)) &lt; <span class="number">0.001f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				index = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//! 与最后一个元素交换，方便删除</span></span><br><span class="line">			node-&gt;objects[index] = node-&gt;objects.back();</span><br><span class="line">			node-&gt;objects.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//! 如果叶子节点空了，则告诉父节点需要将其删除掉.</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;objects.empty())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! 非叶子节点</span></span><br><span class="line">	<span class="keyword">if</span> (recursiveRemove(depth + <span class="number">1</span>, node-&gt;children[<span class="number">0</span>], node-&gt;children[<span class="number">0</span>]-&gt;bMin, node-&gt;children[<span class="number">0</span>]-&gt;bMax, object))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> node-&gt;children[<span class="number">0</span>];</span><br><span class="line">		node-&gt;children[<span class="number">0</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (recursiveRemove(depth + <span class="number">1</span>, node-&gt;children[<span class="number">1</span>], node-&gt;children[<span class="number">1</span>]-&gt;bMin, node-&gt;children[<span class="number">1</span>]-&gt;bMax, object))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> node-&gt;children[<span class="number">1</span>];</span><br><span class="line">		node-&gt;children[<span class="number">1</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (recursiveRemove(depth + <span class="number">1</span>, node-&gt;children[<span class="number">2</span>], node-&gt;children[<span class="number">2</span>]-&gt;bMin, node-&gt;children[<span class="number">2</span>]-&gt;bMax, object))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> node-&gt;children[<span class="number">2</span>];</span><br><span class="line">		node-&gt;children[<span class="number">2</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (recursiveRemove(depth + <span class="number">1</span>, node-&gt;children[<span class="number">3</span>], node-&gt;children[<span class="number">3</span>]-&gt;bMin, node-&gt;children[<span class="number">3</span>]-&gt;bMax, object))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> node-&gt;children[<span class="number">3</span>];</span><br><span class="line">		node-&gt;children[<span class="number">3</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! 父节点的全部子节点为空，自己也将被删除了</span></span><br><span class="line">	<span class="keyword">if</span> (node-&gt;children[<span class="number">0</span>] == <span class="literal">nullptr</span> &amp;&amp; node-&gt;children[<span class="number">1</span>] == <span class="literal">nullptr</span> </span><br><span class="line">		&amp;&amp; node-&gt;children[<span class="number">2</span>] == <span class="literal">nullptr</span> &amp;&amp; node-&gt;children[<span class="number">3</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 6、四叉树分割算法——访问

&emsp;&emsp;最后，为了将四叉树的空间划分结果可视化出来，需要对整颗四叉树做一个遍历。树形数据结构遍历都是一些很基础的基本功，这里不再赘述，每遍历到一个节点，将该节点的矩形区域范围绘制出来。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QuadTree::recursiveTraverse(TreeNode *node, glm::vec2 min, glm::vec2 max, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec2&gt;&amp; lines)</span><br><span class="line">&#123;</span><br><span class="line">	glm::vec2 center = (max + min) * <span class="number">0.5f</span>;</span><br><span class="line">	<span class="keyword">float</span> length = <span class="built_in">std</span>::max(max.x - min.x, max.y - min.y);</span><br><span class="line">	glm::vec2 corners[<span class="number">4</span>];</span><br><span class="line">	corners[<span class="number">0</span>] = min;</span><br><span class="line">	corners[<span class="number">1</span>] = min + glm::vec2(length, <span class="number">0.0f</span>);</span><br><span class="line">	corners[<span class="number">2</span>] = max;</span><br><span class="line">	corners[<span class="number">3</span>] = min + glm::vec2(<span class="number">0.0f</span>, length);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! get the bounding box to draw.</span></span><br><span class="line">	lines.push_back(corners[<span class="number">0</span>]);</span><br><span class="line">	lines.push_back(corners[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	lines.push_back(corners[<span class="number">1</span>]);</span><br><span class="line">	lines.push_back(corners[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	lines.push_back(corners[<span class="number">2</span>]);</span><br><span class="line">	lines.push_back(corners[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	lines.push_back(corners[<span class="number">3</span>]);</span><br><span class="line">	lines.push_back(corners[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span> || node-&gt;isLeaf)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! get the four sub-nodes' region.</span></span><br><span class="line">	glm::vec2 subMin[<span class="number">4</span>];</span><br><span class="line">	glm::vec2 subMax[<span class="number">4</span>];</span><br><span class="line">	subMin[<span class="number">0</span>] = min;</span><br><span class="line">	subMax[<span class="number">0</span>] = center;</span><br><span class="line">	subMin[<span class="number">1</span>] = center - glm::vec2(<span class="number">0.0f</span>, length / <span class="number">2</span>);</span><br><span class="line">	subMax[<span class="number">1</span>] = center + glm::vec2(length / <span class="number">2</span>, <span class="number">0.0f</span>);</span><br><span class="line">	subMin[<span class="number">2</span>] = center;</span><br><span class="line">	subMax[<span class="number">2</span>] = max;</span><br><span class="line">	subMin[<span class="number">3</span>] = min + glm::vec2(<span class="number">0.0f</span>, length / <span class="number">2</span>);</span><br><span class="line">	subMax[<span class="number">3</span>] = center + glm::vec2(<span class="number">0.0f</span>, length / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	recursiveTraverse(node-&gt;children[<span class="number">0</span>], subMin[<span class="number">0</span>], subMax[<span class="number">0</span>], lines);</span><br><span class="line">	recursiveTraverse(node-&gt;children[<span class="number">1</span>], subMin[<span class="number">1</span>], subMax[<span class="number">1</span>], lines);</span><br><span class="line">	recursiveTraverse(node-&gt;children[<span class="number">2</span>], subMin[<span class="number">2</span>], subMax[<span class="number">2</span>], lines);</span><br><span class="line">	recursiveTraverse(node-&gt;children[<span class="number">3</span>], subMin[<span class="number">3</span>], subMax[<span class="number">3</span>], lines);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 7、四叉树可视化实验结果

&emsp;&emsp;采用OpenGL图形API将烟花粒子系统和它的四叉树结构可视化出来如下图所示，烟花粒子系统的实现和OpenGL渲染API的使用超出了本课程的范围，因此不再赘述。这里构建的四叉树数据对象是粒子点云，下面一系列图片中左边的图展示是烟花粒子效果，右边的图则展示了构建出来的粒子点云四叉树的可视化结果（绿色部分）。可以看到空间分割的情况符合我们的预期，在粒子点密集的区域四叉树往下分割了不少层，而点云稀疏甚至没有的部分不会往下继续分割，这个就是二维分割的四叉树结构，当我们要搜索某一个区域周围的粒子点时就可以通过四叉树迅速地进行邻域查询。



<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.30/blog/Octree/11.jpg" width="99%">
<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.30/blog/Octree/22.jpg" width="99%">

<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.30/blog/Octree/Animation.gif" width="99%">



&emsp;&emsp;关于四叉树的可视化部分就到这里，下面来看看三维八叉树在计算机图形学光线追踪渲染技术中的实际应用和性能提升。



## 三、利用八叉树算法加速射线求交

&emsp;&emsp;四叉树和八叉树从本质上来讲没有区别，算法的思想都是一样的，只不过四叉树是针对二维的情况，而八叉树针对的是三维的情况。在三维空间均匀划分的是一个长方体，每一个长方体分割成八个相同的子长方体，因而三维情况的空间分割树有八个子节点，被称为八叉树。Wiki的八叉树定义为： 八叉树（Octree）是一种用于描述三维空间的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。 



<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.30/blog/Octree/3.jpg" width="50%">
<center> 图3 三维空间的八叉树 </center>


<p>&emsp;&emsp;想象一个立方体，我们最少可以切成多少个相同等分的小立方体？答案就是8个。再想象 我们有一个房间，房间里某个角落藏着一枚金币，我们想很快的把金币找出来。 我们可以把房间当成一个立方体，先切成八个小立方体，然后排除掉没有放任何东西的小立方体，再把有可能藏金币的小立方体继续切八等份…. 如此下去，平均在$Log_8$(房间内的所有物品数)的时间内就可找到金币。八叉树就是用在3D空间中的场景管理，可以加速我们的物体搜索、碰撞检测、射线求交、邻域搜索等等空间查找操作。</p>
<p>&emsp;&emsp;一般情况下，八叉树的构建过程如下：</p>
<ul>
<li>(1).设定最大递归深度;</li>
<li>(2).找出场景的最大尺寸，并以此尺寸建立第一个立方体;</li>
<li>(3).依序将单位元元素丢入能被包含且没有子节点的立方体;</li>
<li>(4).若没有达到最大递归深度，就进行细分八等份，再将该立方体所装的单位元元素全部分担给八个子立方体;</li>
<li>(5).若发现子立方体所分配到的单位元元素数量不为零且跟父立方体是一样的，则该子立方体停止细分，因为跟据空间分割理论，细分的空间所得到的分配必定较少，若是一样数目，则再怎么切数目还是一样，会造成无穷切割的情形；</li>
<li>(6).重复步骤(3)，直到达到最大递归深度。 </li>
</ul>
<p>&emsp;&emsp;光线追踪是一个递归的过程。发射一束光线到场景，求出光线和几何图形间最近的交点，如果该交点的材质是反射性或折射性的，可以在该交点向反射方向或折射方向继续追踪，如此递归下去，直到设定的最大递归深度或者射线追踪到光源处（或者背景色），如此便计算处一个像素的着色值。<strong>光线追踪算法涉及到大量的光线与几何体的求交点运算，因而与渲染效率息息相关。复杂物体大多采用三角形网格表示，因而进一步来说是射线与三角形的求交运算。</strong>下面我将为每个三角网格模型构建一颗八叉树，加速射线与三角网格模型的求交。</p>
<h4 id="1、八叉树分割算法——构建与销毁"><a href="#1、八叉树分割算法——构建与销毁" class="headerlink" title="1、八叉树分割算法——构建与销毁"></a>1、八叉树分割算法——构建与销毁</h4><p>&emsp;&emsp;在开始构建之前，我们首先要弄清楚一点的就是在这里数据对象是一个个三角形而非一个个点，三角形是由一定的大小的，它有可能刚好处在分割平面上，导致三角形跨越了多个子节点。这时为了防止遗漏，应该把三角形都存储到由交集的节点中。同时，每个叶子节点中并不会直接存储三角形图元数据，而是存储三角形面片的索引。定义八叉树节点如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//! it's leaf or not.</span></span><br><span class="line">	<span class="keyword">bool</span> m_isLeaf;</span><br><span class="line">	<span class="comment">//! the eight children.</span></span><br><span class="line">	Node *m_children[<span class="number">8</span>];</span><br><span class="line">	<span class="comment">//! extent.</span></span><br><span class="line">	AABB m_boundingBox;</span><br><span class="line">	<span class="comment">//! objects' id list.</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&gt; m_objectIds;</span><br><span class="line"></span><br><span class="line">	Node() : m_isLeaf(<span class="literal">true</span>), m_boundingBox(AABB(Vector3D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), Vector3D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		m_children[<span class="number">0</span>] = m_children[<span class="number">1</span>] = m_children[<span class="number">2</span>] = m_children[<span class="number">3</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">		m_children[<span class="number">4</span>] = m_children[<span class="number">5</span>] = m_children[<span class="number">6</span>] = m_children[<span class="number">7</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node(Vector3D min, Vector3D max, <span class="keyword">bool</span> isLeaf) : m_isLeaf(isLeaf),</span><br><span class="line">		m_boundingBox(AABB(min, max))</span><br><span class="line">	&#123;</span><br><span class="line">		m_children[<span class="number">0</span>] = m_children[<span class="number">1</span>] = m_children[<span class="number">2</span>] = m_children[<span class="number">3</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">		m_children[<span class="number">4</span>] = m_children[<span class="number">5</span>] = m_children[<span class="number">6</span>] = m_children[<span class="number">7</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的$m_objectIds$s是一个三元组的vector，三元组的每个元素存储一个三角形面片的三个顶点索引。然后输入模型的三角形面片列表，我们自顶向下构建八叉树。构建的过程其实跟四叉树的构建过程差别不大，区别在于子区域的划分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Node *Octree::recursiveBuild(<span class="keyword">unsigned</span> <span class="keyword">int</span> depth, Vector3D min, Vector3D max,</span><br><span class="line">	<span class="keyword">const</span> MeshHitable * target, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; ids)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//! reach the max depth or there are just a few objects, we dont' need to go further.</span></span><br><span class="line">	<span class="keyword">if</span> (depth == m_maxDepth || ids.size() &lt;= <span class="number">10</span> * <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Node *cur = <span class="keyword">new</span> Node(min, max, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vertices = target-&gt;m_vertices;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ids.size(); i += <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (isContain(cur-&gt;m_boundingBox, vertices[ids[i + <span class="number">0</span>]].m_position,</span><br><span class="line">				vertices[ids[i + <span class="number">1</span>]].m_position, vertices[ids[i + <span class="number">2</span>]].m_position))</span><br><span class="line">				cur-&gt;m_objectIds.push_back(<span class="built_in">std</span>::make_tuple(ids[i + <span class="number">0</span>], ids[i + <span class="number">1</span>], ids[i + <span class="number">2</span>]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! otherwise, just divide into 8 sub-nodes.</span></span><br><span class="line">	Node *cur = <span class="keyword">new</span> Node(min, max, <span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; subIds[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vertices = target-&gt;m_vertices;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;AABB&gt; subRegions = cur-&gt;m_boundingBox.getEightSubAABB();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ids.size(); i += <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p1 = vertices[ids[i + <span class="number">0</span>]].m_position;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p2 = vertices[ids[i + <span class="number">1</span>]].m_position;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p3 = vertices[ids[i + <span class="number">2</span>]].m_position;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (isContain(subRegions[j], p1, p2, p3))</span><br><span class="line">			&#123;</span><br><span class="line">				subIds[j].push_back(ids[i + <span class="number">0</span>]);</span><br><span class="line">				subIds[j].push_back(ids[i + <span class="number">1</span>]);</span><br><span class="line">				subIds[j].push_back(ids[i + <span class="number">2</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur-&gt;m_children[<span class="number">0</span>] = recursiveBuild(depth + <span class="number">1</span>, subRegions[<span class="number">0</span>].getMin(), subRegions[<span class="number">0</span>].getMax(), target, subIds[<span class="number">0</span>]);</span><br><span class="line">	cur-&gt;m_children[<span class="number">1</span>] = recursiveBuild(depth + <span class="number">1</span>, subRegions[<span class="number">1</span>].getMin(), subRegions[<span class="number">1</span>].getMax(), target, subIds[<span class="number">1</span>]);</span><br><span class="line">	cur-&gt;m_children[<span class="number">2</span>] = recursiveBuild(depth + <span class="number">1</span>, subRegions[<span class="number">2</span>].getMin(), subRegions[<span class="number">2</span>].getMax(), target, subIds[<span class="number">2</span>]);</span><br><span class="line">	cur-&gt;m_children[<span class="number">3</span>] = recursiveBuild(depth + <span class="number">1</span>, subRegions[<span class="number">3</span>].getMin(), subRegions[<span class="number">3</span>].getMax(), target, subIds[<span class="number">3</span>]);</span><br><span class="line">	cur-&gt;m_children[<span class="number">4</span>] = recursiveBuild(depth + <span class="number">1</span>, subRegions[<span class="number">4</span>].getMin(), subRegions[<span class="number">4</span>].getMax(), target, subIds[<span class="number">4</span>]);</span><br><span class="line">	cur-&gt;m_children[<span class="number">5</span>] = recursiveBuild(depth + <span class="number">1</span>, subRegions[<span class="number">5</span>].getMin(), subRegions[<span class="number">5</span>].getMax(), target, subIds[<span class="number">5</span>]);</span><br><span class="line">	cur-&gt;m_children[<span class="number">6</span>] = recursiveBuild(depth + <span class="number">1</span>, subRegions[<span class="number">6</span>].getMin(), subRegions[<span class="number">6</span>].getMax(), target, subIds[<span class="number">6</span>]);</span><br><span class="line">	cur-&gt;m_children[<span class="number">7</span>] = recursiveBuild(depth + <span class="number">1</span>, subRegions[<span class="number">7</span>].getMin(), subRegions[<span class="number">7</span>].getMax(), target, subIds[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;构建过程的时间复杂度为$Nlog_8\ N$。同样的，八叉树销毁过程采用后序遍历的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Octree::recursiveDestory(Node * node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//! backward traverse for deletion.</span></span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	recursiveDestory(node-&gt;m_children[<span class="number">0</span>]);</span><br><span class="line">	recursiveDestory(node-&gt;m_children[<span class="number">1</span>]);</span><br><span class="line">	recursiveDestory(node-&gt;m_children[<span class="number">2</span>]);</span><br><span class="line">	recursiveDestory(node-&gt;m_children[<span class="number">3</span>]);</span><br><span class="line">	recursiveDestory(node-&gt;m_children[<span class="number">4</span>]);</span><br><span class="line">	recursiveDestory(node-&gt;m_children[<span class="number">5</span>]);</span><br><span class="line">	recursiveDestory(node-&gt;m_children[<span class="number">6</span>]);</span><br><span class="line">	recursiveDestory(node-&gt;m_children[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> node;</span><br><span class="line">	node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里有一点需要特别注意的就是需要判断一个立方体区域是否与三角形相交或包含，我采用的方法是首先判断三角形的三个点中是否至少有一个在立方体内部，如果是则返回真。而如果三角形的三个顶点均不在立方体区域内部，但仍有可能三角形与立方体区域存在交集，此时可以通过依次判断三角形的三条边是否与立方体相交。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Octree::isContain(<span class="keyword">const</span> AABB &amp; box, <span class="keyword">const</span> Vector3D &amp; p1, <span class="keyword">const</span> Vector3D &amp; p2, <span class="keyword">const</span> Vector3D &amp; p3)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//! at least one point of the triangle is inside the box, return true.</span></span><br><span class="line">	<span class="keyword">if</span> (box.isInside(p1) || box.isInside(p2) || box.isInside(p3))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! otherwise testing for each edge.</span></span><br><span class="line">	<span class="function">Ray <span class="title">edge1</span><span class="params">(p1, p2 - p1)</span></span>;</span><br><span class="line">	<span class="function">Ray <span class="title">edge2</span><span class="params">(p2, p3 - p2)</span></span>;</span><br><span class="line">	<span class="function">Ray <span class="title">edge3</span><span class="params">(p3, p1 - p3)</span></span>;</span><br><span class="line">	<span class="keyword">float</span> length1 = (p2 - p1).getLength();</span><br><span class="line">	<span class="keyword">float</span> length2 = (p3 - p2).getLength();</span><br><span class="line">	<span class="keyword">float</span> length3 = (p1 - p3).getLength();</span><br><span class="line">	<span class="keyword">if</span> (box.hit(edge1, <span class="number">0.0f</span>, length1) || box.hit(edge2, <span class="number">0.0f</span>, length2) || box.hit(edge3, <span class="number">0.0f</span>, length3))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! if there is no intersection at all, just return false.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、八叉树分割算法——访问"><a href="#2、八叉树分割算法——访问" class="headerlink" title="2、八叉树分割算法——访问"></a>2、八叉树分割算法——访问</h4><p>&emsp;&emsp;构建了八叉树之后，八叉树的优势就体现出来了，在光线追踪过程每发射一条射线我们就要检测该射线与场景中的物体是否发生了碰撞，如果发生了碰撞则需要将碰撞的点计算出来。有了八叉树结构，我们首先检测射线是否与当前节点的区域发生了碰撞，如果不发生碰撞则直接退出；而如果发生了碰撞且当前节点是叶子节点的话，则遍历叶子节点存储的三角形，计算射线与三角形的交点，取距离射线源最近的结果；而当前节点是内部节点的话，则递归调用遍历程序，判断射线是否与该区域的八个子区域碰撞，有碰撞才会继续往下走，无碰撞则不会往下深入。</p>
<p>&emsp;&emsp;这个算法的实现并不复杂，实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Octree::recursiveTraveling(Node * node, <span class="keyword">const</span> Ray &amp; ray, <span class="keyword">float</span> &amp; t_min, <span class="keyword">float</span> &amp; t_max,</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i1, <span class="keyword">unsigned</span> <span class="keyword">int</span> i2, <span class="keyword">unsigned</span> <span class="keyword">int</span> i3, <span class="keyword">float</span> &amp;t)&gt; func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//! just return false if node is nullptr.</span></span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! if the ray doesn't intersect with the aabb box, just return false.</span></span><br><span class="line">	<span class="keyword">if</span> (!node-&gt;m_boundingBox.hit(ray, t_min, t_max))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! if it's a leaf, travels every objects of this node.</span></span><br><span class="line">	<span class="keyword">if</span> (node-&gt;m_isLeaf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; node-&gt;m_objectIds.size(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face = node-&gt;m_objectIds[i];</span><br><span class="line">			ret |= func(<span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(face), <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(face), <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(face), t_max);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//! otherwise, divide into 8 sub-nodes.</span></span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;AABB&gt; subRegions = node-&gt;m_boundingBox.getEightSubAABB();</span><br><span class="line">	<span class="keyword">if</span> (subRegions[<span class="number">0</span>].hit(ray, t_min, t_max))</span><br><span class="line">		ret |= recursiveTraveling(node-&gt;m_children[<span class="number">0</span>], ray, t_min, t_max, func);</span><br><span class="line">	<span class="keyword">if</span> (subRegions[<span class="number">1</span>].hit(ray, t_min, t_max))</span><br><span class="line">		ret |= recursiveTraveling(node-&gt;m_children[<span class="number">1</span>], ray, t_min, t_max, func);</span><br><span class="line">	<span class="keyword">if</span> (subRegions[<span class="number">2</span>].hit(ray, t_min, t_max))</span><br><span class="line">		ret |= recursiveTraveling(node-&gt;m_children[<span class="number">2</span>], ray, t_min, t_max, func);</span><br><span class="line">	<span class="keyword">if</span> (subRegions[<span class="number">3</span>].hit(ray, t_min, t_max))</span><br><span class="line">		ret |= recursiveTraveling(node-&gt;m_children[<span class="number">3</span>], ray, t_min, t_max, func);</span><br><span class="line">	<span class="keyword">if</span> (subRegions[<span class="number">4</span>].hit(ray, t_min, t_max))</span><br><span class="line">		ret |= recursiveTraveling(node-&gt;m_children[<span class="number">4</span>], ray, t_min, t_max, func);</span><br><span class="line">	<span class="keyword">if</span> (subRegions[<span class="number">5</span>].hit(ray, t_min, t_max))</span><br><span class="line">		ret |= recursiveTraveling(node-&gt;m_children[<span class="number">5</span>], ray, t_min, t_max, func);</span><br><span class="line">	<span class="keyword">if</span> (subRegions[<span class="number">6</span>].hit(ray, t_min, t_max))</span><br><span class="line">		ret |= recursiveTraveling(node-&gt;m_children[<span class="number">6</span>], ray, t_min, t_max, func);</span><br><span class="line">	<span class="keyword">if</span> (subRegions[<span class="number">7</span>].hit(ray, t_min, t_max))</span><br><span class="line">		ret |= recursiveTraveling(node-&gt;m_children[<span class="number">7</span>], ray, t_min, t_max, func);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，通过八叉树的结构我们可以避免很多无用功，大大加速整个求交的过程，有了八叉树后射线与三角形求交的时间复杂度就变成了$O(log_8 N)$，其中$N$是输入规模，相比于原来的$O(N)$复杂度提升非常明显。下面就通过实验比较有无八叉树的算法效率。至于光线追踪方面的算法，与本门课的主题关系比较小，而且涉及的内容实在太多，因此不再赘述。</p>
<h4 id="3、八叉树加速实验结果"><a href="#3、八叉树加速实验结果" class="headerlink" title="3、八叉树加速实验结果"></a>3、八叉树加速实验结果</h4><p>&emsp;&emsp;我们将对比两个场景渲染的实验，两个场中均涉及到复杂的三角网格模型。控制的变量有每个像素发射的采样光线个数、有无八叉树加速。一般情况下，采样光线数量越多越好，数量过少会导致渲染出来的图片噪声过多，质量太低。场景中三角网格比较多的模型如下图5所示：</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.30/blog/Octree/5.jpg" width="100%"></div></p>
<center> 图5 从左到右三角形面片的数量依次为100000个、69666个和5022个 </center>
&emsp;&emsp;下面给出了渲染绘制出来的两个场景，从左到右、从上到下的光线采样数量依次为16、64、128和512，可以看到低采样数时渲染出来的图片噪声明显，质量很低。因此为了渲染出高质量的图片，采样数不能太低，这意味着求交数量也将大大增加。我们记下面的两个场景分别为dragonSquare和dragonBox。下面的图片可以看到利用八叉树并没有损失光线追踪的渲染质量。



<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.30/blog/Octree/ret1.jpg" width="100%">
   <center> 图6 场景一：dragonSquare </center>

<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.30/blog/Octree/ret2.jpg" width="100%"></div></p>
<p>   <center> 图7 场景二：dragonBox </center><br>&emsp;&emsp;下面的表1给出了两个场景在有无八叉树时的渲染时间对比，表格中的s是second的缩写，即单位为秒。表格的最后一列有两个“&gt;3小时“是因为等不下去了，就不再等了，花费的时间实在太长了。<strong>通过表格可以看到，有了八叉树的加速，时间效率提升极其明显，特别是采样数量越多的时候，提升倍数越多，完全是几个数量级的提升。这是因为采样数量呈指数增值时，射线与三角形的求交数量也呈指数增长。</strong></p>
<p>   <center> 表1 渲染时间比较 </center></p>
<table>
    <tr>
        <th rowspan="1" align="center">scene</th>
        <th rowspan="1" align="center">16次采样</th>
        <th rowspan="1" align="center">64次采样</th>
        <th rowspan="1" align="center">128次采样</th>
        <th rowspan="1" align="center">512次采样</th>
    </tr>
    <tr>
        <td>dragonSquare（无八叉树）</td>
        <td>427.776s</td>
        <td>2195.918s</td>
        <td>8715.48s</td>
        <td>>3小时</td>
    </tr>
    <tr>
        <td>dragonSquare（有八叉树）</td>
        <td>17.824s</td>
        <td>70.382s</td>
        <td>147.72s</td>
        <td>614.562s</td>
    </tr>
    <tr>
        <td>dragonBox（无八叉树）</td>
        <td>380.944s</td>
        <td>1818.491s</td>
        <td>6548.502</td>
        <td>>3小时</td>
    </tr>
    <tr>
        <td>dragonBox（有八叉树）</td>
        <td>13.136s</td>
        <td>58.661s</td>
        <td>105.642s</td>
        <td>422.652s</td>
    </tr>
</table>



<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>&emsp;&emsp;分治算法思想是一个非常有用的算法思想，我们围绕分治算法这一主题展开其在计算机图形学中应用——四叉树和八叉树空间分割算法实践。抛开诸多细节不说，四叉树和八叉树在本质上与二分查找类似。与二分查找的排序预处理一样，四叉树和八叉树都需要在最开始构建，构建的复杂度与排序的时间复杂度一致，对于那些查找密集型的应用场景来说非常划算（提升的效率极其恐怖）。当然，四叉树和八叉树并不完美的，它们也有缺点，一个比较大的缺点就是它要求空间物体对象分布比较均匀，如果分布不均匀，那么构建出来的树将不会很平衡，这将影响后续的访问效率。针对这一问题，后续的学者已经有比较多的算法变种，限于篇幅这里不再详细展开。</p>
</div></div></div></div></div></div>
        </div>
        
          


  <section class="meta" id="footer-meta">
    <hr>
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-06-25T18:04:00+08:00">
  <a class="notlink">
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>最后更新于 2020年6月25日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Computer-Graphics/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Computer Graphics</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Ray-Tracer/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Ray Tracer</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yangwc.com/2020/01/10/Octree/&title=空间管理Space management：四叉树 & 八叉树 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=又是好久没更新博客了，最近在写算法分析与设计课程的期末作业，作业的题目随意，我就随兴写了烟花粒子的四叉树可视化程序和光追渲染器的八叉树求交优化。之前写的光追渲染器对每个三角网格模型的求交都是暴力遍历所有的三角形，对于三角形数量很多的模型来说效率非常低，所以我捡起了这个渲染器并为每个三角网格模型构建一颗八叉树加快射线与三角形的求交速度。还真别说，性能提升巨大。所以这篇博客本质上是一个期末作业。最后，新年快乐！
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://yangwc.com/2020/01/10/Octree/&title=空间管理Space management：四叉树 & 八叉树 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=又是好久没更新博客了，最近在写算法分析与设计课程的期末作业，作业的题目随意，我就随兴写了烟花粒子的四叉树可视化程序和光追渲染器的八叉树求交优化。之前写的光追渲染器对每个三角网格模型的求交都是暴力遍历所有的三角形，对于三角形数量很多的模型来说效率非常低，所以我捡起了这个渲染器并为每个三角网格模型构建一颗八叉树加快射线与三角形的求交速度。还真别说，性能提升巨大。所以这篇博客本质上是一个期末作业。最后，新年快乐！
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=https://yangwc.com/2020/01/10/Octree/&title=空间管理Space management：四叉树 & 八叉树 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=又是好久没更新博客了，最近在写算法分析与设计课程的期末作业，作业的题目随意，我就随兴写了烟花粒子的四叉树可视化程序和光追渲染器的八叉树求交优化。之前写的光追渲染器对每个三角网格模型的求交都是暴力遍历所有的三角形，对于三角形数量很多的模型来说效率非常低，所以我捡起了这个渲染器并为每个三角网格模型构建一颗八叉树加快射线与三角形的求交速度。还真别说，性能提升巨大。所以这篇博客本质上是一个期末作业。最后，新年快乐！
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                            <h4>
                                <a href="/2020/04/04/Camera/" rel="prev" title="Physically Based Rendering：摄像机模型">
                                  
                                      Physically Based Rendering：摄像机模型
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Ray-Tracer/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Ray Tracer</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2019/11/10/reviewOfSR/" rel="prev" title="流体模拟Fluid Simulation：基于窄带的粒子流体表面重建">
                                    
                                        流体模拟Fluid Simulation：基于窄带的粒子流体表面重建
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Fluid-Simulation/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Fluid Simulation</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
        <section id="comments">
          <div id="lv-container" data-id="city" data-uid="MTAyMC80MzkxOS8yMDQ1NQ==">
            <noscript><div><i class="fas fa-exclamation-triangle">&nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。</i></div></noscript>
          </div>
        </section>
      
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

  <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



  <script>
    window.subData = {
      title: '空间管理Space management：四叉树 & 八叉树',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content material">
    
      <div class="avatar">
        <fancybox><img class="avatar" src="/image/avator.jpg"></fancybox>
      </div>
    
    
      <div class="text">
        
          <h2>YangWC</h2>
        
        
          <p>Enjoy Computer Graphics!</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget toc-wrapper">
    
<header class="material">
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class="content material">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、背景介绍"><span class="toc-text">一、背景介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、八叉树分割算法——构建与销毁"><span class="toc-text">1、八叉树分割算法——构建与销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、八叉树分割算法——访问"><span class="toc-text">2、八叉树分割算法——访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、八叉树加速实验结果"><span class="toc-text">3、八叉树加速实验结果</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#四、总结"><span class="toc-text">四、总结</span></a></li>
    </div>
  </section>


          
        
      
        
          
          
            <section class="widget plain">
  
<header class="material">
  <div><i class=" fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;欢迎来到YangWC的博客</div>
  
</header>

  <div class="content material">
    <p>本站会记录自己的一些学习内容，如若有错或者乱码，欢迎指正，感谢!</p>

  </div>
</section>

          
        
      
        
          
          
            <section class="widget grid">
  
<header class="material">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content material">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于博主
        </a></li>
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn" rel="nofollow" href="/categories/" title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/2D-Rendering/" href="/categories/2D-Rendering/"><div class="name">2D Rendering</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Computer-Graphics/" href="/categories/Computer-Graphics/"><div class="name">Computer Graphics</div><div class="badge">(36)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-Simulation/" href="/categories/Fluid-Simulation/"><div class="name">Fluid Simulation</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-simulation/" href="/categories/Fluid-simulation/"><div class="name">Fluid  simulation</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Image-processing/" href="/categories/Image-processing/"><div class="name">Image processing</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/N-body/" href="/categories/N-body/"><div class="name">N-body</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physical-simulation/" href="/categories/Physical-simulation/"><div class="name">Physical simulation</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physically-Based-Rendering/" href="/categories/Physically-Based-Rendering/"><div class="name">Physically Based Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Position-Based-Dynamics/" href="/categories/Position-Based-Dynamics/"><div class="name">Position Based Dynamics</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Ray-Tracer/" href="/categories/Ray-Tracer/"><div class="name">Ray Tracer</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Real-time-Rendering/" href="/categories/Real-time-Rendering/"><div class="name">Real-time Rendering</div><div class="badge">(6)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Soft-Renderer/" href="/categories/Soft-Renderer/"><div class="name">Soft Renderer</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Voxelization/" href="/categories/Voxelization/"><div class="name">Voxelization</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class="widget tagcloud">
    
<header class="material">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn" rel="nofollow" href="/tags/" title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <a href="/tags/2D-Rendering/" style="font-size: 14px; color: #bbb">2D Rendering</a> <a href="/tags/3D-Math/" style="font-size: 14px; color: #bbb">3D Math</a> <a href="/tags/3D-pipeline/" style="font-size: 15.67px; color: #c6c6c6">3D pipeline</a> <a href="/tags/Advection/" style="font-size: 14px; color: #bbb">Advection</a> <a href="/tags/Computer-Graphics/" style="font-size: 24px; color: #fff">Computer Graphics</a> <a href="/tags/Fluid-Simulation/" style="font-size: 22.33px; color: #f4f4f4">Fluid Simulation</a> <a href="/tags/Fluid-simulation/" style="font-size: 14px; color: #bbb">Fluid simulation</a> <a href="/tags/Glow-effect/" style="font-size: 14px; color: #bbb">Glow effect</a> <a href="/tags/Image-processing/" style="font-size: 14px; color: #bbb">Image processing</a> <a href="/tags/N-body/" style="font-size: 14px; color: #bbb">N-body</a> <a href="/tags/Naiver-Stokes-Equations/" style="font-size: 14px; color: #bbb">Naiver-Stokes Equations</a> <a href="/tags/Physical-simulation/" style="font-size: 14px; color: #bbb">Physical simulation</a> <a href="/tags/Physically-Based-Rendering/" style="font-size: 15.67px; color: #c6c6c6">Physically Based Rendering</a> <a href="/tags/Position-Based-Dynamics/" style="font-size: 17.33px; color: #d2d2d2">Position Based Dynamics</a> <a href="/tags/Rasterization/" style="font-size: 14px; color: #bbb">Rasterization</a> <a href="/tags/Ray-Tracer/" style="font-size: 22.33px; color: #f4f4f4">Ray Tracer</a> <a href="/tags/Real-time-Rendering/" style="font-size: 20.67px; color: #e8e8e8">Real-time Rendering</a> <a href="/tags/Soft-Renderer/" style="font-size: 19px; color: #ddd">Soft Renderer</a> <a href="/tags/Voxelization/" style="font-size: 14px; color: #bbb">Voxelization</a>
    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
	<script>
		var now = new Date(); 
		function createtime() { 
			var grt= new Date("04/24/2019 18:00:00");//在此处修改你的建站时间
			now.setTime(now.getTime()+250); 
			days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
			hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
			if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
			mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
			seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
			snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
			document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
			document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
		} 
	setInterval("createtime()",250);
   </script>
   
   <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->
	
	
	<script>setLoadingBarProgress(80);</script>
</footer>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>









  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>






  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  
    <!--数字雨背景-->
  <canvas id="canvas" width="1440" height="900" ></canvas>
  <script>
	var s = window.screen;
	var width = canvas.width = s.width;
	var height = canvas.height = s.height;
	var fontSize = 13;
	var colunms = Math.floor(width/fontSize);
	var letters = [];
    for(var i=0;i<colunms;i++){
        letters.push(1);
    }
	var draw = function () {
	    canvas.getContext('2d').fillStyle = "rgba(0,0,0,.08)";//遮盖层
		canvas.getContext('2d').fillRect(0,0,width,height);
		canvas.getContext('2d').font = "700 " + fontSize +"px  微软雅黑";
		letters.map(function(y_pos, index){
		text = String.fromCharCode(34+Math.random()*33);
		x_pos = index * fontSize;
		canvas.getContext('2d').fillText(text, x_pos, y_pos);
		letters[index] = (y_pos > 758 + Math.random() * 1e4) ? 0 : y_pos + 10;
		canvas.getContext('2d').fillStyle='#'+letters[index];
	  });
	};
	setInterval(draw, 33);
  </script>
  
  <!-- 页面点击出现文字 -->
  <script type="text/javascript" src="/js/ClickShowText.js"></script>
  
  <script>setLoadingBarProgress(100);</script>
</body>
</html>
