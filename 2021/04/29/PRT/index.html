<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>高质量实时渲染：实时环境光 | YangWC&#39;s Blog</title>
  
  
  <meta name="description" content="Personal blog website.">
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/logo.ico">
  

  
    <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fdf716664defeee80e01568ddbeb2425";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
  
</head>
<body>
  
  
  <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          YangWC's Blog
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
									<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/" id="home">
									<i class="fas fa-grin fa-fw"></i>&nbsp;博客
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
									<i class="fas fa-tag fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-grin fa-fw"></i>&nbsp;博客
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
								<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
								<i class="fas fa-tag fa-fw"></i>&nbsp;标签
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      <div class="l_main">
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2021/04/29/PRT/">
        高质量实时渲染：实时环境光
      </a>
    </h1>
  


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="https://yangwc.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2021-04-29</p>
  </a>
</div>

          
        
          
            
  
  <div class="new-meta-item category">
    <a href="/categories/Real-time-Rendering/" rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Computer Graphics&nbsp;/&nbsp;Real-time Rendering</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p>本文是闫令琪老师GAMES202高质量实时渲染课程的学习笔记和总结，这一节的主题为高质量实时环境光照，内容分为IBL（Imaged Based Lighting）和PRT（Precomputed Radiance Transfer）。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.43/blog/PRT/1.jpg" width="100%"></div></p>
<a id="more"></a>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&emsp;&emsp;环境光照处理着色点与周围环境的光影交互，对增强物体与周围环境的融入程度有着至关重要的作用。在实时渲染领域，环境光特指由预先生成的环境贴图提供的光照信息（即天空盒），贴图的每个纹素都可以看成是一个光源（注：这些光源我们当成其在无穷远处），因此其覆盖的方向是三维空间的所有方向。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/2.png" width="99%"></div></p>
<p>&emsp;&emsp;理论上，准确求解环境光照需要计算如下的半球积分渲染方程：</p>
<script type="math/tex; mode=display">
L_o(p,\omega_o)=\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)cos\theta_i d\omega_i \tag {1}</script><p>&emsp;&emsp;其中，我们不考虑可见性遮挡因素，因此上式是去掉了$V(p,\omega_i)$项的。$L_i(p,\omega_i)$项通过用$\omega_i$对环境贴图进行采样获得。公式$(1)$的求解可以采用蒙特卡洛积分的方法结合重要性采样来进行求解，但这是离线渲染的做法，虽然理论上能够收敛到无偏的结果，但其耗费的算力代价和采样数量对于实时渲染来说根本不可接受！</p>
<p>&emsp;&emsp;由此衍生了一些快速的近似求解算法，例如IBL和PRT。这些算法的核心本质，就是<strong>预计算</strong>，通过某种方法把积分的求解放在预计算阶段，并将结果存储下来，在绘制阶段直接查表来实现快速的环境光渲染。</p>
<h2 id="二、Imaged-Based-Lighting"><a href="#二、Imaged-Based-Lighting" class="headerlink" title="二、Imaged Based Lighting"></a>二、Imaged Based Lighting</h2><p>&emsp;&emsp;IBL的本质就是Split Sum，把公式$(1)$的渲染方程进行拆解，达到变量降维的目的，实现低量存储、高速查表的性能。回顾上一节实时软阴影，我们提到实时渲染领域非常常用的一个近似公式：</p>
<script type="math/tex; mode=display">
\int_{\Omega} f(x)g(x)dx\approx \frac{\int_{\Omega}f(x)dx}{\int_{\Omega}dx}\cdot \int_{\Omega}g(x)dx \tag {2}</script><p>&emsp;&emsp;该公式把两个函数乘积的积分近似为各自积分的乘积（即把乘积符号和积分符号做了个交换）。上次我们也提到，当函数$g(x)$满足以下两个条件时，公式$(2)$的近似是相对比较准确的：</p>
<ul>
<li>当$g(x)$在积分域$\Omega$内的实际贡献（support）很小，即$g(x)$在$\Omega$内绝大部分取值为零，例如一个脉冲函数，仅在$x=0$不为零，其他地方均为零（即狄拉克函数）；</li>
<li>当$g(x)$在积分域$\Omega$内变化不大，可以理解为低频函数。</li>
</ul>
<p>&emsp;&emsp;在实时渲染领域，有三种常用的BRDF材质：specular、diffuse和glossy，其中glossy是介于specular和diffuse之间的一种材质。三者的区别在于反射波瓣（lobe）的分布。如下图1所示，glossy的反射波瓣通常比较狭长（而specular则直接是一个方向了，其BRDF函数为狄拉克函数），diffuse反射波瓣在半球方向均匀分布。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.43/blog/PRT/2.jpg" width="60%"></div></p>
<center> 图1 glossy（左）和diffuse（右）的反射波瓣分布 </center>


<p>&emsp;&emsp;因此，渲染方程$(1)$中的BRDF函数$f_r$在通常情况下，要么实际贡献范围很小（例如glossy），要么实际变化不大（例如diffuse）。由此可以利用公式$(2)$的近似模式来将渲染方程$(1)$拆解开来：</p>
<script type="math/tex; mode=display">
L_o(p,\omega_o)\approx \frac{f_{\Omega_{f_r}}L_i(p,\omega_i)d\omega_i}{\int_{\Omega_{f_r}}d\omega_i}\cdot \int_{\Omega^+}f_r(p,\omega_i,\omega_o)cos\theta_i d\omega_i \tag {3}</script><p>&emsp;&emsp;近似结果拆解成了如上所示的两项，为了方便论述，我们分别称左右两项为irradiance项和brdf项。由此，IBL的预计算分成两步，分别是irradiance项的预计算和brdf项的预计算。</p>
<p>&emsp;&emsp;irradiance项的预计算核心公式为：</p>
<script type="math/tex; mode=display">
\frac{f_{\Omega_{f_r}}L_i(p,\omega_i)d\omega_i}{\int_{\Omega_{f_r}}d\omega_i}</script><p>&emsp;&emsp;其中的积分区域$\Omega_{f_r}$为材质BRDF波瓣分布的区域。例如diffuse的话，那么就是整个半球；而对于glossy材质，其表面越粗糙，则$\Omega_{f_r}$越大。上式本质上可以看成为在$\Omega_{f_r}$区域上的对$L_i$做box filtering处理过程，不同的BRDF材质区别仅在于滤波区域$\Omega_{f_r}$的大小，材质越接近diffuse，那么其滤波范围越大，滤波得到的结果越模糊，反射的结果越模糊，反之则越光滑，这与我们的常识相符。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.43/blog/PRT/3.jpg" width="60%"></div></p>
<center> 图2 split sum的irradiance项近似 </center>


<p>&emsp;&emsp;如上图2所示，对于反射波瓣范围内的radiance采样，可以近似为该反射波瓣投影到球面上的范围内的卷积滤波处理，这就是irradiance预计算的核心本质。实现也很简单，直接用Mipmap为环境贴图生成不同level的降采样结果（降采样本质上就是一个模糊滤波），这一阶段我们称之为Pre-Filterd Evnvironment Map。然后在查表时，根据材质的粗糙度去获取采样相应level的环境贴图，查表输入的采样向量为反射向量（对于diffuse则为表面法线）。粗糙度介于不同的level之间可以再做一次插值。</p>
<p>&emsp;&emsp;brdf项的预计算核心公式为：</p>
<script type="math/tex; mode=display">
\int_{\Omega^+}f_r(p,\omega_i,\omega_o)cos\theta_i d\omega_i</script><p>&emsp;&emsp;这个项的预计算不太好处理。在PBR材质流程管线，我们通常用如下的基于微表面的BRDF函数：</p>
<script type="math/tex; mode=display">
f_r(p,\omega_i,\omega_o)=\frac{F(\omega_o,h)G(\omega_i,\omega_o,h)D(h)}{4(n\cdot\omega_i)(n\cdot\omega_o)} \tag {4}</script><p>&emsp;&emsp;其中$F$、$G$和$D$分别是菲涅尔方程、几何遮蔽函数和法线分布函数。其中$h$是介于$\omega_i$和$\omega_o$之间的半角向量（half vector）。菲尼尔方程采用Schlick近似：</p>
<script type="math/tex; mode=display">
F(\omega_o,h)=R_0+(1-R_0)(1-\omega_o\cdot h)^5 \tag {5}</script><p>&emsp;&emsp;可以看到菲涅尔项依赖的参数有基础反射率$R_0$和$\omega_o\cdot h$。而$G$和$D$函数的可选项有很多，这里不罗列出来，但我们直到这两个函数依赖的参数为表面的粗糙度$\mu$。预计算的公式依赖的参数有三个，这说明我们需要三维的纹理来存储结果，为了降低依赖的维度，这里设法将一些变量提出积分符号外：</p>
<script type="math/tex; mode=display">
\int_{\Omega^+}f_r(p,\omega_i,\omega_o)cos\theta_i d\omega_i
=\int_{\Omega^+}f_r(p,\omega_i,\omega_o)\frac{F(\omega_o,h)}{F(\omega_o,h)}cos\theta_id\omega_i\\
=\int_{\Omega}\frac{f_r(p,\omega_i,\omega_o)}{F(\omega_o,h)}F(\omega_o,h)cos\theta_id\omega_i
\tag{6}</script><p>&emsp;&emsp;把公式$(5)$带入公式$(6)$，有：</p>
<script type="math/tex; mode=display">
\int_{\Omega^+}\frac{f_r(p,\omega_i,\omega_o)}{F(\omega_o,h)}(R_0+(1-R_0)(1-\omega_o\cdot h)^5)cos\theta_id\omega_i
\\
=
\int_{\Omega^+}\frac{f_r(p,\omega_i,\omega_o)}{F(\omega_o,h)}(R_0(1-(1-\omega_o\cdot h)^5)+(1-\omega_o\cdot h)^5)cos\theta_id\omega_i \tag {7}</script><p>&emsp;&emsp;然后把公式$(7)$得到的结果写成以下的两个部分：</p>
<script type="math/tex; mode=display">
\int_{\Omega^+}\frac{f_r(p,\omega_i,\omega_o)}{F(\omega_o,h)}(R_0(1-(1-\omega_o\cdot h)^5)+(1-\omega_o\cdot h)^5)cos\theta_id\omega_i\\
=R_0\int_{\Omega^+}f_r(p,\omega_i,\omega_o)(1-(1-\omega_o\cdot h)^5)cos\theta_id\omega_i
+\int_{\Omega}f_r(p,\omega_i,\omega_o)(1-\omega_o\cdot h)^5 cos\theta_i d\omega_i \tag {8}</script><p>&emsp;&emsp;这样我们就把$R_0$提出积分符号外面，其中下面的$f_r$是去掉了菲涅尔项的BRDF函数。剩下的两个积分项分别依赖于粗糙度$\mu$和$n\cdot \omega_o$，我们构建这样的一个查找表，横坐标$u$为$n\cdot \omega_o$，纵坐标$v$为$\mu$，每个$(n\cdot \omega_o,\mu)$对应的纹素的r通道和g通道分别存储公式$(8)$的左右两个积分项。如下图所示：</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/8.png" width="40%"></div></p>
<center> 图3 brdf积分查找表 </center>

<p>&emsp;&emsp;关于IBL的实现详情见之前的博文<a href="http://yangwc.com/2019/07/21/ImageBasedLighting/">实时渲染Real-time Rendering：Image Based Lighting</a>，这里不再赘述。IBL缺点在于难以处理阴影遮挡问题，目前工业界主流的方法是为cubemap最亮的区域生成一个主要的阴影。</p>
<h2 id="三、Precomputed-Radiance-Transfer"><a href="#三、Precomputed-Radiance-Transfer" class="headerlink" title="三、Precomputed Radiance Transfer"></a>三、Precomputed Radiance Transfer</h2><p>&emsp;&emsp;PRT涉及的数学内容较多，这里仅仅就个人理解做一个总结。PRT把渲染方程的辐射率项$L_i$和BRDF项展开成以球面谐波函数为基的系数权重，因此其预计算都是如何将函数投影到球面谐波函数表达的空间。</p>
<p>&emsp;&emsp;在高等数学、数学分析等课程中，我们都曾学习过函数的级数展开（例如泰勒展开）。对于给定的一个函数$f(x)$，我们可以对其进行级数展开，表示成一系列基函数的加权之和：</p>
<script type="math/tex; mode=display">
f(x)=\Sigma_i c_i\cdot B_i(x) \tag {9}</script><p>&emsp;&emsp;其中$B_i(x)$是第$i$个基函数，$c_i$是相应的权重。我们可以类比线性代数，把所有的基函数$B_i(x)$构成的空间看成是一个函数空间，$c_i$相应地就是在$B_i(x)$基底下的投影权重，所有的基底乘上相应的系数权重，线性组合成了原始函数$f(x)$。因此求解权重系数的过程我们称之为<strong>投影</strong>。</p>
<p>&emsp;&emsp;以傅里叶变换为例。傅里叶变换本质上就是傅里叶级数展开过程中的投影，傅里叶级数用一系列不同频率、振幅的正余弦波的线性组合还原出原始函数$f(x)$。我们透过傅里叶权重可以更加方便地分析原始函数$f(x)$频率分布情况，进行傅里叶分析、滤波等操作。</p>
<p>&emsp;&emsp;卷积定理告诉我们，在空间域的卷积滤波等价于在频率域的乘积。因此，对于两个函数乘积的积分：</p>
<script type="math/tex; mode=display">
\int_{\Omega}f(x) g(x)dx \tag {10}</script><p>&emsp;&emsp;我们可以将上述的公式理解为低通滤波操作。滤波的结果取决于两个函数中比较低频的函数，这样较低频的函数把另一个较高频函数的高频信息过滤掉了！这个公式对于理解PRT非常重要。</p>
<p>&emsp;&emsp;球面谐波（Spherical Harmonics，简称SH）基函数是一组定义在球面上基函数，下图4展示了前4阶的SH基函数分布。第$i$阶SH基函数有$2i+1$个，前$i$阶一共有$(2i+1)^2$个SH基函数。与一维的傅里叶级数类似，越高阶的SH基函数其蕴含的频率信息越高。每个SH基函数由伴随勒让德多项式给出。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.43/blog/PRT/4.jpg" width="80%"></div></p>
<center> 图4 前4阶球面谐波基函数 </center>


<p>&emsp;&emsp;这个<a href="https://zh.wikipedia.org/wiki/%E7%90%83%E8%AB%A7%E5%87%BD%E6%95%B8%E8%A1%A8" target="_blank" rel="noopener">球谐函数表</a>给出了前几阶的SH基函数具体公式，这里不再赘述。这里特别提一点，SH基函数具备一个的良好性质：正交完备性，不同的基函数之间相互正交，即有：</p>
<script type="math/tex; mode=display">
\int_{\Omega}B_i(\omega)B_j(\omega)d\omega=0, i\neq j</script><p>&emsp;&emsp;而上式如果$i=j$，那么：</p>
<script type="math/tex; mode=display">
\int_{\Omega}B_i(\omega)B_j(\omega)d\omega=1, i= j</script><p>&emsp;&emsp;我们知道，三维的方向向量可以转换成用球面坐标系下的$(\theta,\phi)$来表示。因此任何一个关于三维方向$\omega$的函数$f(\omega)$都可以转换成球面函数，该函数在SH基函数$B_i(\omega)$下的权重计算（即投影）公式为：</p>
<script type="math/tex; mode=display">
c_i=\int_{\Omega}f(\omega)B_i(\omega)d\omega \tag {11}</script><p>&emsp;&emsp;投影之后，再用$c_i$权重带入公式$(9)$可以对原始函数$f(\omega)$进行复原，这个过程我们称之为重建。当然，由于级数有无穷多个，我们通常也就用前几阶的SH基函数进行重建，相应带来的影响就是去掉了后面SH基函数蕴含的高频信息（频率截断，即低通滤波），结果只是对原函数的近似。</p>
<p>&emsp;&emsp;我们把目光放回到渲染方程上面：</p>
<script type="math/tex; mode=display">
L(o)=\int_{\Omega}L(i)V(i)\rho(i,o)max(0,n\cdot i)di \tag {12}</script><p>&emsp;&emsp;其中$\rho$是BRDF项，$V(i)$为可见性项。这个方程跟前面提到的形式不太一样，但本质不变，这里懒得改过来了。我们可以把积分里面的函数分成三类，分别是lighting项$L(i)$、visibility项$V(i)$和BRDF项$\rho(i,o)max(0,n\cdot i)$。如果我们直接暴力打表，为场景中的每个点，预计算存储上面的lighting项、visibility项和BRDF项，纹理分辨率为$64\times 64$，那么每个点的存储开销为$6\times 64\times 64$（之所以是$6$，是因为lighting项和BRDF项各占三个数，visibility项占一个数）。而且这仅仅是关于积分内的函数预存储，接下来还需要求解半球的积分方程！</p>
<p>&emsp;&emsp;这种暴力存储的方法并不可取，由此有研究者提出了一种非常精妙的方法来求解上述方程——<strong>Precomputed Radiance Transfer</strong>，简称PRT。PRT方法不仅极大减小了存储的开销，而且还巧妙地把半球的积分方程转化成SH基函数空间下的向量点乘（或者向量矩阵乘）操作，非常快速地实现了全局光照的效果！</p>
<p>&emsp;&emsp;PRT算法把前面公式$(12)$积分里面的函数分成两部分：$L_(i)$为lighting项，剩余的$V(i)\rho(i,o)max(0,n\cdot i)$被记为light transport项。先假定视角$o$固定不变，那么这两个项都是关于入射方向$i$的球面函数，都可以对其进行SH级数展开。</p>
<p>&emsp;&emsp;对lighting项的展开我们记为：</p>
<script type="math/tex; mode=display">
L(\omega_i)\approx\Sigma_p l_p B_p(\omega_i) \tag {13}</script><p>&emsp;&emsp;对light transport项的展开我们记为：</p>
<script type="math/tex; mode=display">
T(\omega_i)\approx \Sigma_q t_q B_q(\omega_i) \tag {14}</script><p>&emsp;&emsp;其中的$\omega_i$就是我们上面提到的入射方向$i$，$l_p$和$t_q$分别是相应的投影权重。将公式$(13)$和公式$(14)$带入渲染方程$(12)$，我们有如下的近似关系：</p>
<script type="math/tex; mode=display">
L_o(p,\omega_o)\approx \Sigma_p\Sigma_q l_pt_q\int_{\Omega^+}B_p(\omega_i)B_q(\omega_i) d\omega_i \tag {15}</script><p>&emsp;&emsp;根据我们前面提到的正交完备性，可知当$p\neq q$时，积分结果为$0$；当$p=q$时，积分结果为$1$。故而公式$(15)$可以继续化简为:</p>
<script type="math/tex; mode=display">
L_o(p,\omega_o)\approx \Sigma_il_i\cdot t_i \tag {16}</script><p>&emsp;&emsp;<strong>最终的公式直接把积分去掉了！这就是PRT算法的神奇之处</strong>。公式$(16)$告诉我们，如果我们能够计算出$l_i$和$t_i$，那么渲染方程结果就是这两个乘积的和。而这所谓的乘积的和实际上就是两个向量的点乘，向量维数取决于采用了多少个SH基函数，如果采用前三阶SH基函数，那么一共有$9$个，$l$和$t$分别是一个$9$维向量，每一个维度是一个rgb向量，即$9\times 3$个数。注意，每个rgb通道各自采用上述的公式$(16)$独立计算（即$l_i\cdot t_i$并非两个rgb向量点乘，特别注意！！！），因此计算结果也是一个rgb向量。</p>
<p>&emsp;&emsp;总而言之，PRT算法的关键之处在于$l$和$t$的计算。$l$是lighting项的SH基函数投影，套用前面的投影公式$(11)$则有：</p>
<script type="math/tex; mode=display">
l_p=\int_{S}L(\omega_i)B_p(\omega_i)d\omega_i \tag {17}</script><p>&emsp;&emsp;其中的积分区域$S$为球面所有方向。而$t$的计算类似，只是将light transport项代入投影公式即可：</p>
<script type="math/tex; mode=display">
t_p=\int_Sf_r(p,\omega_i,\omega_o)max(n\cdot \omega_i,0)V(\omega_i) B_p(\omega_i)d\omega_i \tag {18}</script><p>&emsp;&emsp;这里的计算有一个比较棘手的地方。前面我们假设$\omega_o$固定不变，但如果$\omega_o$变了呢？对于diffuse的BRDF，其本身与$\omega_o$无关，因此$\omega_o$无论如何变化，在预计算阶段我们都可以直接忽略。但如果是glossy材质，$f_r$是会随着观察视角$\omega_o$的变化而变化的！为此，对于glossy材质的BRDF，我们写成如下形式：</p>
<script type="math/tex; mode=display">
t_p(\omega_o)=\int_Sf_r(p,\omega_i,\omega_o)max(n\cdot \omega_i,0)V(\omega_i) B_p(\omega_i)d\omega_i \tag {19}</script><p>&emsp;&emsp;即<strong>对于glossy材质，我们需要增加一个变量$\omega_o$进行打表</strong>。遍历$\omega_o$的离散取值，为每一个不同的$\omega_o$生成一个light transport向量$t(\omega_o)$，因此glossy材质的$t$是一个矩阵，矩阵规模为$m\times n$，其中$m$是SH基函数个数，$n$是$\omega_o$离散化个数。对于glossy材质，计算最终的光照辐射率时是$l$向量和$t$矩阵的矩阵向量乘。</p>
<p>&emsp;&emsp;总而言之，对于diffuse材质，我们用公式$(17)$和公式$(18)$预计算$l$向量和$t$向量；对于glossy材质，我们用公式$(17)$和公式$(19)$计算$l$向量和$t$矩阵。最后用公式$(16)$计算光照辐射率。注意预计算阶段，$l$向量只需计算一次，而$t$则需要遍历场景中的所有点（例如网格顶点），为每个点计算一个$t$，然后作为顶点的属性值一起传输到着色器中。这些积分公式的求解，有很多方法，例如最基本的黎曼和亦或者蒙特卡洛积分。</p>
<h2 id="四、diffuse材质的PRT实现"><a href="#四、diffuse材质的PRT实现" class="headerlink" title="四、diffuse材质的PRT实现"></a>四、diffuse材质的PRT实现</h2><p>&emsp;&emsp;这里以diffuse材质为例讲一下PRT的实现。PRT的实现分成两个步骤：预计算阶段和实时渲染阶段。对于diffuse材质，其BRDF为以下的lambertian公式：</p>
<script type="math/tex; mode=display">
f_r(p,\omega_o,\omega_i)=\frac{\rho}{\pi} \tag {20}</script><p>&emsp;&emsp;其中，$\rho$为材质表面的反照率（diffuse颜色），这里我们假定其取值为$(1,1,1)$。因此，我们可以对前面的公式$(18)$进行简化，有：</p>
<script type="math/tex; mode=display">
t_p=\frac{\rho}{\pi}\int_Smax(n\cdot \omega_i,0)V(\omega_i) B_p(\omega_i)d\omega_i,p=0,1,...,8\tag {21}</script><p>&emsp;&emsp;把公式中的$V(\omega_i)$去掉就是不考虑场景自遮挡的情况。在这里我们只用前三阶SH基函数，那么一共有$9$个基函数，因此$p$取值为$0$到$8$。我们先来看lighting项的投影预计算，lighting项的投影公式为：</p>
<script type="math/tex; mode=display">
l_p=\int_{S}L(\omega_i)B_p(\omega_i)d\omega_i,p=1,...,(2l+1)^2,p=0,1,...,8</script><p>&emsp;&emsp;我们用黎曼和来对上述的积分公式进行近似：</p>
<script type="math/tex; mode=display">
l_p\approx\Sigma_i L(\omega_i) B_p(\omega_i) \Delta \omega_i,p=0,1,...,8</script><p>&emsp;&emsp;在实现时，我们遍历cubemao的所有像素，每个像素构成一个方向$\omega_i$，套用上面的黎曼和公式计算。球谐函数直接调库，这方便的轮子没必要再自己去造。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> SHNum = (SHOrder + <span class="number">1</span>) * (SHOrder + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Eigen::Array3f&gt; SHCoeffiecents(SHNum);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SHNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    SHCoeffiecents[i] = Eigen::Array3f(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> sumWeight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            Eigen::Vector3f dir = cubemapDirs[i * width * height + y * width + x];</span><br><span class="line">            <span class="keyword">int</span> index = (y * width + x) * channel;</span><br><span class="line">            Eigen::<span class="function">Array3f <span class="title">Le</span><span class="params">(images[i][index + <span class="number">0</span>], images[i][index + <span class="number">1</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                images[i][index + <span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> dwi = CalcArea(x, y, width, height);</span><br><span class="line">            Eigen::Vector3d _dir(Eigen::Vector3d(dir[<span class="number">0</span>], dir[<span class="number">1</span>], dir[<span class="number">2</span>]).normalized());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= SHOrder; l++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = -l; m &lt;= l; m++)</span><br><span class="line">                &#123;</span><br><span class="line">                    SHCoeffiecents[sh::GetIndex(l, m)] += Le * (<span class="keyword">float</span>)(sh::EvalSH(l, m, _dir)) * dwi;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于light transport的预计算，也是对前面的公式$(21)$类似的计算过程。只不过需要为每个顶点都计算一个$t$向量，然后存储到文件中。可见性函数我们用光线与场景的求交来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; ProjectFunction(</span><br><span class="line">    <span class="keyword">int</span> order, <span class="keyword">const</span> SphericalFunction&amp; func, <span class="keyword">int</span> sample_count) </span><br><span class="line">&#123;</span><br><span class="line">  CHECK(order &gt;= <span class="number">0</span>, <span class="string">"Order must be at least zero."</span>);</span><br><span class="line">  CHECK(sample_count &gt; <span class="number">0</span>, <span class="string">"Sample count must be at least one."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is the approach demonstrated in [1] and is useful for arbitrary</span></span><br><span class="line">  <span class="comment">// functions on the sphere that are represented analytically.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> sample_side = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">floor</span>(<span class="built_in">sqrt</span>(sample_count)));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; coeffs(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;());</span><br><span class="line">  coeffs-&gt;assign(GetCoefficientCount(order), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// generate sample_side^2 uniformly and stratified samples over the sphere</span></span><br><span class="line">  <span class="built_in">std</span>::random_device rd;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::uniform_real_distribution&lt;&gt; rng(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; sample_side; t++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; sample_side; p++) &#123;</span><br><span class="line">      <span class="keyword">double</span> alpha = (t + rng(gen)) / sample_side;</span><br><span class="line">      <span class="keyword">double</span> beta = (p + rng(gen)) / sample_side;</span><br><span class="line">      <span class="comment">// See http://www.bogotobogo.com/Algorithms/uniform_distribution_sphere.php</span></span><br><span class="line">      <span class="keyword">double</span> phi = <span class="number">2.0</span> * M_PI * beta;</span><br><span class="line">      <span class="keyword">double</span> theta = <span class="built_in">acos</span>(<span class="number">2.0</span> * alpha - <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// evaluate the analytic function for the current spherical coords</span></span><br><span class="line">      <span class="keyword">double</span> func_value = func(phi, theta);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// evaluate the SH basis functions up to band O, scale them by the</span></span><br><span class="line">      <span class="comment">// function's value and accumulate them over all generated samples</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= order; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = -l; m &lt;= l; m++) &#123;</span><br><span class="line">          <span class="keyword">double</span> sh = EvalSH(l, m, phi, theta);</span><br><span class="line">          (*coeffs)[GetIndex(l, m)] += func_value * sh;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">m_TransportSHCoeffs.resize(SHCoeffLength, mesh-&gt;getVertexCount());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;getVertexCount(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> Point3f&amp; v = mesh-&gt;getVertexPositions().col(i);</span><br><span class="line">    <span class="keyword">const</span> Normal3f&amp; n = mesh-&gt;getVertexNormals().col(i);</span><br><span class="line">    <span class="keyword">auto</span> shFunc = [&amp;](<span class="keyword">double</span> phi, <span class="keyword">double</span> theta) -&gt; <span class="keyword">double</span></span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::Array3d d = sh::ToVector(phi, theta);</span><br><span class="line">        <span class="keyword">const</span> Vector3f wi = Vector3f(d.x(), d.y(), d.z());</span><br><span class="line">        <span class="keyword">float</span> cos_theta = wi.dot(n);</span><br><span class="line">		<span class="keyword">if</span> (wi.dot(n) &gt; <span class="number">0.0f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!scene-&gt;rayIntersect(Ray3f(v, wi)))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> wi.dot(n) / M_PI;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> shCoeff = sh::ProjectFunction(SHOrder, shFunc, m_SampleCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; shCoeff-&gt;size(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_TransportSHCoeffs.col(i).coeffRef(j) = (*shCoeff)[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而如果要考虑多次弹射，那么可以通过迭代的方式计算$t$。在前一次迭代的基础上，从每个顶点发射一条射线，如果射线打中了另一个点，那么通过线性插值得到该点的前一次$t$，再乘以余弦项，最后累加。详情见下面代码（想偷懒了）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> tmp = m_TransportSHCoeffs;</span><br><span class="line"><span class="keyword">auto</span> interrefl = [&amp;](<span class="keyword">const</span> Point3f&amp; v, <span class="keyword">const</span> Normal3f&amp; n,</span><br><span class="line">    <span class="keyword">int</span> order, <span class="keyword">int</span> sample_count) -&gt; <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This is the approach demonstrated in [1] and is useful for arbitrary</span></span><br><span class="line">    <span class="comment">// functions on the sphere that are represented analytically.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sample_side = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">floor</span>(<span class="built_in">sqrt</span>(sample_count)));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; coeffs(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;());</span><br><span class="line">    coeffs-&gt;assign(sh::GetCoefficientCount(order), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate sample_side^2 uniformly and stratified samples over the sphere</span></span><br><span class="line">    <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::uniform_real_distribution&lt;&gt; rng(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; sample_side; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; sample_side; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> alpha = (t + rng(gen)) / sample_side;</span><br><span class="line">            <span class="keyword">double</span> beta = (p + rng(gen)) / sample_side;</span><br><span class="line">            <span class="keyword">double</span> phi = <span class="number">2.0</span> * M_PI * beta;</span><br><span class="line">            <span class="keyword">double</span> theta = <span class="built_in">acos</span>(<span class="number">2.0</span> * alpha - <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">            Eigen::Array3d d = sh::ToVector(phi, theta);</span><br><span class="line">            <span class="keyword">const</span> Vector3f wi = Vector3f(d.x(), d.y(), d.z());</span><br><span class="line"></span><br><span class="line">            Intersection its;</span><br><span class="line">            <span class="keyword">bool</span> intersected = scene-&gt;rayIntersect(Ray3f(v, wi), its);</span><br><span class="line">            <span class="keyword">float</span> V = (<span class="number">1</span> - intersected ? <span class="number">0</span> : <span class="number">1</span>) * wi.dot(n);<span class="comment">//(1-v)*cos_theta</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (V &gt; <span class="number">0.f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> Vector3f&amp; bary = its.bary;</span><br><span class="line">                <span class="keyword">auto</span> vertIndex = its.tri_index;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= order; l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> m = -l; m &lt;= l; m++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//double sh = EvalSH(l, m, phi, theta);</span></span><br><span class="line">                        <span class="keyword">int</span> index = sh::GetIndex(l, m);</span><br><span class="line">                        <span class="keyword">float</span> lastSH =</span><br><span class="line">                            bary.x() * tmp.col(vertIndex.x()).coeff(index) +</span><br><span class="line">                            bary.y() * tmp.col(vertIndex.y()).coeff(index) +</span><br><span class="line">                            bary.z() * tmp.col(vertIndex.z()).coeff(index);</span><br><span class="line">                        (*coeffs)[index] += lastSH * V;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scale by the probability of a particular sample, which is</span></span><br><span class="line">    <span class="comment">// 4pi/sample_side^2. 4pi for the surface area of a unit sphere, and</span></span><br><span class="line">    <span class="comment">// 1/sample_side^2 for the number of samples drawn uniformly.</span></span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">4.0</span> * M_PI / (sample_side * sample_side);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coeffs-&gt;size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*coeffs)[i] *= weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> coeffs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= m_Bounce; ++b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;getVertexCount(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> Point3f&amp; v = mesh-&gt;getVertexPositions().col(i);</span><br><span class="line">        <span class="keyword">const</span> Normal3f&amp; n = mesh-&gt;getVertexNormals().col(i);</span><br><span class="line">        <span class="keyword">auto</span> inteCoeff = interrefl(v, n, SHOrder, m_SampleCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inteCoeff-&gt;size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_TransportSHCoeffs.col(i).coeffRef(j) += ((*inteCoeff)[j] / M_PI);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = m_TransportSHCoeffs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;得到了$l$和$t$，在渲染时我们通过存储的文件将这些数据加载进来，然后传到着色器中。Vertex着色器代码如下（重点关注<code>L</code>和<code>LT</code>），这里实现的是Per-Vertex shading。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">attribute vec3 aVertexPosition;</span><br><span class="line">attribute vec3 aNormalPosition;</span><br><span class="line">attribute vec2 aTextureCoord;</span><br><span class="line">attribute mat3 aPrecomputeLT;</span><br><span class="line"></span><br><span class="line">uniform mat4 uModelMatrix;</span><br><span class="line">uniform mat4 uViewMatrix;</span><br><span class="line">uniform mat4 uProjectionMatrix;</span><br><span class="line"></span><br><span class="line">uniform mat3 uPrecomputedL[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">varying highp vec2 vTextureCoord;</span><br><span class="line">varying highp vec3 vFragPos;</span><br><span class="line">varying highp vec3 vNormal;</span><br><span class="line">varying highp vec3 vRadiance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dot</span><span class="params">(mat3 L, mat3 LT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> ret = <span class="number">0.0</span>;</span><br><span class="line">    ret = L[<span class="number">0</span>][<span class="number">0</span>] * LT[<span class="number">0</span>][<span class="number">0</span>] + L[<span class="number">0</span>][<span class="number">1</span>] * LT[<span class="number">0</span>][<span class="number">1</span>] + L[<span class="number">0</span>][<span class="number">2</span>] * LT[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">        + L[<span class="number">1</span>][<span class="number">0</span>] * LT[<span class="number">1</span>][<span class="number">0</span>] + L[<span class="number">1</span>][<span class="number">1</span>] * LT[<span class="number">1</span>][<span class="number">1</span>] + L[<span class="number">1</span>][<span class="number">2</span>] * LT[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">        + L[<span class="number">2</span>][<span class="number">0</span>] * LT[<span class="number">2</span>][<span class="number">0</span>] + L[<span class="number">2</span>][<span class="number">1</span>] * LT[<span class="number">2</span>][<span class="number">1</span>] + L[<span class="number">2</span>][<span class="number">2</span>] * LT[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vFragPos = (uModelMatrix * vec4(aVertexPosition, <span class="number">1.0</span>)).xyz;</span><br><span class="line">  vNormal = (uModelMatrix * vec4(aNormalPosition, <span class="number">0.0</span>)).xyz;</span><br><span class="line"></span><br><span class="line">  gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix *</span><br><span class="line">                vec4(aVertexPosition, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">  vTextureCoord = aTextureCoord;</span><br><span class="line"></span><br><span class="line">  vRadiance = vec3(</span><br><span class="line">      dot(uPrecomputedL[<span class="number">0</span>], aPrecomputeLT),</span><br><span class="line">      dot(uPrecomputedL[<span class="number">1</span>], aPrecomputeLT),</span><br><span class="line">      dot(uPrecomputedL[<span class="number">2</span>], aPrecomputeLT));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Fragment着色器代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_ES</span></span><br><span class="line">precision mediump <span class="keyword">float</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">uniform sampler2D uSampler;</span><br><span class="line"></span><br><span class="line">varying highp vec2 vTextureCoord;</span><br><span class="line">varying highp vec3 vFragPos;</span><br><span class="line">varying highp vec3 vNormal;</span><br><span class="line">varying highp vec3 vRadiance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  gl_FragColor = vec4(vRadiance * <span class="number">2.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;实现的效果比较见下图。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.43/blog/PRT/1.jpg" width="100%"></div></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>$[1]$ Sloan P P, Kautz J, Snyder J. Precomputed radiance transfer for real-time rendering in dynamic, low-frequency lighting environments[C]//Proceedings of the 29th annual conference on Computer graphics and interactive techniques. 2002: 527-536.</p>
<p>$[2]$ <a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html" target="_blank" rel="noopener">GAMES202: 高质量实时渲染</a></p>

        </div>
        
          


  <section class="meta" id="footer-meta">
    <hr>
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-04-29T21:44:19+08:00">
  <a class="notlink">
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>最后更新于 2021年4月29日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Computer-Graphics/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Computer Graphics</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Real-time-Rendering/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Real-time Rendering</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yangwc.com/2021/04/29/PRT/&title=高质量实时渲染：实时环境光 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本文是闫令琪老师GAMES202高质量实时渲染课程的学习笔记和总结，这一节的主题为高质量实时环境光照，内容分为IBL（Imaged Based Lighting）和PRT（Precomputed Radiance Transfer）。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://yangwc.com/2021/04/29/PRT/&title=高质量实时渲染：实时环境光 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本文是闫令琪老师GAMES202高质量实时渲染课程的学习笔记和总结，这一节的主题为高质量实时环境光照，内容分为IBL（Imaged Based Lighting）和PRT（Precomputed Radiance Transfer）。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=https://yangwc.com/2021/04/29/PRT/&title=高质量实时渲染：实时环境光 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本文是闫令琪老师GAMES202高质量实时渲染课程的学习笔记和总结，这一节的主题为高质量实时环境光照，内容分为IBL（Imaged Based Lighting）和PRT（Precomputed Radiance Transfer）。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2021/04/14/PCSS/" rel="prev" title="高质量实时渲染：实时软阴影">
                                    
                                        高质量实时渲染：实时软阴影
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Real-time-Rendering/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Real-time Rendering</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
        <section id="comments">
          <div id="lv-container" data-id="city" data-uid="MTAyMC80MzkxOS8yMDQ1NQ==">
            <noscript><div><i class="fas fa-exclamation-triangle">&nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。</i></div></noscript>
          </div>
        </section>
      
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

  <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



  <script>
    window.subData = {
      title: '高质量实时渲染：实时环境光',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content material">
    
      <div class="avatar">
        <fancybox><img class="avatar" src="/image/avator.jpg"></fancybox>
      </div>
    
    
      <div class="text">
        
          <h2>YangWC</h2>
        
        
          <p>A student from Sun Yat-sen University.</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget toc-wrapper">
    
<header class="material">
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class="content material">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、前言"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Imaged-Based-Lighting"><span class="toc-text">二、Imaged Based Lighting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Precomputed-Radiance-Transfer"><span class="toc-text">三、Precomputed Radiance Transfer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、diffuse材质的PRT实现"><span class="toc-text">四、diffuse材质的PRT实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class="widget plain">
  
<header class="material">
  <div><i class=" fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;欢迎来到YangWC的博客</div>
  
</header>

  <div class="content material">
    <p>本站会记录自己的一些学习内容，如若有错或者乱码，欢迎指正，感谢!</p>

  </div>
</section>

          
        
      
        
          
          
            <section class="widget grid">
  
<header class="material">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content material">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于博主
        </a></li>
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn" rel="nofollow" href="/categories/" title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/2D-Rendering/" href="/categories/2D-Rendering/"><div class="name">2D Rendering</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Computer-Graphics/" href="/categories/Computer-Graphics/"><div class="name">Computer Graphics</div><div class="badge">(34)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-Simulation/" href="/categories/Fluid-Simulation/"><div class="name">Fluid Simulation</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-simulation/" href="/categories/Fluid-simulation/"><div class="name">Fluid  simulation</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Image-processing/" href="/categories/Image-processing/"><div class="name">Image processing</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/N-body/" href="/categories/N-body/"><div class="name">N-body</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physical-simulation/" href="/categories/Physical-simulation/"><div class="name">Physical simulation</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physically-Based-Rendering/" href="/categories/Physically-Based-Rendering/"><div class="name">Physically Based Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Position-Based-Dynamics/" href="/categories/Position-Based-Dynamics/"><div class="name">Position Based Dynamics</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Ray-Tracer/" href="/categories/Ray-Tracer/"><div class="name">Ray Tracer</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Real-time-Rendering/" href="/categories/Real-time-Rendering/"><div class="name">Real-time Rendering</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Soft-Renderer/" href="/categories/Soft-Renderer/"><div class="name">Soft Renderer</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Voxelization/" href="/categories/Voxelization/"><div class="name">Voxelization</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class="widget tagcloud">
    
<header class="material">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn" rel="nofollow" href="/tags/" title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <a href="/tags/2D-Rendering/" style="font-size: 14px; color: #bbb">2D Rendering</a> <a href="/tags/3D-Math/" style="font-size: 14px; color: #bbb">3D Math</a> <a href="/tags/3D-pipeline/" style="font-size: 16px; color: #c9c9c9">3D pipeline</a> <a href="/tags/Advection/" style="font-size: 14px; color: #bbb">Advection</a> <a href="/tags/Computer-Graphics/" style="font-size: 24px; color: #fff">Computer Graphics</a> <a href="/tags/Fluid-Simulation/" style="font-size: 22px; color: #f1f1f1">Fluid Simulation</a> <a href="/tags/Fluid-simulation/" style="font-size: 14px; color: #bbb">Fluid simulation</a> <a href="/tags/Glow-effect/" style="font-size: 14px; color: #bbb">Glow effect</a> <a href="/tags/Image-processing/" style="font-size: 14px; color: #bbb">Image processing</a> <a href="/tags/N-body/" style="font-size: 14px; color: #bbb">N-body</a> <a href="/tags/Naiver-Stokes-Equations/" style="font-size: 14px; color: #bbb">Naiver-Stokes Equations</a> <a href="/tags/Physical-simulation/" style="font-size: 14px; color: #bbb">Physical simulation</a> <a href="/tags/Physically-Based-Rendering/" style="font-size: 16px; color: #c9c9c9">Physically Based Rendering</a> <a href="/tags/Position-Based-Dynamics/" style="font-size: 18px; color: #d6d6d6">Position Based Dynamics</a> <a href="/tags/Rasterization/" style="font-size: 14px; color: #bbb">Rasterization</a> <a href="/tags/Ray-Tracer/" style="font-size: 22px; color: #f1f1f1">Ray Tracer</a> <a href="/tags/Real-time-Rendering/" style="font-size: 20px; color: #e4e4e4">Real-time Rendering</a> <a href="/tags/Soft-Renderer/" style="font-size: 20px; color: #e4e4e4">Soft Renderer</a> <a href="/tags/Voxelization/" style="font-size: 14px; color: #bbb">Voxelization</a>
    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
	<script>
		var now = new Date(); 
		function createtime() { 
			var grt= new Date("04/24/2019 18:00:00");//在此处修改你的建站时间
			now.setTime(now.getTime()+250); 
			days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
			hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
			if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
			mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
			seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
			snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
			document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
			document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
		} 
	setInterval("createtime()",250);
   </script>
   
   <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->
	
	
	<script>setLoadingBarProgress(80);</script>
</footer>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>









  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>






  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  
    <!--数字雨背景-->
  <canvas id="canvas" width="1440" height="900" ></canvas>
  <script>
	var s = window.screen;
	var width = canvas.width = s.width;
	var height = canvas.height = s.height;
	var fontSize = 13;
	var colunms = Math.floor(width/fontSize);
	var letters = [];
    for(var i=0;i<colunms;i++){
        letters.push(1);
    }
	var draw = function () {
	    canvas.getContext('2d').fillStyle = "rgba(0,0,0,.08)";//遮盖层
		canvas.getContext('2d').fillRect(0,0,width,height);
		canvas.getContext('2d').font = "700 " + fontSize +"px  微软雅黑";
		letters.map(function(y_pos, index){
		text = String.fromCharCode(34+Math.random()*33);
		x_pos = index * fontSize;
		canvas.getContext('2d').fillText(text, x_pos, y_pos);
		letters[index] = (y_pos > 758 + Math.random() * 1e4) ? 0 : y_pos + 10;
		canvas.getContext('2d').fillStyle='#'+letters[index];
	  });
	};
	setInterval(draw, 33);
  </script>
  
  <!-- 页面点击出现文字 -->
  <script type="text/javascript" src="/js/ClickShowText.js"></script>
  
  <script>setLoadingBarProgress(100);</script>
</body>
</html>
