<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>实时渲染Real-time Rendering：Image Based Lighting | YangWC&#39;s Blog</title>
  
  
  <meta name="description" content="Personal blog website.">
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/logo.ico">
  

  
    <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fdf716664defeee80e01568ddbeb2425";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
  
</head>
<body>
  
  
  <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          YangWC's Blog
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/" id="home">
									<i class="fas fa-grin fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
									<i class="fas fa-tag fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
									<i class="fas fa-info-circle fa-fw"></i>&nbsp;关于博主
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-grin fa-fw"></i>&nbsp;主页
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
								<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
								<i class="fas fa-tag fa-fw"></i>&nbsp;标签
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;关于博主
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      <div class="l_main">
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/07/21/ImageBasedLighting/">
        实时渲染Real-time Rendering：Image Based Lighting
      </a>
    </h1>
  


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="http://yoursite.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-21</p>
  </a>
</div>

          
        
          
            
  
  <div class="new-meta-item category">
    <a href="/categories/Physically-Based-Rendering/" rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Computer Graphics&nbsp;/&nbsp;Real-time Rendering&nbsp;/&nbsp;Physically Based Rendering</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p>本文在前一篇PBR渲染器的基础上，进一步深入理解并实现了Image Based Lighting的全局光照。Image Based Lighting预先烘培辐照度贴图、构建BRDF积分查找表，然后在实时渲染中直接查询查找表快速计算渲染方程，实现的效果高效且真实。这种技术已经集成在虚幻4引擎中。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/header.png" width="99%"></div></p>
<a id="more"></a>
<ul>
<li>渲染方程的求解</li>
<li>hdr文件转成cubemap</li>
<li>预计算漫反射积分</li>
<li>预计算镜面反射积分</li>
<li>计算渲染方程</li>
<li>实现效果</li>
<li>参考资料</li>
</ul>
<center><font size="6">Image Based Lighting</font></center>
&emsp;&emsp;在前面一篇基于物理的渲染中我们仅仅考虑了直接光照部分，仅仅考虑直接光照时求解渲染方程非常简单，只需需根据给定的光源直接计算并叠加，而不需要在法线轴向的半球方向做积分。Image Based Lighting（以下简称IBL）翻译过来的意思就是基于图像的光照，这种技术专门计算来自于周围环境的间接光照，周围环境的光影信息存储在一张环境贴图中，这个环境贴图可以是预先生成好的，也可以是运行时动态生成好的。IBL技术使得物体的光照效果与周围的环境更加融合，大大增强沉浸感。



## 一、渲染方程的求解

&emsp;&emsp;IBL的渲染方程与PBR一样，即特化的渲染方程——反射方程，如下所示：
$$
L_o(p,\omega_o)=\int_{\Omega}(k_d\frac{c}{\pi}+\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)})L_i(p,\omega_i)n\cdot \omega_id\omega_i \tag {1}
$$
&emsp;&emsp;我们实现基于物理的光照效果的本质就是要计算上面的渲染方程，它是对半球方向$\Omega$的所有$\omega_i$积分。在前面一偏PBR中我们求解这个积分方程非常容易，因为仅考虑直接光照且光源为非面积光源时，上述的被积函数部分是一个狄拉克函数，即除了在光源方向上函数值不为$0$，在半球内的其余定义域该被积函数均为$0$，因此没有必要求半球积分，或者说半球积分的值就等于在光源方向上的被积函数值。但是在IBL中，就没有这么简单了。我们把环境贴图中的每一个像素都当作一个光源，这使得我们必须要求解半球方向的积分，即在整个半球方向采样光照信息。如果我们直接暴力求解渲染方程$(1)$的话，在每一个片元着色器上我们都要计算渲染方程的半球积分，耗费极大的性能，这对于实时性应用来说几乎不可能。

&emsp;&emsp;因此，为了高效地求解渲染积分方程，IBL方法将渲染方程中的积分项预先计算出来并存储到指定的纹理图片上，在后面进行光照计算的时候根据相关的信息索引预先计算好的积分值，从而快速高效地求解积分。这其实就是以空间换时间的思想。为了方便预先计算积分值，我们把公式$(1)$写成如下的形式：
$$
L_o(p,\omega_o)
=\int_{\Omega}(k_d\frac{c}{\pi}+\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)})L_i(p,\omega_i)n\cdot \omega_id\omega_i\\
=\int_{\Omega}k_d\frac{c}{\pi}L_i(p,\omega_i)n\cdot \omega_id\omega_i
+\int_{\Omega}(\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)})L_i(p,\omega_i)n\cdot \omega_id\omega_i \tag {2}
$$
&emsp;&emsp;上面公式$(2)$的两个项分别对应光照的漫反射部分和镜面反射部分，我们把这两部分分开来，然后分别单独计算漫反射的积分值、镜面反射的积分值，这个其实相当于对立方体环境贴图做一个特殊的卷积操作，计算得到的结果分别存储到各自指定查找表中供后续的渲染使用。这个就是IBL算法的核心思想，接下来我们就围绕这个核心思想展开相应的实现细节。



## 二、hdr文件转成cubemap

&emsp;&emsp;在实现积分预计算之前我们还有一件事要完成，就是获取周围环境贴图的辐射率值，因为我们把环境贴图的每一个像素都当作一个光源。在进行积分计算时，我们要根据给定的入射方向$\omega_i$去获取该方向上辐射过来的辐射率值。如果环境贴图是一个立方体贴图的话，这很容易实现，因为立方体贴图就是根据三维向量进行索引的。但是在IBL中我们的环境贴图并不是一个普通的环境贴图，普通的环境贴图的像素值在低动态范围（Low Dynamic Range），即每个像素的分量不超过1.0。IBL同样是PBR渲染方法，为了能够捕捉真实的物理光影和细节，我们的环境贴图应该是高动态范围的（High Dynamic Range）。

&emsp;&emsp;目前有一种以.hdr为后缀的图像格式保存了高动态范围的像素值，这种格式的文件采用一种巧妙的方法将超出$0.0$到$1.0$的正确的颜色值保存下来。高动态范围的环境贴图就采用了这种格式保存，stb_image支持.hdr文件加载。[这里](http://www.hdrlabs.com/sibl/archive.html)收集了一些hdr格式的环境贴图，stb_image加载.hdr文件也非常简单，如下所示：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> *data = stbi_loadf(path.c_str(), &amp;m_width, &amp;m_height, &amp;m_channel, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

&emsp;&emsp;加载后得到的图片如下图1所示，这是一个二维的图片，类似于广角镜头拍摄得到的画面。.hdr格式保存的不是六张独立的图片，它将6张图片从球面投影到一个二维的平面上，从而构成下面这张略带扭曲的矩形纹理图。为了后续方便获取指定像素的纹理值，我们需要把这张矩形的hdr图转换成立方体贴图。

<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/1.jpg" width="80%">
<center> 图1 .hdr贴图 </center>


<p>&emsp;&emsp;从hdr转换到cubemap的过程其实就是利用球面投影到二维平面，可以理解为球面的纹理映射为二维的纹理（或者说球面上的点映射到二维平面上的点）。这个映射过程就是利用了球坐标和笛卡尔坐标的关系，对于一个球心在原点的单位球体上的点$(x,y,z)$，我们也可以用采用天顶角$\theta$（与$xz$平面的夹角）和方位角$\phi$（在$xz$平面上与$x$轴的夹角）来唯一地表示，他们的关系如下：</p>
<script type="math/tex; mode=display">
x=cos(\theta)cos(\phi)\\
y=sin(\theta) \\
z=cos(\theta)sin(\phi)  \tag {3}</script><p>&emsp;&emsp;其中$\theta$的取值范围为$[-\pi/2,+\pi/2]$，$\phi$的取值范围为$[-\pi,+\pi]$，我们很容易地可以分别将其映射到二维纹理坐标uv的$[0,1]$，这样我们就将一个三维立方体贴图纹理坐标映射到了二维的纹理坐标，这个其实就是构建.hdr时的映射过程。现在我们要再现这个过程，获取三维纹理坐标对应的二维纹理坐标，然后索引上面的hdr贴图，从而得到三维纹理坐标对应的像素值，并将其保存到cubemap当中。我们采用的方法就是绘制6次立方体，每次保存1个立方体面的像素值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IBLAuxiliary::convertToCubemap(<span class="keyword">int</span> width, <span class="keyword">int</span> height,</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hdrTexIndex, <span class="keyword">unsigned</span> <span class="keyword">int</span> cuebmapTexIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// manager.</span></span><br><span class="line">	TextureMgr::ptr texMgr = TextureMgr::getSingleton();</span><br><span class="line">	ShaderMgr::ptr shaderMgr = ShaderMgr::getSingleton();</span><br><span class="line">	<span class="comment">// load shader.</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> shaderIndex = shaderMgr-&gt;loadShader(<span class="string">"convertToCubemap"</span>,</span><br><span class="line">		<span class="string">"./glsl/convertToCubemap.vert"</span>, <span class="string">"./glsl/convertToCubemap.frag"</span>);</span><br><span class="line">	<span class="comment">// load cube mesh.</span></span><br><span class="line">	Mesh::ptr cubeMesh = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Mesh&gt;(<span class="keyword">new</span> Cube(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">	<span class="comment">// load framebuffer.</span></span><br><span class="line">	FrameBuffer::ptr framebuffer = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;FrameBuffer&gt;(<span class="keyword">new</span> FrameBuffer(width, height,</span><br><span class="line">		<span class="string">"convertDepth"</span>, &#123;&#125;, <span class="literal">true</span>));</span><br><span class="line">	<span class="comment">// projection matrix and view matrix.</span></span><br><span class="line">	glm::mat4 captureProjectMatrix = glm::perspective(glm::radians(<span class="number">90.0f</span>), <span class="number">1.0f</span>, <span class="number">0.1f</span>, <span class="number">10.0f</span>);</span><br><span class="line">	glm::mat4 captureViewMatrix[] =</span><br><span class="line">	&#123;</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(+<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,+<span class="number">1.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,+<span class="number">1.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,<span class="number">-1.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,<span class="number">-1.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,+<span class="number">1.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="number">-1.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// convert.</span></span><br><span class="line">	framebuffer-&gt;bind();</span><br><span class="line">	glDisable(GL_BLEND);</span><br><span class="line">	glDisable(GL_CULL_FACE);</span><br><span class="line">	glEnable(GL_DEPTH_TEST);</span><br><span class="line">	glDepthFunc(GL_LEQUAL);</span><br><span class="line">	glClearColor(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	GLuint cubemapId = texMgr-&gt;getTexture(cuebmapTexIndex)-&gt;getTextureId();</span><br><span class="line">	Shader::ptr shader = shaderMgr-&gt;getShader(shaderIndex);</span><br><span class="line">	shader-&gt;bind();</span><br><span class="line">	shader-&gt;setInt(<span class="string">"hdrMap"</span>, <span class="number">0</span>);</span><br><span class="line">	shader-&gt;setMat4(<span class="string">"projectMatrix"</span>, captureProjectMatrix);</span><br><span class="line">	texMgr-&gt;bindTexture(hdrTexIndex, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		shader-&gt;setMat4(<span class="string">"viewMatrix"</span>, captureViewMatrix[i]);</span><br><span class="line">		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">			GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, cubemapId, <span class="number">0</span>);</span><br><span class="line">		cubeMesh-&gt;draw(<span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	shader-&gt;unBind();</span><br><span class="line">	texMgr-&gt;unBindTexture(hdrTexIndex);</span><br><span class="line">	framebuffer-&gt;unBind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;相应的，在着色器中我们将三维纹理坐标投影到二维纹理坐标，索引hdr值，输出为片元着色器的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">=======================Vertex Shader=======================</span><br><span class="line">#version <span class="number">330</span> core</span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line">layout (location = <span class="number">2</span>) in vec2 texcoord;</span><br><span class="line">layout (location = <span class="number">3</span>) in vec3 color;</span><br><span class="line"></span><br><span class="line">out vec3 worldPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	worldPos = position;</span><br><span class="line">	gl_Position = projectMatrix * viewMatrix * vec4(position,<span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======================Fragment Shader=====================</span><br><span class="line">#version <span class="number">330</span> core</span><br><span class="line">in vec3 worldPos;</span><br><span class="line">out vec4 fragColor;</span><br><span class="line"></span><br><span class="line">uniform sampler2D hdrMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1/(pi/2), 1/(pi))</span></span><br><span class="line"><span class="keyword">const</span> vec2 invAtan = vec2(<span class="number">0.1591</span>, <span class="number">0.3183</span>);</span><br><span class="line"><span class="function">vec2 <span class="title">sampleSphericalMap</span><span class="params">(vec3 v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec2 uv = vec2(<span class="built_in">atan</span>(v.z, v.x), <span class="built_in">asin</span>(v.y));</span><br><span class="line">	<span class="comment">// to [0,1].</span></span><br><span class="line">	uv *= invAtan;</span><br><span class="line">	uv += vec2(<span class="number">0.5f</span>);</span><br><span class="line">	<span class="keyword">return</span> uv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// map 3d texcoord to 2d texcoord.</span></span><br><span class="line">	vec2 uv = sampleSphericalMap(normalize(worldPos));</span><br><span class="line">	<span class="comment">// sample hdr map.</span></span><br><span class="line">	vec3 sampler = texture(hdrMap, uv).rgb;</span><br><span class="line">	<span class="comment">// save to one face of cubemap.</span></span><br><span class="line">	fragColor = vec4(sampler, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上面的步骤，我们就将一个二维的hdr贴图转换成cubemap，如下图2所示，方便我们后续的使用。有了这个高动态范围的环境贴图，接下来我们就展开漫反射积分和镜面反射积分的预计算。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/2.png" width="99%"></div></p>
<center> 图2 hdr立方体贴图 </center>





<h2 id="三、预计算漫反射积分"><a href="#三、预计算漫反射积分" class="headerlink" title="三、预计算漫反射积分"></a>三、预计算漫反射积分</h2><p>&emsp;&emsp;首先来看渲染方程中的漫反射积分部分，把它单独拎出来：</p>
<script type="math/tex; mode=display">
\int_{\Omega}k_d\frac{c}{\pi}L_i(p,\omega_i)n\cdot \omega_id\omega_i
=k_d\frac{c}{\pi}\int_{\Omega}L_i(p,\omega_i)n\cdot \omega_id\omega_i \tag {4}</script><p>&emsp;&emsp;上面的积分公式中，积分变量为$\omega_i$，和$\frac{c}{\pi}$项都与$\omega_i$无关，故可以提出积分外。我们实际上要求积分的被积函数是$L_i(p,\omega_i)n\cdot \omega_i$。假设点$p$在原点，则对于每一个$n$确定的半球方向，积分值仅仅取决于$\omega_i$。因此，我们遍历所有的$n$，然后预先计算其积分值$\int_{\Omega}L_i(p,\omega_i)n\cdot \omega_id\omega_i$到一张cubemap当中，最后渲染时直接用$n$去采样这个cubemap得到预先计算好的积分值。这个就是预计算漫反射积分的思路。</p>
<p>&emsp;&emsp;$n$就是给定法线向量，它的取值范围就是所有方向，相当于一个球心在原点的单位球体上的所有点。为了遍历所有的$n$，我们送入一个立方体进行预计算的渲染，不需要球体，因为立方体的顶点归一化normalize之后也就是对应的球面上的点。然后在片元着色器根据这个$n$进行半球方向的积分，最后存储到cubemap当中。同样的，我们需要绘制6次，每次绘制保存到cubemap的六个面中的一面。</p>
<p>&emsp;&emsp;然后就是关于公式$(4)$当中的积分数值计算。首先需要注意的是公式$(4)$当中的积分变量$\omega_i$是立体角，为了方便计算，我们需要把他转成以天顶角$\theta$和方位角$\phi$为变量的表示形式。前面在<a href="https://yangwc.com/2019/05/23/RayTracer-Advance/" target="_blank" rel="noopener">光线追踪器Ray Tracer：进阶篇</a>已经提到过微分立体角$d\omega_i$如何转成用$d\theta$和$d\phi$表示，即$d\omega_i=sin\theta d\theta d\phi$。因此，公式$(4)$中的积分项转成如下的二重积分：</p>
<script type="math/tex; mode=display">
k_d\frac{c}{\pi}\int_{\Omega}L_i(p,\omega_i)n\cdot \omega_id\omega_i
=
k_d\frac{c}{\pi}\int_{\phi=0}^{2\pi}\int_{\theta=0}^{\frac12\pi}L_i(p,\phi_i,\theta_i)cos\theta sin \theta d\theta d\phi \tag {5}</script><p>&emsp;&emsp;这里要提一下，公式$(4)$中的$n\cdot \omega_i$就是$cos\theta$，半球方向内$\theta$取值$[0,\frac12\pi]$，$\phi$取值$[0,2\pi]$。公式$(5)$等号两边完全是等价的。然后我们需要采用数值方法近似计算公式$(5)$的积分值，在半球方向做均匀的离散采样$(\phi,\theta)$，计算采样的方向对应的被积函数值，最后叠加起来，叠加的结果就是黎曼积分和。公式$(5)$的黎曼积分近似公式为：</p>
<script type="math/tex; mode=display">
k_d\frac{c}{\pi}\int_{\phi=0}^{2\pi}\int_{\theta=0}^{\frac12\pi}L_i(p,\phi_i,\theta_i)cos\theta sin \theta d\theta d\phi
\approx k_d\frac{c}{\pi}\Sigma_0^{2\pi}\Sigma_0^{\frac12\pi}L_i(p, \phi_i, \theta_i)cos\theta
sin\theta d\theta d\phi \tag{6}</script><p>&emsp;&emsp;对于公式$(6)$中的黎曼积分，我们需要确定$d\theta$和$d\phi$，即数值积分步长。这个步长越小，则计算结果越接近于理论值，但耗费的时间也越多。此外还需要提的是，我们是在切线空间的半球方向进行采样的，在切线空间获取采样的方向向量之后，我们需要把它转换到世界空间，这里我们没有构建变换矩阵，直接计算切线空间的三个基向量。计算近似的黎曼积分的着色器代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">============================Vertex   Shader=======================</span><br><span class="line">#version <span class="number">330</span> core</span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line">layout (location = <span class="number">2</span>) in vec2 texcoord;</span><br><span class="line">layout (location = <span class="number">3</span>) in vec3 color;</span><br><span class="line"></span><br><span class="line">out vec3 worldPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	worldPos = position;</span><br><span class="line">	gl_Position = projectMatrix * viewMatrix * vec4(position,<span class="number">1.0f</span>);</span><br><span class="line">&#125;    </span><br><span class="line">============================Fragment Shader=======================</span><br><span class="line">#version <span class="number">330</span> core</span><br><span class="line">in vec3 worldPos;</span><br><span class="line">out vec4 fragColor;</span><br><span class="line"></span><br><span class="line">uniform samplerCube environmentMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec3 normal = normalize(worldPos);</span><br><span class="line">	vec3 irradiance = vec3(<span class="number">0.0f</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// tangent space.</span></span><br><span class="line">	vec3 up = vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	vec3 right = cross(up, normal);</span><br><span class="line">	up = cross(normal, right);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">float</span> sampleDelta = <span class="number">0.025</span>;</span><br><span class="line">	<span class="keyword">float</span> sampleDeltaSquared = sampleDelta * sampleDelta;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">float</span> phi = <span class="number">0.0f</span>; phi &lt; <span class="number">2.0</span> * PI;phi += sampleDelta)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">float</span> theta = <span class="number">0.0f</span>; theta &lt; <span class="number">0.5</span> * PI;theta += sampleDelta)</span><br><span class="line">		&#123;</span><br><span class="line">			vec3 sampleDir = vec3(<span class="built_in">sin</span>(theta) * <span class="built_in">cos</span>(phi), <span class="built_in">sin</span>(theta) * <span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(theta));</span><br><span class="line">			<span class="comment">// tangent space to world space.</span></span><br><span class="line">			sampleDir = sampleDir.x * right + sampleDir.y * up + sampleDir.z * normal;</span><br><span class="line">			</span><br><span class="line">			irradiance += texture(environmentMap, sampleDir).rgb * <span class="built_in">cos</span>(theta) * <span class="built_in">sin</span>(theta) * sampleDeltaSquared;</span><br><span class="line">			++ nSamples;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	irradiance = (<span class="number">1.0f</span> / PI) * irradiance ;</span><br><span class="line">	fragColor = vec4(irradiance, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在片元着色器中，我们取采样步长$d\phi$和$d\theta$均为$0.025$，然后是两重循环，获取采样方向向量的$(\phi,\theta)$后我们需要把它转换成笛卡尔坐标下的方向向量，用这个方向相应去获取该方向对应的hdr立方体纹理。最后结果除以一个$\pi$，对应公式$(6)$中的$\pi$，而剩下的漫反射因子$k_d$和反照率$c$由渲染时确定。上面的过程相当于对hdr立方体贴图做一个卷积操作，存储结果的纹理我们称之为辐照度纹理（Irradiance Map）。由于辐照度纹理没有高频的细节，因此我们不需要设置太大分辨率，在cpu端创建一个$64\times 64$大小的cubemap，然后调用着色器绘制6次写入这个cubemap当中，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IBLAuxiliary::convoluteDiffuseIntegral(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">unsigned</span> <span class="keyword">int</span> cubemapTexIndex, <span class="keyword">unsigned</span> <span class="keyword">int</span> irradianceTexIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// manager.</span></span><br><span class="line">	TextureMgr::ptr texMgr = TextureMgr::getSingleton();</span><br><span class="line">	ShaderMgr::ptr shaderMgr = ShaderMgr::getSingleton();</span><br><span class="line">	<span class="comment">// load shader.</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> shaderIndex = shaderMgr-&gt;loadShader(<span class="string">"diffuseIntegral"</span>,</span><br><span class="line">		<span class="string">"./glsl/diffuseIntegral.vert"</span>, <span class="string">"./glsl/diffuseIntegral.frag"</span>);</span><br><span class="line">	<span class="comment">// load cube mesh.</span></span><br><span class="line">	Mesh::ptr cubeMesh = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Mesh&gt;(<span class="keyword">new</span> Cube(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">	<span class="comment">// load framebuffer.</span></span><br><span class="line">	FrameBuffer::ptr framebuffer = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;FrameBuffer&gt;(</span><br><span class="line">		<span class="keyword">new</span> FrameBuffer(width, height, <span class="string">"irradianceDepth"</span>, &#123;&#125;, <span class="literal">true</span>));</span><br><span class="line">	<span class="comment">// projection matrix and view matrix.</span></span><br><span class="line">	glm::mat4 captureProjectMatrix = glm::perspective(glm::radians(<span class="number">90.0f</span>), <span class="number">1.0f</span>, <span class="number">0.1f</span>, <span class="number">10.0f</span>);</span><br><span class="line">	glm::mat4 captureViewMatrix[] =</span><br><span class="line">	&#123;</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(+<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,+<span class="number">1.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,+<span class="number">1.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,<span class="number">-1.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,<span class="number">-1.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,+<span class="number">1.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="number">-1.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// begin to convolute.</span></span><br><span class="line">	framebuffer-&gt;bind();</span><br><span class="line">	glDisable(GL_BLEND);</span><br><span class="line">	glDisable(GL_CULL_FACE);</span><br><span class="line">	glEnable(GL_DEPTH_TEST);</span><br><span class="line">	glDepthFunc(GL_LEQUAL);</span><br><span class="line">	glClearColor(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	GLuint irradianceTexId = texMgr-&gt;getTexture(irradianceTexIndex)-&gt;getTextureId();</span><br><span class="line">	Shader::ptr shader = shaderMgr-&gt;getShader(shaderIndex);</span><br><span class="line">	shader-&gt;bind();</span><br><span class="line">	shader-&gt;setInt(<span class="string">"environmentMap"</span>, <span class="number">0</span>);</span><br><span class="line">	shader-&gt;setMat4(<span class="string">"projectMatrix"</span>, captureProjectMatrix);</span><br><span class="line">	texMgr-&gt;bindTexture(cubemapTexIndex, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		shader-&gt;setMat4(<span class="string">"viewMatrix"</span>, captureViewMatrix[i]);</span><br><span class="line">		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">			GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, irradianceTexId, <span class="number">0</span>);</span><br><span class="line">		cubeMesh-&gt;draw(<span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	shader-&gt;unBind();</span><br><span class="line">	texMgr-&gt;unBindTexture(cubemapTexIndex);</span><br><span class="line">	framebuffer-&gt;unBind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上的预计算或者说预烘培步骤只需执行一次，然后我们就得到了一张辐照度立方体贴图，如下图3所示，可以看到类似对原来的立方体贴图做了一个模糊处理，但这并不是模糊处理。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/3.png" width="99%"></div></p>
<center> 图3 预烘培得到的辐照度纹理 </center>




<h2 id="四、预计算镜面反射积分"><a href="#四、预计算镜面反射积分" class="headerlink" title="四、预计算镜面反射积分"></a>四、预计算镜面反射积分</h2><p>&emsp;&emsp;接下来我们就把目标转到镜面反射的积分预计算上面。我们要预计算的就是渲染方程$(2)$中的镜面反射部分，如下所示：</p>
<script type="math/tex; mode=display">
\int_{\Omega}(\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)})L_i(p,\omega_i)n\cdot \omega_id\omega_i =\int_{\Omega}f_r(p,\omega_i,\omega_o)L_i(p,\omega_i)n\cdot \omega_id\omega_i \tag {7}</script><p>&emsp;&emsp;被积函数中的$f_r(p,\omega_i,\omega_o)$是之前提到的brdf函数，它与积分变量$\omega_i$有关，因此它不是一个常量，我们不能像前面的漫反射积分那样把brdf函数当作常数项并提出积分外。除此之外，我们还注意到最终的积分值还取决于出射方向或者说观察方向$\omega_o$，因此公式$(7)$的积分值取决于$n$和$\omega_o$这两个三维的向量。前面的漫反射积分仅取决于$n$，所以我们可以很容易地遍历所有的$n$，然后将积分值存储到立方体贴图中。但是在镜面反射积分这里，积分值取决于$n$和$\omega_o$，这使得问题变得复杂起来，这是因为我们不能同时用$n$和$\omega_o$去索引立方体贴图。Epic Games公司提出了提出了一种近似的方案，这种方法就是将公式$(7)$中的积分分成两部分：</p>
<script type="math/tex; mode=display">
\int_{\Omega}f_r(p,\omega_i,\omega_o)L_i(p,\omega_i)n\cdot \omega_id\omega_i
\approx
\int_{\Omega}L_i(p,\omega_i)d\omega_i 
*
\int_{\Omega}f_r(p,\omega_i,\omega_o)n\cdot 
\omega_i d\omega_i \tag {8}</script><p>&emsp;&emsp;其中$\int_{\Omega}L_i(p,\omega_i)d\omega_i$是对半球方向的辐射率进行积分，$\int_{\Omega}f_r(p,\omega_i,\omega_o)n\cdot<br>\omega_id\omega_i$则对半球方向的brdf函数进行积分，我们将原来的积分分成了这两部分，预计算然后保存到两张纹理当中。可以看到前面一部分的积分仅仅取决于法线向量$n$，后面一部分表面上取决于$n$和$\omega_o$，后面深入了解之后就会发现不用$n$和$\omega_o$去索引brdf函数的积分值。</p>
<h3 id="1、Pre-Filtered-Environment-Map"><a href="#1、Pre-Filtered-Environment-Map" class="headerlink" title="1、Pre-Filtered Environment Map"></a>1、Pre-Filtered Environment Map</h3><p>&emsp;&emsp;首先我们来看前面一部分的积分值，即$\int_{\Omega}L_i(p,\omega_i)d\omega_i$，这部分预计算得到的纹理为预过滤的环境贴图，它返回的是反射的像素值。我们知道，给定一个物体表面，若其表面的粗糙程度越高，则反射的内容越模糊。因此，为了把物体的粗糙度考虑进去，我们将考虑物体的粗糙度划分成几个等级，每个等级预计算一遍积分，并存储到cubemap的一个mipmap当中。我们为生成的预过滤环境贴图构建mipmap，越粗糙则存储到mipmap的等级越高，正如如下图4所示：</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/4.png" width="99%"></div></p>
<center> 图4 不同粗糙度对应的mipmap </center>


<p>&emsp;&emsp;表面越粗糙则反射得越模糊得现象其实涉及到一个反射波瓣的问题，所以的反射波瓣就是反射光线的分布范围。如下图5所示，对于一个光滑的完美镜面，其反射波瓣就是反射向量，越粗糙则反射波瓣越大，且基本上都是以反射向量为中心。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/5.png" width="99%"></div></p>
<center> 图5 不同粗糙度下的反射波瓣 </center>


<p>&emsp;&emsp;因此，当我们进行积分采样时，我们没有必要再在半球方向做一个均匀的采样，因为超出反射波瓣的采样是无效的。我们应该偏向反射波瓣采样，这里就涉及到了一个重要性采样的问题，重要性采样的内容在前面的<a href="https://yangwc.com/2019/05/23/RayTracer-Advance/" target="_blank" rel="noopener">光线追踪器Ray Tracer：进阶篇</a>已经详细地展开过，这里就不再赘述。采用了重要性采样方法，我们求解积分方程的数值方法不再是黎曼积分法，而是蒙特卡洛积分法，蒙特卡洛积分同样在光线追踪渲染器中提及过。</p>
<p>&emsp;&emsp;为了加速蒙特卡洛积分方法的收敛速度，Epic Games公司提出使用超均匀分布序列（Low-discrepancy Sequence）——Hammersley序列。相对于普通的伪随机数，Hammersley序列的随机数分布更加均匀，如下图6所示，将其应用到蒙特卡洛采样能够提升收敛速度。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/6.png" width="80%"></div></p>
<center> 图6 伪随机数vs超均匀分布随机数 </center>


<p>&emsp;&emsp;我们将使用的是二维的Hammersley序列。一个二维的Hammersley序列$H_N=\{x_1,…,x_N\}, N\geq 1$是散落分布在单位正方形内的点集，其数学定义为：</p>
<script type="math/tex; mode=display">
H_N=\{x_i=
(\begin{matrix}
i/N\\
\Phi_2(i)
\end{matrix}
),\ \ for\ \ i=0,...,N-1
\} \tag {9}</script><p>&emsp;&emsp;其中$\Phi_2(i)$是Van der Corput序列，它输入$i$，然后将$i$的二进制编码以小数点为对称做一个镜像操作，返回$[0,1)$的浮点数，其数学定义为：</p>
<script type="math/tex; mode=display">
\Phi_2(i)=\frac{a_0}{2}+\frac{a_1}{2^2}+...+\frac{a_r}{2^{r+1}} \tag {10}</script><p>&emsp;&emsp;其中的$a_0a_1…a_n$是$i$的二进制编码每一位二进制位，即$i=a_0+a_1\cdot 2+a_2\cdot 2^2+a_3\cdot 2^3+…+a_r\cdot 2^r$。然后我们需要将这个二维的序列转换成我们对半球方向的三维采样，同样我们利用球面坐标和笛卡尔坐标之间的关系，首先将Hammersley序列$x_i=(u,v)^T\in H_N$映射到$(\phi,\theta)$，然后转换成笛卡尔坐标下的向量形式。一个均匀映射和一个余弦映射公式如下：</p>
<script type="math/tex; mode=display">
Uniform\ \ mapping=
\{\begin{matrix}
\theta=cos^{-1}(1-u)\\
\phi=2\pi v
\end{matrix}
\\
Cosinus\ \ mapping=
\{\begin{matrix}
\theta=cos^{-1}(\sqrt{(1-u)})\\
\phi=2\pi v
\end{matrix} \tag {11}</script><p>&emsp;&emsp;均匀映射就是将序列映射到一个均匀的分布，余弦映射则将序列映射到一个更偏向于半球中心轴上的分布。两者的区别如下图7所示。Hammersley序列可以通过位移操作快速地实现，具体代码见下面。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/7.jpg" width="70%"></div></p>
<center> 图7 均匀映射vs余弦映射 </center>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">radicalInverseVdc</span><span class="params">(uint bits)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bits = (bits &lt;&lt; <span class="number">16u</span>) | (bits &gt;&gt; <span class="number">16u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x55555555</span>u) &lt;&lt; <span class="number">1u</span>) | ((bits &amp; <span class="number">0xAAAAAAAA</span>u) &gt;&gt; <span class="number">1u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x33333333</span>u) &lt;&lt; <span class="number">2u</span>) | ((bits &amp; <span class="number">0xCCCCCCCC</span>u) &gt;&gt; <span class="number">2u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x0F0F0F0F</span>u) &lt;&lt; <span class="number">4u</span>) | ((bits &amp; <span class="number">0xF0F0F0F0</span>u) &gt;&gt; <span class="number">4u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x00FF00FF</span>u) &lt;&lt; <span class="number">8u</span>) | ((bits &amp; <span class="number">0xFF00FF00</span>u) &gt;&gt; <span class="number">8u</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float</span>(bits) * <span class="number">2.3283064365386963e-10</span>; <span class="comment">// / 0x100000000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec2 <span class="title">hammersley</span><span class="params">(uint i, uint N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> vec2(<span class="keyword">float</span>(i) / <span class="keyword">float</span>(N), radicalInverseVdc(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;紧接着我们要用Hammersley序列实现我们的重要性采样。前面已经提到过，我们将考虑物体的粗糙度，因为不同粗糙度下的反射波瓣大小不同。我们将粗糙度换分成5个等级，每个等级根据当前的粗糙度进行重要性采样。因此做重要性采样时我们需要根据粗糙度确定当前的反射波瓣大小，反射波瓣越大则采样范围越大。我们将结合之前PBR提到的法线分布函数，法线分布函数给定一个法线向量，它返回微平面法线与给定法线朝向一致的分布概率。Trowbridge-Reitz GGX法线分布函数的数学定义为：</p>
<script type="math/tex; mode=display">
NDF_{GGXTR}(n,h,\alpha)=\frac{\alpha^2}{\pi((n\cdot h)^2(\alpha^2-1)+1)^2} \tag {12}</script><p>&emsp;&emsp;我们将法线分布函数与余弦映射结合起来做重要性采样：</p>
<script type="math/tex; mode=display">
Important\ \ sampling=
\{\begin{matrix}
\theta=cos^{-1}(\sqrt{\frac{1-u}{u(\alpha^2-1)+1}})\\
\phi=2\pi v
\end{matrix} \tag {13}</script><p>&emsp;&emsp;同样这也是Epic Games公司提出的映射方法，注意到与公式$(11)$中的余弦映射相比，公式$(13)$多了一个分母$u(\alpha^2-1)+1$取自公式$(12)$中的法线分布函数。当粗糙度$\alpha$增大时，余弦值减小，$\theta$取值范围越大，反射波瓣也就越大，这个就是公式$(13)$的大体思路。对于给定的Hammersley序列、法线向量N、粗糙度roughness，一个重要性采样代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">importanceSampleGGX</span><span class="params">(vec2 Xi, vec3 N, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> a = roughness * roughness;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">float</span> phi = <span class="number">2.0</span> * PI * Xi.x;</span><br><span class="line">	<span class="keyword">float</span> cosTheta = <span class="built_in">sqrt</span>((<span class="number">1.0</span> - Xi.y) / (<span class="number">1.0</span> + (a * a - <span class="number">1.0</span>) * Xi.y));</span><br><span class="line">	<span class="keyword">float</span> sinTheta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cosTheta * cosTheta);</span><br><span class="line">	vec3 H;</span><br><span class="line">	H.x = <span class="built_in">cos</span>(phi) * sinTheta;</span><br><span class="line">	H.y = <span class="built_in">sin</span>(phi) * sinTheta;</span><br><span class="line">	H.z = cosTheta;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// from tangent space to world space.</span></span><br><span class="line">	vec3 up = <span class="built_in">abs</span>(N.z) &lt; <span class="number">0.999</span> ? vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>) : vec3(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">	vec3 tangent = normalize(cross(up, N));</span><br><span class="line">	vec3 bitangent = cross(N, tangent);</span><br><span class="line">	vec3 sampleVec = H.x * tangent + H.y * bitangent + H.z * N;</span><br><span class="line">	<span class="keyword">return</span> normalize(sampleVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后我们就利用重要性采样进行数值积分的计算，如下所示：</p>
<script type="math/tex; mode=display">
\int_{\Omega}L_i(p,\omega_i)d\omega_i
\approx \frac1N\Sigma_{k=1}^NL_i(l_k) \tag {14}</script><p>&emsp;&emsp;然后在实现时，Ephic Games公司发现再乘上一个权重$cos\theta_{l_k}$效果更加，因而实现的积分计算代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">in vec3 worldPos;</span><br><span class="line">out vec4 fragColor;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> roughness;</span><br><span class="line">uniform samplerCube environmentMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">radicalInverseVdc</span><span class="params">(uint bits)</span></span>;</span><br><span class="line"><span class="function">vec2 <span class="title">hammersley</span><span class="params">(uint i, uint N)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">importanceSampleGGX</span><span class="params">(vec2 Xi, vec3 N, <span class="keyword">float</span> roughness)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec3 N = normalize(worldPos);</span><br><span class="line">	vec3 V = N;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> uint sampleCount = <span class="number">1024u</span>;</span><br><span class="line">	<span class="keyword">float</span> totalWeight = <span class="number">0.0f</span>;</span><br><span class="line">	vec3 prefilteredColor = vec3(<span class="number">0.0f</span>);</span><br><span class="line">	<span class="keyword">for</span>(uint i = <span class="number">0u</span>;i &lt; sampleCount;++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec2 Xi = hammersley(i, sampleCount);</span><br><span class="line">		<span class="comment">// sample halfway vector.</span></span><br><span class="line">		vec3 H = importanceSampleGGX(Xi, N, roughness);</span><br><span class="line">		<span class="comment">// reflect vector.</span></span><br><span class="line">		vec3 L = normalize(<span class="number">2.0</span> * dot(V, H) * H - V);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">float</span> NdotL = max(dot(N, L), <span class="number">0.0</span>);</span><br><span class="line">		<span class="keyword">if</span>(NdotL &gt; <span class="number">0.0f</span>);</span><br><span class="line">		&#123;</span><br><span class="line">			prefilteredColor += texture(environmentMap, L).rgb * NdotL;</span><br><span class="line">			totalWeight += NdotL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	prefilteredColor = prefilteredColor / totalWeight;</span><br><span class="line">	</span><br><span class="line">	fragColor = vec4(prefilteredColor, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在cpu端生成多个mipmap层次的cubemap，对于每一个粗糙度等级，我们将预计算的结果存储到对应mipmap等级的cubemap纹理当中，最后我们就得到如图4所示的多个mipmap等级的Pre-Filtered Environment Map。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IBLAuxiliary::convoluteSpecularIntegral(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">unsigned</span> <span class="keyword">int</span> cubemapTexIndex,</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> prefilteredTexIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// manager.</span></span><br><span class="line">	TextureMgr::ptr texMgr = TextureMgr::getSingleton();</span><br><span class="line">	ShaderMgr::ptr shaderMgr = ShaderMgr::getSingleton();</span><br><span class="line">	<span class="comment">// load shader.</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> shaderIndex = shaderMgr-&gt;loadShader(<span class="string">"prefilterEnvMap"</span>,</span><br><span class="line">		<span class="string">"./glsl/prefilterEnvMap.vert"</span>, <span class="string">"./glsl/prefilterEnvMap.frag"</span>);</span><br><span class="line">	<span class="comment">// load cube mesh.</span></span><br><span class="line">	Mesh::ptr cubeMesh = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Mesh&gt;(<span class="keyword">new</span> Cube(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">	<span class="comment">// projection matrix and view matrix.</span></span><br><span class="line">	glm::mat4 captureProjectMatrix = glm::perspective(glm::radians(<span class="number">90.0f</span>), <span class="number">1.0f</span>, <span class="number">0.1f</span>, <span class="number">10.0f</span>);</span><br><span class="line">	glm::mat4 captureViewMatrix[] =</span><br><span class="line">	&#123;</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(+<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,+<span class="number">1.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,+<span class="number">1.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,<span class="number">-1.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,<span class="number">-1.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,+<span class="number">1.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">		glm::lookAt(glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="number">-1.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// begin to filter.</span></span><br><span class="line">	GLuint prefilteredTexId = texMgr-&gt;getTexture(prefilteredTexIndex)-&gt;getTextureId();</span><br><span class="line">	Shader::ptr shader = shaderMgr-&gt;getShader(shaderIndex);</span><br><span class="line">	shader-&gt;bind();</span><br><span class="line">	shader-&gt;setInt(<span class="string">"environmentMap"</span>, <span class="number">0</span>);</span><br><span class="line">	shader-&gt;setMat4(<span class="string">"projectMatrix"</span>, captureProjectMatrix);</span><br><span class="line">	texMgr-&gt;bindTexture(cubemapTexIndex, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> maxMipLevels = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> mip = <span class="number">0</span>; mip &lt; maxMipLevels; ++mip)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> mipWidth = width * <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">0.5</span>, mip);</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> mipHeight = height * <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">0.5</span>, mip);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">		ss &lt;&lt; mip;</span><br><span class="line">		FrameBuffer::ptr framebuffer = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;FrameBuffer&gt;(</span><br><span class="line">			<span class="keyword">new</span> FrameBuffer(mipWidth, mipHeight, <span class="string">"prefilteredDepth"</span> + ss.str(), &#123;&#125;, <span class="literal">true</span>));</span><br><span class="line">		framebuffer-&gt;bind();</span><br><span class="line">		glDisable(GL_BLEND);</span><br><span class="line">		glDisable(GL_CULL_FACE);</span><br><span class="line">		glEnable(GL_DEPTH_TEST);</span><br><span class="line">		glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);</span><br><span class="line">		glDepthFunc(GL_LEQUAL);</span><br><span class="line">		glClearColor(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> roughness = (<span class="keyword">float</span>)mip / (<span class="keyword">float</span>)(maxMipLevels - <span class="number">1</span>);</span><br><span class="line">		shader-&gt;setFloat(<span class="string">"roughness"</span>, roughness);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			shader-&gt;setMat4(<span class="string">"viewMatrix"</span>, captureViewMatrix[i]);</span><br><span class="line">			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">				GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, prefilteredTexId, mip);</span><br><span class="line">			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">			cubeMesh-&gt;draw(<span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		framebuffer-&gt;unBind();</span><br><span class="line">	&#125;</span><br><span class="line">	shader-&gt;unBind();</span><br><span class="line">	texMgr-&gt;unBindTexture(cubemapTexIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、Pre-computing-the-BRDF"><a href="#2、Pre-computing-the-BRDF" class="headerlink" title="2、Pre-computing the BRDF"></a>2、Pre-computing the BRDF</h3><p>&emsp;&emsp;接下来我们把目标方法第二部分的积分计算，即brdf函数积分：</p>
<script type="math/tex; mode=display">
\int_{\Omega}f_r(p,\omega_i,\omega_o)n\cdot \omega_id\omega_i \tag {15}</script><p>&emsp;&emsp;公式$(15)$的积分值取决于三个变量，即$n\cdot \omega_o$、表面粗糙度以及$F_0$，$F_0$是菲涅尔方程的一个输入值。三个变量太多了，为了简化且方便预计算，我们设法将一些变量提出积分符号外：</p>
<script type="math/tex; mode=display">
\int_{\Omega}f_r(p,\omega_i,\omega_o)n\cdot \omega_id\omega_i
=\int_{\Omega}f_r(p,\omega_i,\omega_o)\frac{F(\omega_o,h)}{F(\omega_o,h)}n\cdot \omega_id\omega_i\\
=\int_{\Omega}\frac{f_r(p,\omega_i,\omega_o)}{F(\omega_o,h)}F(\omega_o,h)n\cdot \omega_id\omega_i
\tag{16}</script><p>&emsp;&emsp;将菲涅尔项$F(\omega_o,h)=(F_0+(1-F_0)(1-\omega_o\cdot h)^5)$代入上式，得：</p>
<script type="math/tex; mode=display">
\int_{\Omega}\frac{f_r(p,\omega_i,\omega_o)}{F(\omega_o,h)}(F_0+(1-F_0)(1-\omega_o\cdot h)^5)n\cdot \omega_id\omega_i
\\
=
\int_{\Omega}\frac{f_r(p,\omega_i,\omega_o)}{F(\omega_o,h)}(F_0(1-(1-\omega_o\cdot h)^5)+(1-\omega_o\cdot h)^5)n\cdot \omega_id\omega_i \tag {17}</script><p>​    &emsp;&emsp;然后将公式$(17)$得到的结果分成两部分：</p>
<script type="math/tex; mode=display">
\int_{\Omega}\frac{f_r(p,\omega_i,\omega_o)}{F(\omega_o,h)}(F_0(1-(1-\omega_o\cdot h)^5)+(1-\omega_o\cdot h)^5)n\cdot \omega_id\omega_i\\
=F_o\int_{\Omega}f_r(p,\omega_i,\omega_o)(1-(1-\omega_o\cdot h)^5)n\cdot \omega_id\omega_i
+\int_{\Omega}f_r(p,\omega_i,\omega_o)(1-\omega_o\cdot h)^5 n\cdot \omega_i d\omega_i \tag {18}</script><p>&emsp;&emsp;注意，公式$(18)$中的是去掉了菲涅尔项的brdf函数，因为菲涅尔项被消去了。现在我们把$F_0$提出积分外了，公式$(18)$中的两项积分取决于$n\cdot \omega_o$和粗糙度roughness。我们构建这样的一个二维查找表，它的横轴坐标取值为$n\cdot \omega_o$，纵轴坐标取值为粗糙度roughness，我们渲染屏幕空间大小的四边形，遍历$n\cdot \omega_o$和粗糙度的所有取值，计算其对应的公式$(18)$中的两项积分的结果，存储为纹理的像素值。最后渲染时使用纹理坐标$(n\cdot \omega_o, roughness)$去索引像素值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">geometrySchlickGGX</span><span class="params">(<span class="keyword">float</span> NdotV, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> a = roughness;</span><br><span class="line">	<span class="keyword">float</span> k = (a * a) / <span class="number">2.0f</span>;</span><br><span class="line">	<span class="keyword">float</span> nom = NdotV;</span><br><span class="line">	<span class="keyword">float</span> denom = NdotV * (<span class="number">1.0</span> - k) + k;</span><br><span class="line">	<span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">geometrySmith</span><span class="params">(vec3 N, vec3 V, vec3 L, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> NdotV = max(dot(N, V), <span class="number">0.0</span>);</span><br><span class="line">	<span class="keyword">float</span> NdotL = max(dot(N, L), <span class="number">0.0</span>);</span><br><span class="line">	<span class="keyword">float</span> ggx2 = geometrySchlickGGX(NdotV, roughness);</span><br><span class="line">	<span class="keyword">float</span> ggx1 = geometrySchlickGGX(NdotL, roughness);</span><br><span class="line">	<span class="keyword">return</span> ggx1 * ggx2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec2 <span class="title">integrateBRDF</span><span class="params">(<span class="keyword">float</span> NdotV, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec3 V;</span><br><span class="line">	V.x = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - NdotV * NdotV);</span><br><span class="line">	V.y = <span class="number">0.0f</span>;</span><br><span class="line">	V.z = NdotV;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> A = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">float</span> B = <span class="number">0.0</span>;</span><br><span class="line">	</span><br><span class="line">	vec3 N = vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> uint sampleCount = <span class="number">1024u</span>;</span><br><span class="line">	<span class="keyword">for</span>(uint i = <span class="number">0u</span>;i &lt; sampleCount;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec2 Xi = hammersley(i, sampleCount);</span><br><span class="line">		vec3 H = importanceSampleGGX(Xi, N, roughness);</span><br><span class="line">		vec3 L = normalize(<span class="number">2.0</span> * dot(V, H) * H - V);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">float</span> NdotL = max(L.z, <span class="number">0.0</span>);</span><br><span class="line">		<span class="keyword">float</span> NdotH = max(H.z, <span class="number">0.0</span>);</span><br><span class="line">		<span class="keyword">float</span> VdotH = max(dot(V, H), <span class="number">0.0</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(NdotL &gt; <span class="number">0.0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> G = geometrySmith(N, V, L, roughness);</span><br><span class="line">			<span class="keyword">float</span> G_Vis = (G * VdotH) / (NdotH * NdotV);</span><br><span class="line">			<span class="keyword">float</span> Fc = <span class="built_in">pow</span>(<span class="number">1.0</span> - VdotH, <span class="number">5.0</span>);</span><br><span class="line">			A += (<span class="number">1.0</span> - Fc) * G_Vis;</span><br><span class="line">			B += Fc * G_Vis;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	A /= <span class="keyword">float</span>(sampleCount);</span><br><span class="line">	B /= <span class="keyword">float</span>(sampleCount);</span><br><span class="line">	<span class="keyword">return</span> vec2(A, B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec2 value = integrateBRDF(Texcoord.x, Texcoord.y);</span><br><span class="line">	fragColor = vec4(value, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在cpu端创建一个二维纹理，并送入一个屏幕大小的四边形进行预计算的渲染。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IBLAuxiliary::convoluteSpecularBRDFIntegral(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">unsigned</span> <span class="keyword">int</span> brdfLutTexIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// manager.</span></span><br><span class="line">	TextureMgr::ptr texMgr = TextureMgr::getSingleton();</span><br><span class="line">	ShaderMgr::ptr shaderMgr = ShaderMgr::getSingleton();</span><br><span class="line">	<span class="comment">// load shader.</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> shaderIndex = shaderMgr-&gt;loadShader(<span class="string">"genBrdfLUT"</span>,</span><br><span class="line">		<span class="string">"./glsl/genBrdfLUT.vert"</span>, <span class="string">"./glsl/genBrdfLUT.frag"</span>);</span><br><span class="line">	<span class="comment">// load quad mesh.</span></span><br><span class="line">	Mesh::ptr quadMesh = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Mesh&gt;(<span class="keyword">new</span> ScreenQuad());</span><br><span class="line">	FrameBuffer::ptr framebuffer = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;FrameBuffer&gt;(</span><br><span class="line">		<span class="keyword">new</span> FrameBuffer(width, height, <span class="string">"brdfDepth"</span>, &#123;&#125;, <span class="literal">true</span>));</span><br><span class="line">	Shader::ptr shader = shaderMgr-&gt;getShader(shaderIndex);</span><br><span class="line"></span><br><span class="line">	framebuffer-&gt;bind();</span><br><span class="line">	glDisable(GL_BLEND);</span><br><span class="line">	glDisable(GL_CULL_FACE);</span><br><span class="line">	glDisable(GL_DEPTH_TEST);</span><br><span class="line">	glDepthFunc(GL_LEQUAL);</span><br><span class="line">	glClearColor(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	GLuint brdfLutTexId = texMgr-&gt;getTexture(brdfLutTexIndex)-&gt;getTextureId();</span><br><span class="line">	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, brdfLutTexId, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	shader-&gt;bind();</span><br><span class="line">	quadMesh-&gt;draw(<span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">	shader-&gt;unBind();</span><br><span class="line">	framebuffer-&gt;unBind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后我们就可以得到下面这张纹理。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/8.png" width="60%"></div></p>
<center> 图8 brdf积分查找表 </center>




<h2 id="五、计算渲染方程"><a href="#五、计算渲染方程" class="headerlink" title="五、计算渲染方程"></a>五、计算渲染方程</h2><p>&emsp;&emsp;在前面的步骤中我们预计算获取了Irradiance Map、Pre-Filtered Environment Map以及BRDF Lookup Texture，最后我们就直接查找这些纹理，用以我们的光照计算。光照计算部分直接就是一开始提到的渲染方程，渲染方程中的积分项从纹理中直接获取，不再需要实时计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ambient lighting.</span></span><br><span class="line">vec3 ambientS = fresnelSchlickRoughness(max(dot(normal, viewDir), <span class="number">0.0f</span>), F0, roughness);</span><br><span class="line">vec3 ambientD = vec3(<span class="number">1.0f</span>) - ambientS;</span><br><span class="line">ambientD *= (<span class="number">1.0</span> - metallic);</span><br><span class="line">vec3 irradiance = texture(irradianceMap, normal).rgb;</span><br><span class="line"></span><br><span class="line">vec3 R = normalize(reflect(-viewDir, normal));</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> MAX_REFLECTION_LOD = <span class="number">4.0</span>;</span><br><span class="line">vec3 prefilteredColor = texture(prefilteredMap, R, roughness * MAX_REFLECTION_LOD).rgb;</span><br><span class="line"></span><br><span class="line">vec2 envBrdf = texture(brdfLutMap, vec2(max(dot(normal, viewDir), <span class="number">0.0f</span>), roughness)).rg;</span><br><span class="line">vec3 envSpecular = prefilteredColor * (ambientS * envBrdf.x + envBrdf.y);</span><br><span class="line"></span><br><span class="line">vec3 ambient = (albedo * irradiance * ambientD + envSpecular) * ao;</span><br><span class="line"></span><br><span class="line">fragColor.xyz = ambient + fragColor.xyz * shadow + pointLightRadiance;</span><br></pre></td></tr></table></figure>
<h2 id="六、实现效果"><a href="#六、实现效果" class="headerlink" title="六、实现效果"></a>六、实现效果</h2><p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/ret1.png" width="99%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/ret2.png" width="99%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/ret3.png" width="99%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/ret4.png" width="99%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.20/blog/ImageBasedLighting/ret5.png" width="99%"></div></p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>$[1]$ <a href="http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html" target="_blank" rel="noopener">Hammersley Points on the Hemisphere</a></p>
<p>$[2]$ <a href="https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf" target="_blank" rel="noopener">Real Shading in Unreal Engine 4, by Brian Karis, Epic Games</a></p>
<p>$[3]$ <a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance" target="_blank" rel="noopener">https://learnopengl.com/PBR/IBL/Diffuse-irradiance</a></p>
<p>$[4]$ <a href="https://learnopengl.com/PBR/IBL/Specular-IBL" target="_blank" rel="noopener">https://learnopengl.com/PBR/IBL/Specular-IBL</a></p>
</div>
        </div>
        
          


  <section class="meta" id="footer-meta">
    <hr>
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-09-27T21:05:02+08:00">
  <a class="notlink">
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>最后更新于 2019年9月27日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Computer-Graphics/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Computer Graphics</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Real-time-Rendering/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Real-time Rendering</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Physically-Based-Rendering/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Physically Based Rendering</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/07/21/ImageBasedLighting/&title=实时渲染Real-time Rendering：Image Based Lighting | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png&summary=本文在前一篇PBR渲染器的基础上，进一步深入理解并实现了Image Based Lighting的全局光照。Image Based Lighting预先烘培辐照度贴图、构建BRDF积分查找表，然后在实时渲染中直接查询查找表快速计算渲染方程，实现的效果高效且真实。这种技术已经集成在虚幻4引擎中。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2019/07/21/ImageBasedLighting/&title=实时渲染Real-time Rendering：Image Based Lighting | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png&summary=本文在前一篇PBR渲染器的基础上，进一步深入理解并实现了Image Based Lighting的全局光照。Image Based Lighting预先烘培辐照度贴图、构建BRDF积分查找表，然后在实时渲染中直接查询查找表快速计算渲染方程，实现的效果高效且真实。这种技术已经集成在虚幻4引擎中。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/07/21/ImageBasedLighting/&title=实时渲染Real-time Rendering：Image Based Lighting | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png&summary=本文在前一篇PBR渲染器的基础上，进一步深入理解并实现了Image Based Lighting的全局光照。Image Based Lighting预先烘培辐照度贴图、构建BRDF积分查找表，然后在实时渲染中直接查询查找表快速计算渲染方程，实现的效果高效且真实。这种技术已经集成在虚幻4引擎中。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                            <h4>
                                <a href="/2019/07/23/2DLighting/" rel="prev" title="二维渲染2D Rendering：2D Lighting">
                                  
                                      二维渲染2D Rendering：2D Lighting
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/2D-Rendering/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>2D Rendering</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2019/07/14/PhysicallyBasedRendering/" rel="prev" title="实时渲染Real-time Rendering：基于物理的光照模型">
                                    
                                        实时渲染Real-time Rendering：基于物理的光照模型
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Real-time-Rendering/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Real-time Rendering</a> <a class="tag" href="/tags/Physically-Based-Rendering/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Physically Based Rendering</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
        <section id="comments">
          <div id="lv-container" data-id="city" data-uid="MTAyMC80MzkxOS8yMDQ1NQ==">
            <noscript><div><i class="fas fa-exclamation-triangle">&nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。</i></div></noscript>
          </div>
        </section>
      
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

  <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



  <script>
    window.subData = {
      title: '实时渲染Real-time Rendering：Image Based Lighting',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content material">
    
      <div class="avatar">
        <fancybox><img class="avatar" src="/image/avator.png"></fancybox>
      </div>
    
    
      <div class="text">
        
          <h2>YangWC</h2>
        
        
          <p>A student from Sun Yat-sen University.</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget toc-wrapper">
    
<header class="material">
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class="content material">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#三、预计算漫反射积分"><span class="toc-text">三、预计算漫反射积分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、预计算镜面反射积分"><span class="toc-text">四、预计算镜面反射积分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、Pre-Filtered-Environment-Map"><span class="toc-text">1、Pre-Filtered Environment Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、Pre-computing-the-BRDF"><span class="toc-text">2、Pre-computing the BRDF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、计算渲染方程"><span class="toc-text">五、计算渲染方程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、实现效果"><span class="toc-text">六、实现效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料："><span class="toc-text">参考资料：</span></a></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class="widget plain">
  
<header class="material">
  <div><i class=" fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;欢迎来到YangWC的博客</div>
  
</header>

  <div class="content material">
    <p>本站会记录自己的一些学习内容，如若有错，欢迎指正，感谢!</p>

  </div>
</section>

          
        
      
        
          
          
            <section class="widget grid">
  
<header class="material">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content material">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于博主
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn" rel="nofollow" href="/categories/" title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/2D-Rendering/" href="/categories/2D-Rendering/"><div class="name">2D Rendering</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Computer-Graphics/" href="/categories/Computer-Graphics/"><div class="name">Computer Graphics</div><div class="badge">(20)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-Simulation/" href="/categories/Fluid-Simulation/"><div class="name">Fluid Simulation</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/N-body/" href="/categories/N-body/"><div class="name">N-body</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physically-Based-Rendering/" href="/categories/Physically-Based-Rendering/"><div class="name">Physically Based Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Position-Based-Dynamics/" href="/categories/Position-Based-Dynamics/"><div class="name">Position Based Dynamics</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Ray-Tracer/" href="/categories/Ray-Tracer/"><div class="name">Ray Tracer</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Real-time-Rendering/" href="/categories/Real-time-Rendering/"><div class="name">Real-time Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Soft-Renderer/" href="/categories/Soft-Renderer/"><div class="name">Soft Renderer</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Voxelization/" href="/categories/Voxelization/"><div class="name">Voxelization</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class="widget tagcloud">
    
<header class="material">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn" rel="nofollow" href="/tags/" title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <a href="/tags/2D-Rendering/" style="font-size: 14px; color: #bbb">2D Rendering</a> <a href="/tags/3D-Math/" style="font-size: 14px; color: #bbb">3D Math</a> <a href="/tags/3D-pipeline/" style="font-size: 16px; color: #c9c9c9">3D pipeline</a> <a href="/tags/Advection/" style="font-size: 14px; color: #bbb">Advection</a> <a href="/tags/Computer-Graphics/" style="font-size: 24px; color: #fff">Computer Graphics</a> <a href="/tags/Fluid-Simulation/" style="font-size: 22px; color: #f1f1f1">Fluid Simulation</a> <a href="/tags/Glow-effect/" style="font-size: 14px; color: #bbb">Glow effect</a> <a href="/tags/N-body/" style="font-size: 14px; color: #bbb">N-body</a> <a href="/tags/Naiver-Stokes-Equations/" style="font-size: 14px; color: #bbb">Naiver-Stokes Equations</a> <a href="/tags/Physically-Based-Rendering/" style="font-size: 16px; color: #c9c9c9">Physically Based Rendering</a> <a href="/tags/Position-Based-Dynamics/" style="font-size: 18px; color: #d6d6d6">Position Based Dynamics</a> <a href="/tags/Rasterization/" style="font-size: 14px; color: #bbb">Rasterization</a> <a href="/tags/Ray-Tracer/" style="font-size: 16px; color: #c9c9c9">Ray Tracer</a> <a href="/tags/Real-time-Rendering/" style="font-size: 16px; color: #c9c9c9">Real-time Rendering</a> <a href="/tags/Soft-Renderer/" style="font-size: 20px; color: #e4e4e4">Soft Renderer</a> <a href="/tags/Voxelization/" style="font-size: 14px; color: #bbb">Voxelization</a>
    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
	<script>
		var now = new Date(); 
		function createtime() { 
			var grt= new Date("04/24/2019 18:00:00");//在此处修改你的建站时间
			now.setTime(now.getTime()+250); 
			days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
			hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
			if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
			mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
			seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
			snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
			document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
			document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
		} 
	setInterval("createtime()",250);
   </script>
   
   <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->
	
	
	<script>setLoadingBarProgress(80);</script>
</footer>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>









  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>






  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  
    <!--数字雨背景-->
  <canvas id="canvas" width="1440" height="900" ></canvas>
  <script>
	var s = window.screen;
	var width = canvas.width = s.width;
	var height = canvas.height = s.height;
	var fontSize = 13;
	var colunms = Math.floor(width/fontSize);
	var letters = [];
    for(var i=0;i<colunms;i++){
        letters.push(1);
    }
	var draw = function () {
	    canvas.getContext('2d').fillStyle = "rgba(0,0,0,.08)";//遮盖层
		canvas.getContext('2d').fillRect(0,0,width,height);
		canvas.getContext('2d').font = "700 " + fontSize +"px  微软雅黑";
		letters.map(function(y_pos, index){
		text = String.fromCharCode(34+Math.random()*33);
		x_pos = index * fontSize;
		canvas.getContext('2d').fillText(text, x_pos, y_pos);
		letters[index] = (y_pos > 758 + Math.random() * 1e4) ? 0 : y_pos + 10;
		canvas.getContext('2d').fillStyle='#'+letters[index];
	  });
	};
	setInterval(draw, 33);
  </script>
  
  <!-- 页面点击出现文字 -->
  <script type="text/javascript" src="/js/ClickShowText.js"></script>
  
  <script>setLoadingBarProgress(100);</script>
</body>
</html>
