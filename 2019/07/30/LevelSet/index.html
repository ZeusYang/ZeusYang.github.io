<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>流体模拟Fluid Simulation：Level Set &amp; Marching Cube | YangWC&#39;s Blog</title>
  
  
  <meta name="description" content="Personal blog website.">
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/logo.ico">
  

  
    <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fdf716664defeee80e01568ddbeb2425";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
  
</head>
<body>
  
  
  <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          YangWC's Blog
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
									<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/" id="home">
									<i class="fas fa-grin fa-fw"></i>&nbsp;博客
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
									<i class="fas fa-tag fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-grin fa-fw"></i>&nbsp;博客
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
								<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
								<i class="fas fa-tag fa-fw"></i>&nbsp;标签
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      <div class="l_main">
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/07/30/LevelSet/">
        流体模拟Fluid Simulation：Level Set & Marching Cube
      </a>
    </h1>
  


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="https://yangwc.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-30</p>
  </a>
</div>

          
        
          
            
  
  <div class="new-meta-item category">
    <a href="/categories/Fluid-Simulation/" rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Computer Graphics&nbsp;/&nbsp;Fluid Simulation</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p>本文主要是基于欧拉网格流体模拟中的算法常客——Level Set和Marching Cube，Level Set算法负责构建复杂的边界几何体，而Marching Cube负责从欧拉网格中重建流体表面。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.22/blog/LevelSet/ret2.png" width="99%"></div></p>
<a id="more"></a>
<ul>
<li>符号距离场</li>
<li>三角形网格的SDF计算</li>
<li>Marching Cube重建算法</li>
<li>参考资料</li>
</ul>
<center><font size="6">水平集（Level Set）</font></center>



<p>&emsp;&emsp;在流体模拟中，我们需要处理流体与固体边界的交互作用。这对于流体模拟来说至关重要，因为流体通常是作用到固体以及其他边界上才会体现流体的特性，让人看起来是流体。这就涉及到两个问题：</p>
<p>&emsp;&emsp;1、给定一个点（例如用半拉格朗日后向追踪得到的点），如何判断它是否在固体边界内？</p>
<p>&emsp;&emsp;2、如何计算给定一点到几何体表面上的最近的点？</p>
<p>&emsp;&emsp;上面的问题在流体模拟中非常常见，在基于欧拉网格的流体模拟中，我们常用的是水平集的方法。我们将几何体表示成一个隐式的表面，给定关于这个几何体的连续标量函数$\phi(x,y,z)$，我们定义该几何体构成的空间如下：</p>
<p>&emsp;&emsp;1、当$\phi(x,y,z)&gt;0$时，点$x$在几何体外部，此时满足该条件的$x$的点集构成几何体的外部空间；</p>
<p>&emsp;&emsp;2、当$\phi(x,y,z) &lt;0$时，点$x$在几何体内部，此时满足该条件的$x$的点集构成几何体的内部空间；</p>
<p>&emsp;&emsp;3、当$\phi(x,y,z)=0$时，点$x$在几何体的表面上，此时的$x$的点集构成了几何体的表面区域。</p>
<p>&emsp;&emsp;可以看到，我们采用了一个连续的标量函数$\phi(x,y,z)$来隐式地表示一个几何体，几何体的表面就是函数$\phi(x,y,z)$取值为$0$的所有点集，在三维的情况下这个点集构成了关于$\phi(x,y,z)$的一个等高面（或者说等值面），在这个等高面上$\phi(x,y,z)$取值均为$0$，这就是“水平集”一词的由来，几何体的表面就是$\phi(x,y,z)$的$0$水平集。事实上，我们要寻找的这个连续标量函数$\phi(x,y,z)$就是符号距离场（Signed Distance Field，简称SDF）。</p>
<h2 id="一、符号距离场"><a href="#一、符号距离场" class="headerlink" title="一、符号距离场"></a>一、符号距离场</h2><p>&emsp;&emsp;任意给定一个要隐式表达的点的闭集$S$，关于这个点集$S$的距离场函数为：</p>
<script type="math/tex; mode=display">
distance_S(\vec x)=min_{\vec p\in S}||\vec x-\vec p|| \tag {1}</script><p>&emsp;&emsp;该距离场函数给出了$\vec x$到点集$S$的最近距离。若点集$S$将三维空间划分成了良定义的外部和内部（例如一个封闭的三角形网格模拟），那么其符号距离场函数就定义为：</p>
<script type="math/tex; mode=display">
\phi(\vec x)=
\{
\begin{matrix}
+distance_S(\vec x), x\ \ is\ \ outside.\\
-distance_S(\vec x), x\ \ is\ \ inside. 
\end{matrix} \tag {2}</script><p>&emsp;&emsp;符号距离场具有需要非常有用的性质。首先是符号距离场的梯度，根据矢量微积分，梯度指向函数值变换最快的方向，在这里显然沿着法线方向距离场函数值的变换最快，因而表面上的法线向量就等于表面上的符号距离场函数的梯度$\nabla \phi(\vec x)$。在几何体的外部，$-\nabla \phi(\vec x)$指向$\vec x$到几何体表面上的最近点$\vec p$；在几何体内部，$\nabla \phi(\vec x)$指向$\vec x$到几何体表面上的最近点$\vec p$。</p>
<p>&emsp;&emsp;以外部的点$\vec x$为例，记$\vec p$为点$\vec x$到几何体表面上的最近的点，$\vec c$为点$\vec x$到最近点$\vec p$的单位方向向量：</p>
<script type="math/tex; mode=display">
\vec c = \frac{\vec p-\vec x}{||\vec p-\vec x||} \tag {3}</script><p>&emsp;&emsp;如果我们将点$\vec x$沿着$\vec c$方向移动非常小的距离$\epsilon$，即$\vec x’=\vec x+ \epsilon \vec c$，那么点$\vec x’$到几何体表面上的最近点依然是$\vec p$。即若沿着$\vec c$方向移动$\vec x$点，其到物体表面上的最近点$\vec p$保持不变。挪动得到的新的点$\vec x’$的符号距离场函数为$\phi(\vec x’)=\phi(x)-\epsilon$，从而我们可以得出符号距离场关于$\vec c$方向向量上的方向导数为：</p>
<script type="math/tex; mode=display">
\frac{\partial \phi(\vec x)}{\partial \vec c}
=lim_{\epsilon\to 0}\frac{\phi(\vec x+\epsilon \vec c)-\phi(\vec x)}{\epsilon}\\
=lim_{\epsilon\to 0}\frac{\phi(\vec x)-\epsilon-\phi(\vec x)}{\epsilon}\\
=lim_{\epsilon\to 0}\frac{-\epsilon}{\epsilon}=-1 \tag {4}</script><p>&emsp;&emsp;根据上面的推导，我们知道$\phi(\vec x)$沿着梯度方向的变化速率为$1$，从而可知梯度向量长度为$1$，这意味着SDF的梯度实际上是一个单位向量，因而表面上的单位法线就是等于SDF函数的梯度向量：</p>
<script type="math/tex; mode=display">
||\nabla\phi|| = 1 \tag {5}</script><p>&emsp;&emsp;除此之外，上面的公式$(5)$是一个非线性偏微分方程——程函方程（Eikonal equation）。根据SDF函数及其梯度，我们可以求得外部的点$\vec x$到几何体表面上的距离最近的点$\vec p$：</p>
<script type="math/tex; mode=display">
\vec p=\vec x-\phi(\vec x)\nabla \phi(\vec x) \tag {6}</script><p>&emsp;&emsp;一般情况下，符号距离场函数都是光滑的，即梯度$\nabla \phi$和更高阶的导数都存在，但是也存在一些例外的点。一些中轴上的点到几何体表面的最近距离的点可能不唯一，例如球体的圆心到球体表面最近的距离就是半径$r$，但是其最近距离上的点有无穷多个，凹几何体同样存在这种情况。在这些特定的区域，符号距离场函数依然连续，只是存在一些扭曲，但函数不可微，因而梯度以及更高阶的导数不存在。在这些不可微的区域，我们的数值近似方法依旧会给出一个梯度向量，但这个梯度向量远远小于单位向量，甚至接近于$0$。</p>
<h2 id="二、三角形网格的SDF计算"><a href="#二、三角形网格的SDF计算" class="headerlink" title="二、三角形网格的SDF计算"></a>二、三角形网格的SDF计算</h2><p>&emsp;&emsp;了解了符号距离场之后，我们现在就把目标转到几何体的符号距离场计算上面。对于一些简单的几何体我们可以轻松地写出其SDF的解析表达式，例如一个球心为$\vec c$、半径为$r$的球体其SDF函数为$\phi_{sphere}(\vec x)=||\vec x-\vec c||-r$，一个以$\vec n$为法线、过点$\vec p$的无限平面其SDF函数为$\phi_{plane}(\vec x)=(\vec x-\vec p)\cdot \vec n$，还有一些简单的锥体、柱体、立方体等等都可以直接写出其SDF表达式。但是通常情况下我们接触的几何体更多的是采用三角形的网格模型来表示，三角形构成的网格模型并没有一个显式的几何函数，因而不可能像简单的几何体那样直接写出SDF的解析函数。</p>
<p>&emsp;&emsp;与直接获取几何体的解析SDF函数不一样，对于三角网格模型，我们将其所开的空间划分成一个欧拉网格，在每一个网格点上采样并存储网格模型的SDF值。然后在后面获取给定点$\vec x$的SDF函数值时，我们根据$\vec x$获取其周围网格点的SDF值，接着做一个插值操作，从而快速地获取$\vec x$对应的SDF函数值。<strong>这就是所谓的水平集方法：对符号距离场函数进行离散采样，并存储到均匀划分的网格中。</strong>显然这是求解了SDF函数的数值表达式，相对于解析表达式，它没有那么精确，但是对于流体模拟来说这些误差还是能够接受的。</p>
<p>&emsp;&emsp;我们首先要计算每个网格点上的符号距离场的值，目前主要有两种算法：第一种从几何角度展开，寻找给定的点到三角网格模型上的最近点并计算最近的距离场；第二种围绕偏微分方程展开，求解SDF的程函方程$||\nabla\phi||=1 $。两种算法都有各自的用途，第一种方法更好理解，结果也更为精确，而第二中方法则适用于非显式表示的几何体。这里我们首先考虑第一种基于几何的方法。</p>
<p>&emsp;&emsp;我们首先来看一个简化了的问题：给定一个有限的点集，计算任一点$\vec x$到这个点集的距离场。由于点集并没有内部和外部的划分概念，因此我们的距离场也无需带上符号。计算的伪代码如下图1所示。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.22/blog/LevelSet/1.png" width="99%"></div></p>
<center> 图1 点集的水平集计算伪代码 </center>


<p>&emsp;&emsp;算法主要分为两步，首先初始化一个三维的$\phi_{i,k,k}$数组，我们计算得到的SDF将存储到这个数组中。第一步，输入的点计算其对应的欧拉网格点，并更新该欧拉网格的SDF函数。第二步就是将第一步计算的SDF值扩散到其他未填充的欧拉网格点。上面的伪代码中第二步循环的顺序非常重要，因为这影响到其他欧拉网格点的SDF值的正确性。关于第二步的循环顺序，有两种比较推荐的方法，分别是快速移动算法和快速扫描算法，算法的复杂度分别为$O(nlog n)$和$O(n)$。我们目前仅看后一种，即快速扫描算法。</p>
<p>&emsp;&emsp;经过图1中的第一步之后，点集周围的欧拉网格点已经获取了距离场信息。第二步就是剩下的欧拉网格点需要从这些已知的欧拉网格点获取距离场信息。快速扫描算法基于这样的一个事实：最终每个未知的欧拉网格点的距离场信息必然是从其周围的某一个方向传播过来。为了确保每个欧拉网格点获取正确的距离场信息，我们遍历所有的传播方向。在三维空间中，传播方向有八个，即$i$递增、递减，$j$递增、递减，以及$k$递增、递减。因此算法将循环遍历八次，每次循环按照指定的方向进行遍历。为了提升算法的准确率，我们还可以多重复几次执行快速扫描算法。</p>
<p>&emsp;&emsp;上面我们讨论点集的水平集计算方法，接下来我们就继续深入到关于三角网格的水平集计算方法，这里的三角形网格是一个封闭的三角形网格。三角网格的水平集计算方法也是在上面点集的水平集计算方法的基础上展开，与之不同的是，这里我们追踪的不是点而是三角形。除此之外，我们还需要一些额外的步骤用于判断每个欧拉网格点是属于外部还是内部，这将影响到SDF函数值的符号。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.22/blog/LevelSet/2.png" width="90%"></div></p>
<center> 图2 三角网格的水平集计算伪代码 </center>


<p>&emsp;&emsp;三角网格的水平集计算方法比较复杂，图2的伪代码其实有些地方没有详细地说明，而这些地方恰恰非常关键。除了申请了一个三维数组用于存储$\phi_{i,j,k}$和一个三维数组存储每个最近点的索引$t_{i,j,k}$，我们还申请了一个整数数组$c_{i,j,k}$记录相交次数。为了判断一个欧拉网格点是在三角网格内部还是外部，我们采用了投射射线法：如果一个点按照某个方向发射射线，该射线与三角网格模型的交点个数为奇数个，则该点处于网格模型内部；若该射线与三角网格模型的交点个数为偶数个，则该点处于网格模型的外部。</p>
<p>&emsp;&emsp;我们向$x$轴的负方向投射射线，暴力的方法就是每一个欧拉网格点都投射一条射线，但这其实是没必要的。我们创建了一个相交次数的记录数组$c_{i,j,k}$，每一个欧拉网格点$i,j,k$检测其到$i+1,j,k$点的边是否与三角形相交，然后在算法的最后，我们将$i$从$0$开始递增，理解$c_{i,j,k}$数组，并判断当前的累加值是奇数还是偶数，从而确定距离场的符号值。检测每一条$i,j,k$到$i+1,j,k$的边与三角形的相交情况时，因为投射的射线是平行于$x$轴的，我们可以将三角形投影到$yz$平面上，然后检测$j,k$是否在投影到$yz$平面上的三角形内。若在投影的三角形内，则必然相交，反之不相交。因此，我们需要一个方法快速判断给定的点是否在二维的三角形内。</p>
<p>&emsp;&emsp;这里我们采用SoS（Simulation Of Simplicity$^{[2]}$）的方法。给定两个二维向量$\vec a$和$\vec b$，在不考虑三维的情况下，二维的向量乘积结果为标量，其几何意义为由$\vec a$和$\vec b$构成的平行四边形的<strong>有向</strong>面积，$|\vec a\times \vec b|=|\vec a||\vec b|sin\theta$。当$\vec a\times \vec b &lt; 0$时，两者夹角大于180度；当$\vec a\times \vec b =0$时，两者共线（可能同向，可能反向）；当$\vec a\times \vec b&gt;0$时，两者夹角小于180度。观察下面的图3，三角形由$x_1$、$x_2$和$x_3$构成，设要判断的点为$p$，我们可得向量$\vec l_1 = {x_1-p}$、$\vec l_2 = x_2-p$以及$\vec l_3 = x_3-p$。注意到这样的一个事实，若点$p$在三角形内部，则向量$\vec l_1$、$\vec l_2$和$\vec l_3$两两之间的夹角必定小于180度。若点$p$在三角形外部，则必定（以逆时针方向为例）存在两个向量之间的夹角大于0，此时的叉乘结果小于0，正如下图中的$p_2$，逆时针方向上，$x_1-p_2$和$x_2-p_2$夹角大于0了。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.22/blog/LevelSet/3.png" width="90%"></div></p>
<center> 图3 判断点是否在三角形内部 </center>


<p>&emsp;&emsp;上面的讨论我们已经知道如何判断给定的点是否在三角形内部了，接下来我们计算给定的点在三角形内部的重心坐标，后面我们在求交运算时需要根据重心坐标进行插值获取第三维的信息。还是一样，注意到叉乘的几何意义，我们通过叉乘得到了三个四边形的有向面积，然后除以2就是点$p$与三个顶点$x_1$、$x_2$和$x_3$构成的三角形的有向面积$S_1$、$S_2$、$S_3$，重心坐标就可以根据这些有向面积再除三角形总的有向面积和：</p>
<script type="math/tex; mode=display">
\alpha=\frac{S_1}{S_1+S_2+S_3}\\
\beta=\frac{S_2}{S_1+S_2+S_3}\\
\gamma=\frac{S_3}{S_1+S_2+S_3} \tag {7}</script><p>&emsp;&emsp;最后编程代码如下所示，我们首先判断三个有向面积符号是否相同，若有一个不同则直接返回不在三角形内部的情况。最后根据有向面积计算相应的重心坐标。这里的二维判断仅用于相交计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LevelSet::orientation(</span><br><span class="line">	<span class="keyword">float</span> x1, <span class="keyword">float</span> y1,</span><br><span class="line">	<span class="keyword">float</span> x2, <span class="keyword">float</span> y2,</span><br><span class="line">	<span class="keyword">float</span> &amp; signedArea)</span><br><span class="line">&#123;</span><br><span class="line">	signedArea = y1 * x2 - x1 * y2;</span><br><span class="line">	<span class="keyword">if</span> (signedArea &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (signedArea &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (y2 &gt; y1) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (y2 &lt; y1)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x1 &gt; x2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x1 &lt; x2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> LevelSet::pointInTriangle2D(</span><br><span class="line">	<span class="keyword">float</span> x0, <span class="keyword">float</span> y0,</span><br><span class="line">	<span class="keyword">float</span> x1, <span class="keyword">float</span> y1,</span><br><span class="line">	<span class="keyword">float</span> x2, <span class="keyword">float</span> y2,</span><br><span class="line">	<span class="keyword">float</span> x3, <span class="keyword">float</span> y3,</span><br><span class="line">	<span class="keyword">float</span> &amp; a, <span class="keyword">float</span> &amp; b, <span class="keyword">float</span> &amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	x1 -= x0; x2 -= x0; x3 -= x0;</span><br><span class="line">	y1 -= y0; y2 -= y0; y3 -= y0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> signA = orientation(x2, y2, x3, y3, a);</span><br><span class="line">	<span class="keyword">if</span> (signA == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> signB = orientation(x3, y3, x1, y1, b);</span><br><span class="line">	<span class="keyword">if</span> (signB != signA)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> signC = orientation(x1, y1, x2, y2, c);</span><br><span class="line">	<span class="keyword">if</span> (signC != signA)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">float</span> sum = a + b + c;</span><br><span class="line">	a /= sum;</span><br><span class="line">	b /= sum;</span><br><span class="line">	c /= sum;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除了前面的二维相交计算，在三维空间中，我们还要求欧拉网格点到三角形的垂直距离，从而得到每个点的距离场。这里采用重心法求点到三角形距离。求的三角形重心坐标$\alpha$、$\beta$、$\gamma$，设三角形的三个顶点为$\vec x_1$、$\vec x_2$、$\vec x_3$，求重心坐标就是求下面的$2\times2$的矩阵方程组：</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
\vec x_{21}\cdot \vec x_{21} & \vec x_{21}\cdot \vec x_{31}\\
\vec x_{21}\cdot \vec x_{31} & \vec x_{31}\cdot \vec x_{31}
\end{matrix}
\right]
\left[
\begin{matrix}
\beta \\
\gamma
\end{matrix}
\right]
=
\left[
\begin{matrix}
\vec x_{21}\cdot \vec x_{01}\\
\vec x_{31}\cdot \vec x_{01}
\end{matrix}
\right]\\
\alpha = 1 - \beta - \gamma \tag {8}</script><p>&emsp;&emsp;上面公式中的$\vec x_{21}$是$\vec x_2-\vec x_1$的简写，其他的类似。当且仅当求得的重心坐标$\alpha$、$\beta$和$\gamma$均大于0时，交点才在三角形的内部，此时的最近点就为$\alpha \vec x_1+\beta \vec x_2+\gamma \vec x_3$。否则SDF最近的点应该在三角形的边上，这里有一个小小的优化，就是若有一个重心坐标值大于0，则该重心坐标对应的点的对边不需要考虑进来。例如$\alpha&gt;0$，则无需考虑$\vec x_2-\vec x_1$这条边，但通常我们需要考虑剩下的两条边，然后取两者的距离最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> LevelSet::pointToTriangle(</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; x0,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; x1,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; x2,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; x3)</span><br><span class="line">&#123;</span><br><span class="line">	glm::vec3 x13 = x1 - x3;</span><br><span class="line">	glm::vec3 x23 = x2 - x3;</span><br><span class="line">	glm::vec3 x03 = x0 - x3;</span><br><span class="line">	<span class="keyword">float</span> m13 = glm::dot(x13, x13);</span><br><span class="line">	<span class="keyword">float</span> m23 = glm::dot(x23, x23);</span><br><span class="line">	<span class="keyword">float</span> d = glm::dot(x13, x23);</span><br><span class="line">	<span class="keyword">float</span> invDet = <span class="number">1.0f</span> / (glm::max(m13 * m23 - d * d, <span class="number">1e-30</span>f));</span><br><span class="line">	<span class="keyword">float</span> a = glm::dot(x13, x03), b = glm::dot(x23, x03);</span><br><span class="line">	<span class="comment">// the barycentric coordinates</span></span><br><span class="line">	<span class="keyword">float</span> w23 = invDet * (m23 * a - d * b);</span><br><span class="line">	<span class="keyword">float</span> w31 = invDet * (m13 * b - d * a);</span><br><span class="line">	<span class="keyword">float</span> w12 = <span class="number">1.0f</span> - w23 - w31;</span><br><span class="line">	<span class="keyword">if</span> (w23 &gt;= <span class="number">0</span> &amp;&amp; w31 &gt;= <span class="number">0</span> &amp;&amp; w12 &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> glm::distance(x0, w23 * x1 + w31 * x2 + w12 * x3);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (w23 &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> glm::min(pointToLineSegment(x0, x1, x2), pointToLineSegment(x0, x1, x3));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(w31 &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> glm::min(pointToLineSegment(x0, x1, x2), pointToLineSegment(x0, x2, x3));</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="keyword">return</span> glm::min(pointToLineSegment(x0, x1, x3), pointToLineSegment(x0, x2, x3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;求一点到给定线段的距离其实跟三角形的重心法类似，我们将给定的点投影到边上，然后取比值$\theta$（即线段的重心坐标）。设求点$\vec x_0$到线段$\vec x_1-\vec x_2$的最近的距离，则最近的点为$(1-\theta)\vec x_1+\vec x_2$。</p>
<script type="math/tex; mode=display">
\theta=\frac{(\vec x_2 - \vec x_1)\cdot(\vec x_0-\vec x_1)}{||\vec x_2-\vec x_1||^2} \tag {9}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> LevelSet::pointToLineSegment(</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; x0,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; x1,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; x2)</span><br><span class="line">&#123;</span><br><span class="line">	glm::vec3 dx = x2 - x1;</span><br><span class="line">	<span class="keyword">float</span> lengthSquared = glm::dot(dx, dx);</span><br><span class="line">	<span class="keyword">float</span> ret = glm::dot(x2 - x0, dx);</span><br><span class="line">	ret /= lengthSquared;</span><br><span class="line">	ret = glm::clamp(ret, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	<span class="keyword">return</span> glm::distance(x0, (x1 * ret + x2 * (<span class="number">1.0f</span> - ret)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;解决了以上问题，接下来我们就能完成Level Set算法中的第一步了：遍历模型的所有三角形，对于每一个三角形，我们计算其包围盒，在包围盒内的所有欧拉网格点，计算其到该三角形的垂直距离并与当前自己记录的最小距离进行比较、替换，与此同时记录最近的三角形的索引；然后将三角形投影（这里的投影很简单，不需要任何的计算，直接舍弃第三维$x$的值即可）到$yz$平面，计算其二维的包围盒，在这个二维包围盒内的所有点，判断其是否在三角形内，若在三角形内，则对应的相交记录数加1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LevelSet::makeLevelSet3D(</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Renderer::Vertex&gt;&amp; vertices,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; indices,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; origin, <span class="keyword">float</span> dx, glm::ivec3 dim, </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp; phi)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// initialization.</span></span><br><span class="line">	<span class="comment">// signed distance value.</span></span><br><span class="line">	phi.resize(dim.x * dim.y * dim.z, FLT_MAX);</span><br><span class="line">	<span class="comment">// closest triangle's index.</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; closestTriangle(dim.x * dim.y * dim.z, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">// intersection counting.</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersectionCount(dim.x * dim.y * dim.z, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// setp 1.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; indices.size(); x += <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		glm::vec3 p[<span class="number">3</span>];</span><br><span class="line">		p[<span class="number">0</span>] = vertices[indices[x + <span class="number">0</span>]].position;</span><br><span class="line">		p[<span class="number">1</span>] = vertices[indices[x + <span class="number">1</span>]].position;</span><br><span class="line">		p[<span class="number">2</span>] = vertices[indices[x + <span class="number">2</span>]].position;</span><br><span class="line">		glm::ivec3 index[<span class="number">3</span>];</span><br><span class="line">		index[<span class="number">0</span>] = glm::ivec3((p[<span class="number">0</span>].x - origin.x) / dx, (p[<span class="number">0</span>].y - origin.y) / dx, (p[<span class="number">0</span>].z - origin.z) / dx);</span><br><span class="line">		index[<span class="number">1</span>] = glm::ivec3((p[<span class="number">1</span>].x - origin.x) / dx, (p[<span class="number">1</span>].y - origin.y) / dx, (p[<span class="number">1</span>].z - origin.z) / dx);</span><br><span class="line">		index[<span class="number">2</span>] = glm::ivec3((p[<span class="number">2</span>].x - origin.x) / dx, (p[<span class="number">2</span>].y - origin.y) / dx, (p[<span class="number">2</span>].z - origin.z) / dx);</span><br><span class="line">		<span class="comment">// bounding box.</span></span><br><span class="line">		glm::ivec3 minIndex, maxIndex;</span><br><span class="line">		minIndex.x = (glm::clamp((<span class="keyword">int</span>)glm::min(glm::min(index[<span class="number">0</span>].x,</span><br><span class="line">			index[<span class="number">1</span>].x), index[<span class="number">2</span>].x) - <span class="number">1</span>, <span class="number">0</span>, dim.x - <span class="number">1</span>));</span><br><span class="line">		minIndex.y = (glm::clamp((<span class="keyword">int</span>)glm::min(glm::min(index[<span class="number">0</span>].y,</span><br><span class="line">			index[<span class="number">1</span>].y), index[<span class="number">2</span>].y) - <span class="number">1</span>, <span class="number">0</span>, dim.y - <span class="number">1</span>));</span><br><span class="line">		minIndex.z = (glm::clamp((<span class="keyword">int</span>)glm::min(glm::min(index[<span class="number">0</span>].z,</span><br><span class="line">			index[<span class="number">1</span>].z), index[<span class="number">2</span>].z) - <span class="number">1</span>, <span class="number">0</span>, dim.z - <span class="number">1</span>));</span><br><span class="line">		maxIndex.x = (glm::clamp((<span class="keyword">int</span>)glm::max(glm::max(index[<span class="number">0</span>].x,</span><br><span class="line">			index[<span class="number">1</span>].x), index[<span class="number">2</span>].x) + <span class="number">2</span>, <span class="number">0</span>, dim.x - <span class="number">1</span>));</span><br><span class="line">		maxIndex.y = (glm::clamp((<span class="keyword">int</span>)glm::max(glm::max(index[<span class="number">0</span>].y,</span><br><span class="line">			index[<span class="number">1</span>].y), index[<span class="number">2</span>].y) + <span class="number">2</span>, <span class="number">0</span>, dim.y - <span class="number">1</span>));</span><br><span class="line">		maxIndex.z = (glm::clamp((<span class="keyword">int</span>)glm::max(glm::max(index[<span class="number">0</span>].z,</span><br><span class="line">			index[<span class="number">1</span>].z), index[<span class="number">2</span>].z) + <span class="number">2</span>, <span class="number">0</span>, dim.z - <span class="number">1</span>));</span><br><span class="line">		<span class="comment">// update level set.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = minIndex.x; i &lt;= maxIndex.x; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = minIndex.y; j &lt; maxIndex.y; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = minIndex.z; k &lt; maxIndex.z; ++k)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">int</span> ind = i * dim.y * dim.z + j * dim.z + k;</span><br><span class="line">					glm::<span class="function">vec3 <span class="title">pos</span><span class="params">(origin.x + i * dx, origin.y + j * dx, origin.z + k * dx)</span></span>;</span><br><span class="line">					<span class="keyword">float</span> dist = pointToTriangle(pos, p[<span class="number">0</span>], p[<span class="number">1</span>], p[<span class="number">2</span>]);</span><br><span class="line">					<span class="keyword">if</span> (dist &lt; phi[ind])</span><br><span class="line">					&#123;</span><br><span class="line">						phi[ind] = dist;</span><br><span class="line">						closestTriangle[ind] = x;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// x-z plane bounding box.</span></span><br><span class="line">		minIndex.y = (glm::clamp((<span class="keyword">int</span>)glm::<span class="built_in">ceil</span>(</span><br><span class="line">			glm::min(glm::min(index[<span class="number">0</span>].y, index[<span class="number">1</span>].y), index[<span class="number">2</span>].y)), <span class="number">0</span>, dim.y - <span class="number">1</span>));</span><br><span class="line">		minIndex.z = (glm::clamp((<span class="keyword">int</span>)glm::<span class="built_in">ceil</span>(</span><br><span class="line">			glm::min(glm::min(index[<span class="number">0</span>].z, index[<span class="number">1</span>].z), index[<span class="number">2</span>].z)), <span class="number">0</span>, dim.z - <span class="number">1</span>));</span><br><span class="line">		maxIndex.y = (glm::clamp((<span class="keyword">int</span>)glm::<span class="built_in">floor</span>(</span><br><span class="line">			glm::max(glm::max(index[<span class="number">0</span>].y, index[<span class="number">1</span>].y), index[<span class="number">2</span>].y)), <span class="number">0</span>, dim.y - <span class="number">1</span>));</span><br><span class="line">		maxIndex.z = (glm::clamp((<span class="keyword">int</span>)glm::<span class="built_in">floor</span>(</span><br><span class="line">			glm::max(glm::max(index[<span class="number">0</span>].z, index[<span class="number">1</span>].z), index[<span class="number">2</span>].z)), <span class="number">0</span>, dim.z - <span class="number">1</span>));</span><br><span class="line">		<span class="comment">// intersection count.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = minIndex.y; j &lt;= maxIndex.y; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = minIndex.z; k &lt;= maxIndex.z; ++k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">float</span> a, b, c;</span><br><span class="line">				<span class="comment">// project to y-z plane</span></span><br><span class="line">				<span class="keyword">if</span> (pointInTriangle2D(j, k, </span><br><span class="line">					index[<span class="number">0</span>].y, index[<span class="number">0</span>].z,</span><br><span class="line">					index[<span class="number">1</span>].y, index[<span class="number">1</span>].z,</span><br><span class="line">					index[<span class="number">2</span>].y, index[<span class="number">2</span>].z,</span><br><span class="line">					a, b, c))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">float</span> fi = a * index[<span class="number">0</span>].x + b * index[<span class="number">1</span>].x + c * index[<span class="number">2</span>].x;</span><br><span class="line">					<span class="keyword">int</span> iInterval = <span class="keyword">int</span>(glm::<span class="built_in">ceil</span>(fi));</span><br><span class="line">					<span class="keyword">if</span> (iInterval &lt; <span class="number">0</span>)</span><br><span class="line">						intersectionCount[j * dim.z + k] += <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (iInterval &lt; dim.x)</span><br><span class="line">						intersectionCount[iInterval * dim.y * dim.z + j * dim.z + k] += <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Step1 finished.\n"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;紧接着第二步就是扩散步骤，在第一步中有些欧拉网格点已经获取了距离场信息，现在要将其传递到其它未知的欧拉网格中，从而得到完整的水平集结构。这里我们采用fast sweep算法，在三维空间中，传播方向有八个，即$i$递增、递减，$j$递增、递减，以及$k$递增、递减。因此算法将循环遍历八次，每次循环按照指定的方向进行遍历。同时，为了提高算法的准确率，我们设置迭代两次，每次传递八个方向。传播时，每个欧拉网格点根据给定的方向获取其邻居的距离场信息，若根据邻居的距离场信息得到的距离场数值更小，则进行替换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LevelSet::neighbour(</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Renderer::Vertex&gt;&amp; vertices,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; indices,</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp; phi,</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; closestTriangle,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; pos,</span><br><span class="line">	glm::ivec3 dim,</span><br><span class="line">	glm::ivec3 targetInd,</span><br><span class="line">	glm::ivec3 neighInd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> index = neighInd.x * dim.y * dim.z + neighInd.y * dim.z + neighInd.z;</span><br><span class="line">	<span class="keyword">if</span> (closestTriangle[index] &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> closestTriInd = closestTriangle[index];</span><br><span class="line">		glm::vec3 p[<span class="number">3</span>];</span><br><span class="line">		p[<span class="number">0</span>] = vertices[indices[closestTriInd + <span class="number">0</span>]].position;</span><br><span class="line">		p[<span class="number">1</span>] = vertices[indices[closestTriInd + <span class="number">1</span>]].position;</span><br><span class="line">		p[<span class="number">2</span>] = vertices[indices[closestTriInd + <span class="number">2</span>]].position;</span><br><span class="line">		<span class="keyword">float</span> dist = pointToTriangle(pos, p[<span class="number">0</span>], p[<span class="number">1</span>], p[<span class="number">2</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dist &lt; phi[targetInd.x * dim.y * dim.z + targetInd.y * dim.z + targetInd.z])</span><br><span class="line">		&#123;</span><br><span class="line">			phi[targetInd.x * dim.y * dim.z + targetInd.y * dim.z + targetInd.z] = dist;</span><br><span class="line">			closestTriangle[targetInd.x * dim.y * dim.z + targetInd.y * dim.z + targetInd.z] = closestTriInd;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LevelSet::fastSweep(</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Renderer::Vertex&gt;&amp; vertices,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; indices,</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp; phi,</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; closestTriangle,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; origin,</span><br><span class="line">	<span class="keyword">float</span> dx,</span><br><span class="line">	glm::ivec3 dim,</span><br><span class="line">	glm::ivec3 dir)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i0, i1;</span><br><span class="line">	<span class="keyword">if</span> (dir.x &gt; <span class="number">0</span>)</span><br><span class="line">		i0 = <span class="number">1</span>, i1 = dim.x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i0 = dim.x - <span class="number">2</span>, i1 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> j0, j1;</span><br><span class="line">	<span class="keyword">if</span> (dir.y &gt; <span class="number">0</span>)</span><br><span class="line">		j0 = <span class="number">1</span>, j1 = dim.y;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		j0 = dim.y - <span class="number">2</span>, j1 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> k0, k1;</span><br><span class="line">	<span class="keyword">if</span> (dir.z &gt; <span class="number">0</span>)</span><br><span class="line">		k0 = <span class="number">1</span>, k1 = dim.z;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		k0 = dim.z - <span class="number">2</span>, k1 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = i0; i != i1; i += dir.x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = j0; j != j1; j += dir.y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = k0; k != k1; k += dir.z)</span><br><span class="line">			&#123;</span><br><span class="line">				glm::<span class="function">vec3 <span class="title">pos</span><span class="params">(origin.x + i * dx, origin.y + j * dx, origin.z + k * dx)</span></span>;</span><br><span class="line">				neighbour(vertices, indices, phi, closestTriangle,</span><br><span class="line">					pos, dim, glm::ivec3(i,j,k), glm::ivec3(i - dir.x, j, k));</span><br><span class="line">				neighbour(vertices, indices, phi, closestTriangle,</span><br><span class="line">					pos, dim, glm::ivec3(i, j, k), glm::ivec3(i, j - dir.y, k));</span><br><span class="line">				neighbour(vertices, indices, phi, closestTriangle,</span><br><span class="line">					pos, dim, glm::ivec3(i, j, k), glm::ivec3(i, j, k - dir.z));</span><br><span class="line">				neighbour(vertices, indices, phi, closestTriangle,</span><br><span class="line">					pos, dim, glm::ivec3(i, j, k), glm::ivec3(i - dir.x, j - dir.y, k));</span><br><span class="line">				neighbour(vertices, indices, phi, closestTriangle,</span><br><span class="line">					pos, dim, glm::ivec3(i, j, k), glm::ivec3(i - dir.x, j, k - dir.z));</span><br><span class="line">				neighbour(vertices, indices, phi, closestTriangle,</span><br><span class="line">					pos, dim, glm::ivec3(i, j, k), glm::ivec3(i, j - dir.y, k - dir.z));</span><br><span class="line">				neighbour(vertices, indices, phi, closestTriangle,</span><br><span class="line">					pos, dim, glm::ivec3(i, j, k), glm::ivec3(i - dir.x, j - dir.y, k - dir.z));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LevelSet::makeLevelSet3D(</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Renderer::Vertex&gt;&amp; vertices,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; indices,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; origin, <span class="keyword">float</span> dx, glm::ivec3 dim, </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp; phi)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// initialization.</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// setp 1.</span></span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// step 2.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> pass = <span class="number">0</span>; pass &lt; <span class="number">2</span>; ++pass)</span><br><span class="line">	&#123;</span><br><span class="line">		fastSweep(vertices, indices, phi, closestTriangle, origin, dx, dim, glm::ivec3(+<span class="number">1</span>, +<span class="number">1</span>, +<span class="number">1</span>));</span><br><span class="line">		fastSweep(vertices, indices, phi, closestTriangle, origin, dx, dim, glm::ivec3(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">		fastSweep(vertices, indices, phi, closestTriangle, origin, dx, dim, glm::ivec3(+<span class="number">1</span>, +<span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">		fastSweep(vertices, indices, phi, closestTriangle, origin, dx, dim, glm::ivec3(+<span class="number">1</span>, <span class="number">-1</span>, +<span class="number">1</span>));</span><br><span class="line">		fastSweep(vertices, indices, phi, closestTriangle, origin, dx, dim, glm::ivec3(<span class="number">-1</span>, +<span class="number">1</span>, +<span class="number">1</span>));</span><br><span class="line">		fastSweep(vertices, indices, phi, closestTriangle, origin, dx, dim, glm::ivec3(<span class="number">-1</span>, <span class="number">-1</span>, +<span class="number">1</span>));</span><br><span class="line">		fastSweep(vertices, indices, phi, closestTriangle, origin, dx, dim, glm::ivec3(<span class="number">-1</span>, +<span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">		fastSweep(vertices, indices, phi, closestTriangle, origin, dx, dim, glm::ivec3(+<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Step2 finished.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后的第三步就是修正距离场的符号，前面我们计算得到的距离场都是没有符号的。有了前面计算得到的相交记录数组，判断符号就容易了。注意前面我们计算得到的相交记录的值仅仅是一条边的相交记录，最后我们从$x$轴负方向朝着$x$轴正方面推进，叠加相交记录次数，得到以当前欧拉网格点为起点、朝向$x$轴负方向的射线与网格的相交情况，若为奇数，则需要将距离场的值置为负数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LevelSet::makeLevelSet3D(</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Renderer::Vertex&gt;&amp; vertices,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; indices,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; origin, <span class="keyword">float</span> dx, glm::ivec3 dim, </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp; phi)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// initialization.</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// setp 1.</span></span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// step 2.</span></span><br><span class="line">	...</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// step 3.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dim.y; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dim.z; ++k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> totalCount = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dim.x; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> index = i * dim.y * dim.z + j * dim.z + k;</span><br><span class="line">				totalCount += intersectionCount[index];</span><br><span class="line">				<span class="keyword">if</span> (totalCount % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">					phi[index] = -phi[index];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Step3 finished.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、Marching-Cube重建算法"><a href="#三、Marching-Cube重建算法" class="headerlink" title="三、Marching Cube重建算法"></a>三、Marching Cube重建算法</h2><p>&emsp;&emsp;在前面我们实现了Level Set的构造方法，通过离散空间将三角网格的SDF值保存下来。在欧拉方法的流体模拟中，除了将三角网格模型离散化为水平集之外，还涉及到根据给定的水平集以及等高值，从中重建出网格模型，最经典的就是流体表面的网格重建过程。根据给定的欧拉网格结构重建网格模型最经典、常用的算法就是Marching Cube算法。Marching Cube算法的基本思想就是在欧拉网格的每一个立方体内，寻找在等值面上的网格点。一个立方体有八个顶点，每个顶点对应的函数值各有不同。以0等值面为例，我们要寻找函数值为0的网格点，从而生成三角网格模型。假设有一条边及其两个端点$(i,j,k)$和$(i+1,j,k)$，倘若其一端$(i,j,k)$的函数值大于0，另一端$(i+1,j,k)$的函数值小于0，那么必然在这条线段上存在一个0等值点$p$，可以通过线性插值得到：</p>
<script type="math/tex; mode=display">
\theta=\frac{\phi_{i,j,k}}{\phi_{i,j,k}-\phi_{i+1,j,k}} \\
p=((i+\theta)\Delta x,j\Delta x,k\Delta x) \tag {10}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> MarchingCube::fraction(<span class="keyword">float</span> value, <span class="keyword">float</span> lower, <span class="keyword">float</span> upper)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (value - lower) / (upper - lower);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glm::vec3 MarchingCube::interpolate(<span class="keyword">const</span> glm::vec3 &amp; v0, <span class="keyword">const</span> glm::vec3 &amp; v1, <span class="keyword">float</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0f</span> - value) * v0 + value * v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;立方体有八个顶点，给定一个值，相对于这个值，每个顶点的函数值分为大于给定值和小于给定值两种情况。因此在一个立方体上，传统的Marching Cube算法需要考虑$2^8=256$中情况，这通常通过预先生成一个查找表来进行。即便如此，Robert Brdison指出Lorensen等人的Marching Cube算法因为拓扑结构的歧义性偶尔会产生一些孔洞，从而得到非封闭的网格模型。这里我们采用Marching Cube中的一个鲁棒性更强的算法——Marching Tetrahedra算法，与Marching Cube的直接对整个立方体进行操作不同，Marching Tetrahedra算法将立方体进一步划分成多个四面体（Tetrahedra），然后对四面体进行操作，即计算四面体四个顶点的函数值，并判断是否存在等值点，存在的话就根据等值点构建三角形。</p>
<p>&emsp;&emsp;将立方体划分成多个四面体的方法如下图4所示，立方体有三对对立面，即上和下、左和右、前和后。对于每一个对立面，取同一轨迹的对角线，以这两条对角线所在的平面将立方体，如此切割三次就能得到构成立方体的六个四面体（下图4中六个不同颜色的四面体）。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.22/blog/LevelSet/4.jpg" width="40%"></div></p>
<center> 图4 划分得到的Tetrahedra </center>


<p>&emsp;&emsp;与传统的Marching Cube算法相比，Marching Tetrahedra算法的优势更多。在Marching Cube算法中，操作单位为一个立方体，一个等值面截过立方体构成的截面可以是很复杂的曲面；而在Marching Tetrahedra算法中，操作单位变成了一个四面体，一个等值面截过四面体构成的截面通常只能是单个三角形、或者一个四边形（这个四边形可以分成两个三角形）。另外，因为四面体只有4个顶点，因而单个四面体只需考虑$2^4=16$中情况，相对于原来的$256$种情况大大降低了代码的复杂度。Marching Tetrahedra唯一的缺点就是生成的三角形偏多。</p>
<p>&emsp;&emsp;Marching Tetrahedra算法不太复杂，算法总体上就是一个循环，遍历所有的cube，然后将cube划分成六个四面体，根据四面体四个顶点的函数值判断是否存在三角形。上面已经提到过了，在四面体中最多就存在两个三角形。Marching Tetrahedra算法总体上分为三种情况：不存在三角形、存在一个三角形、存在两个三角形。</p>
<p>&emsp;&emsp;首先来看第一种情况，即不存在三角形。这种情况很好理解，当四面体所有顶点的函数值均为正数或者负数时（这里的正数或负数是相对于给定的函数值点来说，大于给定值则为正，小于则为负），不存在一个0等值点（或者其他等值点），从而不存在三角形。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; MarchingCube::marchingTetrahedra(</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v0, <span class="keyword">const</span> glm::vec3 &amp; v1,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v2, <span class="keyword">const</span> glm::vec3 &amp; v3,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp; value0, <span class="keyword">const</span> <span class="keyword">float</span> &amp; value1,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp; value2, <span class="keyword">const</span> <span class="keyword">float</span> &amp; value3,</span><br><span class="line">	<span class="keyword">float</span> isovalue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; triangles;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// signs.</span></span><br><span class="line">	<span class="keyword">int</span> sign0 = (value0 &gt; isovalue) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> sign1 = (value1 &gt; isovalue) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> sign2 = (value2 &gt; isovalue) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> sign3 = (value3 &gt; isovalue) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// all negative or all positive, no triangles.</span></span><br><span class="line">	<span class="keyword">if</span> ((sign0 == <span class="number">0</span> &amp;&amp; sign1 == <span class="number">0</span> &amp;&amp; sign2 == <span class="number">0</span> &amp;&amp; sign3 == <span class="number">0</span>) ||</span><br><span class="line">		(sign0 == <span class="number">1</span> &amp;&amp; sign1 == <span class="number">1</span> &amp;&amp; sign2 == <span class="number">1</span> &amp;&amp; sign3 == <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> triangles;</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后是第二种情况，即存在一个三角形。注意到一个这样的事实：当四面体的一个顶点函数值为正数，其余三个顶点为负数时，在正值顶点与负值顶点相连的边上可以得到一个等值点，正值顶点分别与三个负值顶点相连的边上可以得到三个等值点，从而构成一个三角形。反过来也一样，当只有一个顶点为负数，其余顶点为正数时同理。如下图5所示，四面体的四个顶点分别为$v_1$、$v_2$、$v_3$和$v_4$，其中$v_1$的函数值为负值，$v_2$、$v_3$和$v_4$的函数值为正，从而通过线性插值得到图中的三个等值点$p_1$、$p_2$和$p_3$，将这三个顶点相连即可得到一个三角形。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.22/blog/LevelSet/5.png" width="60%"></div></p>
<center> 图5 一个三角形的情况 </center>


<p>&emsp;&emsp;一个三角形的情形共有8种，一正三负4种，一负三正4种，在代码种逐一枚举即可。这里需要注意，当三角形退化成一个点时我们不将将其纳入我们的网格顶点中。同时为了使得生成的三角形环绕顺序遵循向外的逆时针方向，在实现时需特别注意顶点的顺序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; MarchingCube::getOneTriangle(</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v0, <span class="keyword">const</span> glm::vec3 &amp; v1,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v2, <span class="keyword">const</span> glm::vec3 &amp; v3,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp;value0, <span class="keyword">const</span> <span class="keyword">float</span> &amp;value1,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp;value2, <span class="keyword">const</span> <span class="keyword">float</span> &amp;value3,</span><br><span class="line">	<span class="keyword">float</span> isovalue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">float</span> t01 = fraction(isovalue, value0, value1);</span><br><span class="line">	<span class="keyword">float</span> t02 = fraction(isovalue, value0, value2);</span><br><span class="line">	<span class="keyword">float</span> t03 = fraction(isovalue, value0, value3);</span><br><span class="line">	glm::vec3 ver0 = interpolate(v0, v1, t01);</span><br><span class="line">	glm::vec3 ver1 = interpolate(v0, v2, t02);</span><br><span class="line">	glm::vec3 ver2 = interpolate(v0, v3, t03);</span><br><span class="line">	<span class="keyword">if</span> (isTriangle(ver0, ver1, ver2))</span><br><span class="line">		<span class="keyword">return</span> &#123; ver0, ver1, ver2 &#125;;</span><br><span class="line">	<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; MarchingCube::marchingTetrahedra(</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v0, <span class="keyword">const</span> glm::vec3 &amp; v1,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v2, <span class="keyword">const</span> glm::vec3 &amp; v3,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp; value0, <span class="keyword">const</span> <span class="keyword">float</span> &amp; value1,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp; value2, <span class="keyword">const</span> <span class="keyword">float</span> &amp; value3,</span><br><span class="line">	<span class="keyword">float</span> isovalue)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// One positive vertex, all others negative =&gt; One triangle</span></span><br><span class="line">	<span class="keyword">if</span> (sign0 == <span class="number">1</span> &amp;&amp; sign1 == <span class="number">0</span> &amp;&amp; sign2 == <span class="number">0</span> &amp;&amp; sign3 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 0-1, 0-2 and 0-3</span></span><br><span class="line">		triangles = getOneTriangle(v0, v1, v2, v3,</span><br><span class="line">			value0, value1, value2, value3, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">0</span> &amp;&amp; sign1 == <span class="number">1</span> &amp;&amp; sign2 == <span class="number">0</span> &amp;&amp; sign3 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 1-2, 1-3 and 1-0</span></span><br><span class="line">		triangles = getOneTriangle(v1, v2, v0, v3,</span><br><span class="line">			value1, value2, value0, value3, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">0</span> &amp;&amp; sign1 == <span class="number">0</span> &amp;&amp; sign2 == <span class="number">1</span> &amp;&amp; sign3 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 2-0, 2-1 and 2-3</span></span><br><span class="line">		triangles = getOneTriangle(v2, v0, v1, v3,</span><br><span class="line">			value2, value0, value1, value3, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">0</span> &amp;&amp; sign1 == <span class="number">0</span> &amp;&amp; sign2 == <span class="number">0</span> &amp;&amp; sign3 == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 3-2, 3-0 and 3-1</span></span><br><span class="line">		triangles = getOneTriangle(v3, v2, v1, v0,</span><br><span class="line">			value3, value2, value1, value0, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// One negative vertex, all others positive =&gt; One triangle</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">0</span> &amp;&amp; sign1 == <span class="number">1</span> &amp;&amp; sign2 == <span class="number">1</span> &amp;&amp; sign3 == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 0-1, 0-3 and 0-2</span></span><br><span class="line">		triangles = getOneTriangle(v0, v3, v2, v1,</span><br><span class="line">			value0, value3, value2, value1, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">1</span> &amp;&amp; sign1 == <span class="number">0</span> &amp;&amp; sign2 == <span class="number">1</span> &amp;&amp; sign3 == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 1-2, 1-3 and 1-0</span></span><br><span class="line">		triangles = getOneTriangle(v1, v3, v0, v2,</span><br><span class="line">			value1, value3, value0, value2, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">1</span> &amp;&amp; sign1 == <span class="number">1</span> &amp;&amp; sign2 == <span class="number">0</span> &amp;&amp; sign3 == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 2-0, 2-3 and 2-1</span></span><br><span class="line">		triangles = getOneTriangle(v2, v3, v1, v0,</span><br><span class="line">			value2, value3, value1, value0, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">1</span> &amp;&amp; sign1 == <span class="number">1</span> &amp;&amp; sign2 == <span class="number">1</span> &amp;&amp; sign3 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 3-2, 3-0 and 3-1</span></span><br><span class="line">		triangles = getOneTriangle(v3, v0, v1, v2,</span><br><span class="line">			value3, value0, value1, value2, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后就是第三种情况，即存在两个三角形。当四个顶点中有两个顶点函数值为正，两个顶点函数值为负时，从正值顶点分别于负值顶点相连的边上可以获取一个等值点，一共可以得到四个等值点，构成一个四边形，或者说两个三角形。如下图6所示，负值顶点为$v_1$、$v_2$，正值顶点为$v_3$、$v_4$，$v_1$分别与$v_3$、$v_4$相连的边上可以得到等值点$p_1$、$p_2$，$v_2$分别与$v_3$、$v_4$相连的边上可以得到等值点$p_3$、$p_4$。最后根据这四个点分别作两个三角形即可。两个三角形的情况共有$C_4^2=6$种，逐一枚举即可。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.22/blog/LevelSet/6.png" width="99%"></div></p>
<center> 图6 两个三角形的情况 </center>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; MarchingCube::getTwoTriangle(</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v0, <span class="keyword">const</span> glm::vec3 &amp; v1,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v2, <span class="keyword">const</span> glm::vec3 &amp; v3,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp;value0, <span class="keyword">const</span> <span class="keyword">float</span> &amp;value1,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp;value2, <span class="keyword">const</span> <span class="keyword">float</span> &amp;value3,</span><br><span class="line">	<span class="keyword">float</span> isovalue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">float</span> t02 = fraction(isovalue, value0, value2);</span><br><span class="line">	<span class="keyword">float</span> t03 = fraction(isovalue, value0, value3);</span><br><span class="line">	<span class="keyword">float</span> t12 = fraction(isovalue, value1, value2);</span><br><span class="line">	<span class="keyword">float</span> t13 = fraction(isovalue, value1, value3);</span><br><span class="line"></span><br><span class="line">	glm::vec3 ver0 = interpolate(v0, v2, t02);</span><br><span class="line">	glm::vec3 ver1 = interpolate(v0, v3, t03);</span><br><span class="line">	glm::vec3 ver2 = interpolate(v1, v2, t12);</span><br><span class="line">	glm::vec3 ver3 = interpolate(v1, v3, t13);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; ret;</span><br><span class="line">	<span class="keyword">if</span> (isTriangle(ver0, ver1, ver2))</span><br><span class="line">	&#123;</span><br><span class="line">		ret.push_back(ver0);</span><br><span class="line">		ret.push_back(ver1);</span><br><span class="line">		ret.push_back(ver2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isTriangle(ver2, ver1, ver3))</span><br><span class="line">	&#123;</span><br><span class="line">		ret.push_back(ver2);</span><br><span class="line">		ret.push_back(ver1);</span><br><span class="line">		ret.push_back(ver3);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; MarchingCube::marchingTetrahedra(</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v0, <span class="keyword">const</span> glm::vec3 &amp; v1,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v2, <span class="keyword">const</span> glm::vec3 &amp; v3,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp; value0, <span class="keyword">const</span> <span class="keyword">float</span> &amp; value1,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp; value2, <span class="keyword">const</span> <span class="keyword">float</span> &amp; value3,</span><br><span class="line">	<span class="keyword">float</span> isovalue)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// Two positive vertice, two negative vertice =&gt; Two triangle</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">1</span> &amp;&amp; sign1 == <span class="number">1</span> &amp;&amp; sign2 == <span class="number">0</span> &amp;&amp; sign3 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 0-2, 0-3, 1-2 and 1-3.</span></span><br><span class="line">		triangles = getTwoTriangle(v0, v1, v2, v3,</span><br><span class="line">			value0, value1, value2, value3, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">0</span> &amp;&amp; sign1 == <span class="number">1</span> &amp;&amp; sign2 == <span class="number">1</span> &amp;&amp; sign3 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 1-0, 1-3, 2-0 and 2-3.</span></span><br><span class="line">		triangles = getTwoTriangle(v1, v2, v0, v3,</span><br><span class="line">			value1, value2, value0, value3, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">0</span> &amp;&amp; sign1 == <span class="number">0</span> &amp;&amp; sign2 == <span class="number">1</span> &amp;&amp; sign3 == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 2-0, 2-1, 3-0 and 3-1.</span></span><br><span class="line">		triangles = getTwoTriangle(v2, v3, v0, v1,</span><br><span class="line">			value2, value3, value0, value1, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">1</span> &amp;&amp; sign1 == <span class="number">0</span> &amp;&amp; sign2 == <span class="number">0</span> &amp;&amp; sign3 == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 0-1, 0-2, 3-1 and 3-2.</span></span><br><span class="line">		triangles = getTwoTriangle(v0, v3, v1, v2,</span><br><span class="line">			value0, value3, value1, value2, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">1</span> &amp;&amp; sign1 == <span class="number">0</span> &amp;&amp; sign2 == <span class="number">1</span> &amp;&amp; sign3 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 0-1, 0-3, 2-1 and 2-3.</span></span><br><span class="line">		triangles = getTwoTriangle(v0, v2, v3, v1,</span><br><span class="line">			value0, value2, value3, value1, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign0 == <span class="number">0</span> &amp;&amp; sign1 == <span class="number">1</span> &amp;&amp; sign2 == <span class="number">0</span> &amp;&amp; sign3 == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Vertices are in edges 1-0, 1-2, 3-0 and 3-2.</span></span><br><span class="line">		triangles = getTwoTriangle(v1, v3, v2, v0,</span><br><span class="line">			value1, value3, value2, value0, isovalue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> triangles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面讨论的都是单个四面体的情形，然后我们需要将一个立方体划分成六个四面体，每个四面体执行上面的Marching Tetrahedra算法，最后将每个四面体得到的三角形合起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MarchingCube::marchingCube(</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v0, <span class="keyword">const</span> glm::vec3 &amp; v1,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v2, <span class="keyword">const</span> glm::vec3 &amp; v3,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v4, <span class="keyword">const</span> glm::vec3 &amp; v5,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; v6, <span class="keyword">const</span> glm::vec3 &amp; v7,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp; value0, <span class="keyword">const</span> <span class="keyword">float</span> &amp; value1,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp; value2, <span class="keyword">const</span> <span class="keyword">float</span> &amp; value3,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp; value4, <span class="keyword">const</span> <span class="keyword">float</span> &amp; value5,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> &amp; value6, <span class="keyword">const</span> <span class="keyword">float</span> &amp; value7,</span><br><span class="line">	<span class="keyword">float</span> isovalue,</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; mesh)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; tmp;</span><br><span class="line"></span><br><span class="line">	tmp = marchingTetrahedra(v5, v0, v3, v1, value5, value0, value3, value1, isovalue);</span><br><span class="line">	mesh.insert(mesh.begin(), tmp.begin(), tmp.end());</span><br><span class="line"></span><br><span class="line">	tmp = marchingTetrahedra(v5, v1, v3, v2, value5, value1, value3, value2, isovalue);</span><br><span class="line">	mesh.insert(mesh.begin(), tmp.begin(), tmp.end());</span><br><span class="line"></span><br><span class="line">	tmp = marchingTetrahedra(v5, v4, v3, v0, value5, value4, value3, value0, isovalue);</span><br><span class="line">	mesh.insert(mesh.begin(), tmp.begin(), tmp.end());</span><br><span class="line"></span><br><span class="line">	tmp = marchingTetrahedra(v5, v3, v6, v2, value5, value3, value6, value2, isovalue);</span><br><span class="line">	mesh.insert(mesh.begin(), tmp.begin(), tmp.end());</span><br><span class="line"></span><br><span class="line">	tmp = marchingTetrahedra(v5, v4, v7, v3, value5, value4, value7, value3, isovalue);</span><br><span class="line">	mesh.insert(mesh.begin(), tmp.begin(), tmp.end());</span><br><span class="line"></span><br><span class="line">	tmp = marchingTetrahedra(v5, v3, v7, v6, value5, value3, value7, value6, isovalue);</span><br><span class="line">	mesh.insert(mesh.begin(), tmp.begin(), tmp.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>这里为了验证前面水平集算法实现的正确性，将构建得到的水平集传入Marching Cube中，构建一个网格模型，</strong>即构建水平集的逆过程。重构过程根据前面水平集划分的欧拉网格大小，对每一个立方体执行Marching Cube算法，三重循环即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; MarchingCube::reconstructMeshFromLevelSet(</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp; phi,</span><br><span class="line">	<span class="keyword">float</span> isovalue,</span><br><span class="line">	glm::ivec3 dim,</span><br><span class="line">	<span class="keyword">float</span> dx,</span><br><span class="line">	glm::vec3 origin)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// reconstruct a mesh from given level set.</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; mesh;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dim.x - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dim.y - <span class="number">1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dim.z - <span class="number">1</span>; ++k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 8 vertice of a cube.</span></span><br><span class="line">				glm::vec3 p[<span class="number">8</span>];</span><br><span class="line">				p[<span class="number">0</span>] = glm::vec3(origin.x + i * dx, origin.y + j * dx, origin.z + k * dx);</span><br><span class="line">				p[<span class="number">1</span>] = glm::vec3(p[<span class="number">0</span>].x + dx, p[<span class="number">0</span>].y, p[<span class="number">0</span>].z);</span><br><span class="line">				p[<span class="number">2</span>] = glm::vec3(p[<span class="number">0</span>].x + dx, p[<span class="number">0</span>].y, p[<span class="number">0</span>].z + dx);</span><br><span class="line">				p[<span class="number">3</span>] = glm::vec3(p[<span class="number">0</span>].x, p[<span class="number">0</span>].y, p[<span class="number">0</span>].z + dx);</span><br><span class="line">				p[<span class="number">4</span>] = glm::vec3(p[<span class="number">0</span>].x, p[<span class="number">0</span>].y + dx, p[<span class="number">0</span>].z);</span><br><span class="line">				p[<span class="number">5</span>] = glm::vec3(p[<span class="number">0</span>].x + dx, p[<span class="number">0</span>].y + dx, p[<span class="number">0</span>].z);</span><br><span class="line">				p[<span class="number">6</span>] = glm::vec3(p[<span class="number">0</span>].x + dx, p[<span class="number">0</span>].y + dx, p[<span class="number">0</span>].z + dx);</span><br><span class="line">				p[<span class="number">7</span>] = glm::vec3(p[<span class="number">0</span>].x, p[<span class="number">0</span>].y + dx, p[<span class="number">0</span>].z + dx);</span><br><span class="line">				<span class="comment">// the corresponding sdf value.</span></span><br><span class="line">				<span class="keyword">float</span> value[<span class="number">8</span>];</span><br><span class="line">				value[<span class="number">0</span>] = phi[i * dim.y * dim.z + j * dim.z + k];</span><br><span class="line">				value[<span class="number">1</span>] = phi[(i + <span class="number">1</span>) * dim.y * dim.z + j * dim.z + k];</span><br><span class="line">				value[<span class="number">2</span>] = phi[(i + <span class="number">1</span>) * dim.y * dim.z + j * dim.z + k + <span class="number">1</span>];</span><br><span class="line">				value[<span class="number">3</span>] = phi[i * dim.y * dim.z + j * dim.z + k + <span class="number">1</span>];</span><br><span class="line">				value[<span class="number">4</span>] = phi[i * dim.y * dim.z + (j + <span class="number">1</span>) * dim.z + k];</span><br><span class="line">				value[<span class="number">5</span>] = phi[(i + <span class="number">1</span>) * dim.y * dim.z + (j + <span class="number">1</span>) * dim.z + k];</span><br><span class="line">				value[<span class="number">6</span>] = phi[(i + <span class="number">1</span>) * dim.y * dim.z + (j + <span class="number">1</span>) * dim.z + k + <span class="number">1</span>];</span><br><span class="line">				value[<span class="number">7</span>] = phi[i * dim.y * dim.z + (j + <span class="number">1</span>) * dim.z + k + <span class="number">1</span>];</span><br><span class="line">				<span class="comment">// marching a cube.</span></span><br><span class="line">				marchingCube(p[<span class="number">0</span>], p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>], p[<span class="number">4</span>], p[<span class="number">5</span>], p[<span class="number">6</span>], p[<span class="number">7</span>],</span><br><span class="line">					value[<span class="number">0</span>], value[<span class="number">1</span>], value[<span class="number">2</span>], value[<span class="number">3</span>], value[<span class="number">4</span>], value[<span class="number">5</span>], value[<span class="number">6</span>], value[<span class="number">7</span>],</span><br><span class="line">					isovalue, mesh);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mesh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面几张图展示了从水平集重建的网格。左边是原三角网格模型，精度均比较高，右边的是通过构建了水平集之后再从水平集重建的网格模型。受限于水平集的欧拉网格精度，重建得到的网格模型显然精度没有那么高，是一个粗糙的low poly模型。通过Marching Tetrahedra算法得到的网格依然是封闭的，这也验证了我们前面的水平集算法实现的正确性。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.22/blog/LevelSet/ret1.png" width="99%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.22/blog/LevelSet/ret2.png" width="99%"></div></p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>$[1]$ <a href="https://en.wikipedia.org/wiki/Marching_tetrahedra" target="_blank" rel="noopener">Marching tetrahedra. From Wikipedia, the free encyclopedia</a></p>
<p>$[2]$ Edelsbrunner H, Mucke E P. Simulation of Simplicity: A Technique to Cope with Degenerate Cases in Geometric Algorithms[J]. Acm Transactions on Graphics, 1990, 9(1):66-104.</p>
<p>$[3]$ 《Fluid Simulation For Computer Graphics》, Robert Bridson.</p>

        </div>
        
          


  <section class="meta" id="footer-meta">
    <hr>
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-10-20T17:05:38+08:00">
  <a class="notlink">
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>最后更新于 2019年10月20日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Computer-Graphics/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Computer Graphics</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Fluid-Simulation/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Fluid Simulation</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yangwc.com/2019/07/30/LevelSet/&title=流体模拟Fluid Simulation：Level Set & Marching Cube | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本文主要是基于欧拉网格流体模拟中的算法常客——Level Set和Marching Cube，Level Set算法负责构建复杂的边界几何体，而Marching Cube负责从欧拉网格中重建流体表面。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://yangwc.com/2019/07/30/LevelSet/&title=流体模拟Fluid Simulation：Level Set & Marching Cube | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本文主要是基于欧拉网格流体模拟中的算法常客——Level Set和Marching Cube，Level Set算法负责构建复杂的边界几何体，而Marching Cube负责从欧拉网格中重建流体表面。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=https://yangwc.com/2019/07/30/LevelSet/&title=流体模拟Fluid Simulation：Level Set & Marching Cube | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本文主要是基于欧拉网格流体模拟中的算法常客——Level Set和Marching Cube，Level Set算法负责构建复杂的边界几何体，而Marching Cube负责从欧拉网格中重建流体表面。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                            <h4>
                                <a href="/2019/08/03/MakingFluidImcompressible/" rel="prev" title="流体模拟Fluid Simulation：求解流体不可压缩的泊松方程">
                                  
                                      流体模拟Fluid Simulation：求解流体不可压缩的泊松方程
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Fluid-Simulation/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Fluid Simulation</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2019/07/23/2DLighting/" rel="prev" title="二维渲染2D Rendering：2D Lighting">
                                    
                                        二维渲染2D Rendering：2D Lighting
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/2D-Rendering/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>2D Rendering</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
        <section id="comments">
          <div id="lv-container" data-id="city" data-uid="MTAyMC80MzkxOS8yMDQ1NQ==">
            <noscript><div><i class="fas fa-exclamation-triangle">&nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。</i></div></noscript>
          </div>
        </section>
      
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

  <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



  <script>
    window.subData = {
      title: '流体模拟Fluid Simulation：Level Set & Marching Cube',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content material">
    
      <div class="avatar">
        <fancybox><img class="avatar" src="/image/avator.jpg"></fancybox>
      </div>
    
    
      <div class="text">
        
          <h2>YangWC</h2>
        
        
          <p>A student from Sun Yat-sen University.</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget toc-wrapper">
    
<header class="material">
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class="content material">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、符号距离场"><span class="toc-text">一、符号距离场</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、三角形网格的SDF计算"><span class="toc-text">二、三角形网格的SDF计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Marching-Cube重建算法"><span class="toc-text">三、Marching Cube重建算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料："><span class="toc-text">参考资料：</span></a></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class="widget plain">
  
<header class="material">
  <div><i class=" fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;欢迎来到YangWC的博客</div>
  
</header>

  <div class="content material">
    <p>本站会记录自己的一些学习内容，如若有错或者乱码，欢迎指正，感谢!</p>

  </div>
</section>

          
        
      
        
          
          
            <section class="widget grid">
  
<header class="material">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content material">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于博主
        </a></li>
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn" rel="nofollow" href="/categories/" title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/2D-Rendering/" href="/categories/2D-Rendering/"><div class="name">2D Rendering</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Computer-Graphics/" href="/categories/Computer-Graphics/"><div class="name">Computer Graphics</div><div class="badge">(34)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-Simulation/" href="/categories/Fluid-Simulation/"><div class="name">Fluid Simulation</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-simulation/" href="/categories/Fluid-simulation/"><div class="name">Fluid  simulation</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Image-processing/" href="/categories/Image-processing/"><div class="name">Image processing</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/N-body/" href="/categories/N-body/"><div class="name">N-body</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physical-simulation/" href="/categories/Physical-simulation/"><div class="name">Physical simulation</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physically-Based-Rendering/" href="/categories/Physically-Based-Rendering/"><div class="name">Physically Based Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Position-Based-Dynamics/" href="/categories/Position-Based-Dynamics/"><div class="name">Position Based Dynamics</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Ray-Tracer/" href="/categories/Ray-Tracer/"><div class="name">Ray Tracer</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Real-time-Rendering/" href="/categories/Real-time-Rendering/"><div class="name">Real-time Rendering</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Soft-Renderer/" href="/categories/Soft-Renderer/"><div class="name">Soft Renderer</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Voxelization/" href="/categories/Voxelization/"><div class="name">Voxelization</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class="widget tagcloud">
    
<header class="material">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn" rel="nofollow" href="/tags/" title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <a href="/tags/2D-Rendering/" style="font-size: 14px; color: #bbb">2D Rendering</a> <a href="/tags/3D-Math/" style="font-size: 14px; color: #bbb">3D Math</a> <a href="/tags/3D-pipeline/" style="font-size: 16px; color: #c9c9c9">3D pipeline</a> <a href="/tags/Advection/" style="font-size: 14px; color: #bbb">Advection</a> <a href="/tags/Computer-Graphics/" style="font-size: 24px; color: #fff">Computer Graphics</a> <a href="/tags/Fluid-Simulation/" style="font-size: 22px; color: #f1f1f1">Fluid Simulation</a> <a href="/tags/Fluid-simulation/" style="font-size: 14px; color: #bbb">Fluid simulation</a> <a href="/tags/Glow-effect/" style="font-size: 14px; color: #bbb">Glow effect</a> <a href="/tags/Image-processing/" style="font-size: 14px; color: #bbb">Image processing</a> <a href="/tags/N-body/" style="font-size: 14px; color: #bbb">N-body</a> <a href="/tags/Naiver-Stokes-Equations/" style="font-size: 14px; color: #bbb">Naiver-Stokes Equations</a> <a href="/tags/Physical-simulation/" style="font-size: 14px; color: #bbb">Physical simulation</a> <a href="/tags/Physically-Based-Rendering/" style="font-size: 16px; color: #c9c9c9">Physically Based Rendering</a> <a href="/tags/Position-Based-Dynamics/" style="font-size: 18px; color: #d6d6d6">Position Based Dynamics</a> <a href="/tags/Rasterization/" style="font-size: 14px; color: #bbb">Rasterization</a> <a href="/tags/Ray-Tracer/" style="font-size: 22px; color: #f1f1f1">Ray Tracer</a> <a href="/tags/Real-time-Rendering/" style="font-size: 20px; color: #e4e4e4">Real-time Rendering</a> <a href="/tags/Soft-Renderer/" style="font-size: 20px; color: #e4e4e4">Soft Renderer</a> <a href="/tags/Voxelization/" style="font-size: 14px; color: #bbb">Voxelization</a>
    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
	<script>
		var now = new Date(); 
		function createtime() { 
			var grt= new Date("04/24/2019 18:00:00");//在此处修改你的建站时间
			now.setTime(now.getTime()+250); 
			days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
			hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
			if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
			mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
			seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
			snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
			document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
			document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
		} 
	setInterval("createtime()",250);
   </script>
   
   <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->
	
	
	<script>setLoadingBarProgress(80);</script>
</footer>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>









  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>






  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  
    <!--数字雨背景-->
  <canvas id="canvas" width="1440" height="900" ></canvas>
  <script>
	var s = window.screen;
	var width = canvas.width = s.width;
	var height = canvas.height = s.height;
	var fontSize = 13;
	var colunms = Math.floor(width/fontSize);
	var letters = [];
    for(var i=0;i<colunms;i++){
        letters.push(1);
    }
	var draw = function () {
	    canvas.getContext('2d').fillStyle = "rgba(0,0,0,.08)";//遮盖层
		canvas.getContext('2d').fillRect(0,0,width,height);
		canvas.getContext('2d').font = "700 " + fontSize +"px  微软雅黑";
		letters.map(function(y_pos, index){
		text = String.fromCharCode(34+Math.random()*33);
		x_pos = index * fontSize;
		canvas.getContext('2d').fillText(text, x_pos, y_pos);
		letters[index] = (y_pos > 758 + Math.random() * 1e4) ? 0 : y_pos + 10;
		canvas.getContext('2d').fillStyle='#'+letters[index];
	  });
	};
	setInterval(draw, 33);
  </script>
  
  <!-- 页面点击出现文字 -->
  <script type="text/javascript" src="/js/ClickShowText.js"></script>
  
  <script>setLoadingBarProgress(100);</script>
</body>
</html>
