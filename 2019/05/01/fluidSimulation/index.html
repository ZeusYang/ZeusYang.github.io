<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>流体模拟Fluid Simulation：流体模拟基础 | YangWC&#39;s Blog</title>
  
  
  <meta name="description" content="Personal blog website.">
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/logo.ico">
  

  
    <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fdf716664defeee80e01568ddbeb2425";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
  
</head>
<body>
  
  
  <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          YangWC's Blog
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
									<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/" id="home">
									<i class="fas fa-grin fa-fw"></i>&nbsp;博客
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
									<i class="fas fa-tag fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-grin fa-fw"></i>&nbsp;博客
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
								<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
								<i class="fas fa-tag fa-fw"></i>&nbsp;标签
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      <div class="l_main">
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/05/01/fluidSimulation/">
        流体模拟Fluid Simulation：流体模拟基础
      </a>
    </h1>
  


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="https://yangwc.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-05-01</p>
  </a>
</div>

          
        
          
            
  
  <div class="new-meta-item category">
    <a href="/categories/Fluid-Simulation/" rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Computer Graphics&nbsp;/&nbsp;Fluid Simulation</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p>本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。</p>
<a id="more"></a>
<ul>
<li>矢量微积分</li>
<li>Naiver-Stokes偏微分方程组</li>
<li>N-S方程的分步求解</li>
<li>对流算法</li>
</ul>
<h2 id="一、矢量微积分"><a href="#一、矢量微积分" class="headerlink" title="一、矢量微积分"></a>一、矢量微积分</h2><p>&emsp;&emsp;高等数学中太多数讨论的是一维的微积分，而矢量微积分则是一维微积分的高维扩展。矢量微积分的三个基础算子：<strong>梯度</strong>（符号为$∇$），<strong>散度</strong>（符号为$∇\cdot$)，<strong>旋度</strong>（符号为$∇\times$），在此基础上流体力学中经常用到的还有拉普拉斯算子。</p>
<h3 id="1、梯度（Gradient）"><a href="#1、梯度（Gradient）" class="headerlink" title="1、梯度（Gradient）"></a>1、梯度（Gradient）</h3><p>&emsp;&emsp;梯度实际上就是矢量的空间偏导数，且结果依然是一个矢量，$2$维的梯度如下：</p>
<script type="math/tex; mode=display">
∇f(x,y)=(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}) \tag {1.1}</script><p>&emsp;&emsp;依此类推，$3$维的梯度有如下形式：</p>
<script type="math/tex; mode=display">
∇f(x,y,z)=(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y},\frac{\partial f}{\partial z}) \tag {1.2}</script><p>&emsp;&emsp;有时也会采用如下形式来表示梯度：</p>
<script type="math/tex; mode=display">
∇f=\frac{\partial f}{\partial \vec x} \tag {1.3}</script><p>&emsp;&emsp;梯度通常用来近似计算函数值（实际上就是一维形式的推广)：</p>
<script type="math/tex; mode=display">
f(\vec x+\Delta \vec x)\approx f(\vec x)+∇f(\vec x)\cdot \Delta \vec x \tag {1.4}</script><p>&emsp;&emsp;同样的，多个函数的梯度就构成了一个矩阵：</p>
<script type="math/tex; mode=display">
∇\vec F=∇(f,g,h)=\left(   \begin{matrix}
   \frac{\partial f}{\partial x} & \frac{\partial f}{\partial y} & \frac{\partial f}{\partial z} \\
   \frac{\partial g}{\partial x} & \frac{\partial g}{\partial y} & \frac{\partial g}{\partial z} \\
   \frac{\partial h}{\partial x} & \frac{\partial h}{\partial y} & \frac{\partial h}{\partial z} \\
  \end{matrix}  \right)
  =\left( \begin{matrix}∇f\\ ∇g\\ ∇h\\ \end{matrix}  \right) \tag {1.5}</script><h3 id="2、散度（Divergence）"><a href="#2、散度（Divergence）" class="headerlink" title="2、散度（Divergence）"></a>2、散度（Divergence）</h3><p>&emsp;&emsp;散度算子仅仅应用于向量场，它衡量在某一点出相应的矢量聚集或者发散程度，测量方向为<strong>径向</strong>，结果为标量。$2$维、$3$维形式的散度算子如下所示：</p>
<script type="math/tex; mode=display">
∇\cdot \vec u=∇\cdot (u,v)=\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}</script><script type="math/tex; mode=display">
∇\cdot \vec u=∇\cdot (u,v,w)=\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}+\frac{\partial w}{\partial z} \tag {1.6}</script><p>&emsp;&emsp;输入是矢量，而输出为标量。类比梯度，散度符号$∇\cdot \vec u$可以理解为梯度$∇$与矢量$\vec u$的点乘：</p>
<script type="math/tex; mode=display">
∇\cdot \vec u=(\frac{\partial}{\partial x},\frac{\partial}{\partial y},\frac{\partial}{\partial z})\cdot (u,v,w)=\frac{\partial}{\partial x}u+\frac{\partial}{\partial y}v+\frac{\partial}{\partial z}w \tag {1.7}</script><p>&emsp;&emsp;若矢量场散度为$0$，则称该矢量场<strong>无散度</strong>。</p>
<h3 id="3、旋度（Curl）"><a href="#3、旋度（Curl）" class="headerlink" title="3、旋度（Curl）"></a>3、旋度（Curl）</h3><p>&emsp;&emsp;旋度衡量围绕某一点的旋转速度，测量方向为<strong>切向</strong>，三维形式的旋度是一个向量：</p>
<script type="math/tex; mode=display">
∇\times \vec u=∇\times (u,v,w)
=(\frac{\partial w}{\partial y}-\frac{\partial v}{\partial z},
\frac{\partial u}{\partial z}-\frac{\partial w}{\partial x},
\frac{\partial v}{\partial x}-\frac{\partial u}{\partial y}) \tag {1.8}</script><p>&emsp;&emsp;倒推到$2$维，我们取上式中的$w=0$，即矢量场为$(u,v,0)$，$2$维向量场的旋度是一个标量：</p>
<script type="math/tex; mode=display">
∇\times \vec u=∇\times (u,v)=\frac{\partial v}{\partial x}-\frac{\partial u}{\partial y} \tag {1.9}</script><p>&emsp;&emsp;同样地，旋度符号$∇\times \vec u$我们可以理解为梯度$∇$与矢量场$\vec u$的叉乘：</p>
<script type="math/tex; mode=display">
∇\times \vec u=
(\frac{\partial }{\partial x},
\frac{\partial }{\partial y},
\frac{\partial }{\partial z})\times(u,v,w) \tag {1.10}</script><p>&emsp;&emsp;若矢量场旋度为$0$，则称该矢量场<strong>无旋度</strong>。</p>
<h3 id="4、拉普拉斯算子（Laplacian）"><a href="#4、拉普拉斯算子（Laplacian）" class="headerlink" title="4、拉普拉斯算子（Laplacian）"></a>4、拉普拉斯算子（Laplacian）</h3><p>&emsp;&emsp;拉普拉斯算子定义为梯度的散度，符号表示为$∇\cdot∇$，显然$∇\cdot$是散度，而后面的$∇$则为梯度，故拉普拉斯算子即梯度的散度，是一个二阶微分算子。$2$维、$3$维形式分别如下：</p>
<script type="math/tex; mode=display">
∇\cdot∇f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}</script><script type="math/tex; mode=display">
∇\cdot∇f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}+\frac{\partial^2f}{\partial z^2} \tag {1.11}</script><p>&emsp;&emsp;简言之，拉普拉斯算子定义如下：</p>
<script type="math/tex; mode=display">
∇\cdot∇f=\Sigma_{i=1}^n\frac{\partial^2f}{\partial x_i^2} \tag {1.12}</script><p>&emsp;&emsp;偏微分方程$∇\cdot ∇f=0$被称为拉普拉斯方程；而如果右边为某个非$0$常数，即$∇\cdot ∇f=q$，我们称之为泊松方程。更一般地，如果梯度再乘上一个标量$a$（如$1/\rho$)，即$∇\cdot (a∇f)=q$，我们依旧称之为泊松问题。</p>
<h2 id="二、-Naiver-Stokes-偏微分方程组"><a href="#二、-Naiver-Stokes-偏微分方程组" class="headerlink" title="二、$Naiver-Stokes$偏微分方程组"></a>二、$Naiver-Stokes$偏微分方程组</h2><p>&emsp;&emsp;流体模拟器的构建主要围绕著名的不可压缩$Navier-Stokes$方程展开，它是一个流体力学领域的偏微分方程，方程形式如下：</p>
<script type="math/tex; mode=display">
\frac{\partial \vec u}{\partial t}+\vec u\cdot ∇\vec u+\frac1\rho∇p=\vec g+\nu∇\cdot∇\vec u \tag {2.1}</script><script type="math/tex; mode=display">
∇\cdot\vec u=0 \tag {2.2}</script><p>&emsp;&emsp;这个方程组看起非常地复杂，接下来我们就把它剖析成一个个比较简单的部分来理解。</p>
<h3 id="1、符号标记"><a href="#1、符号标记" class="headerlink" title="1、符号标记"></a>1、符号标记</h3><p>&emsp;&emsp;我们有必要定义一些物理量的符号用以标记：</p>
<p>&emsp;&emsp;符号$\vec u$在流体力学中通常表示为流体的速度矢量，记$3$维的速度矢量$\vec u=(u,v,w)$；</p>
<p>&emsp;&emsp;希腊字符$\rho$是流体的密度，对于水，该值大约为$1000kg/m^3$，而空气则大约为$1.3kg/m^3$；</p>
<p>&emsp;&emsp;字符$p$代表压力，流体对任何物体施加的单位面积力；</p>
<p>&emsp;&emsp;字符$\vec g$则是我们熟悉的重力加速度，通常取$(0,-9.81,0)m/s^2$。我们约定$y$轴向上，而$x$轴和$z$轴在水平面上。另外补充一点，我们把其他的一些类似的力都累加到$\vec g$上，也就是我们统一用$\vec g$表示所有类似力之和，这类力我们称之为<strong>体积力</strong>（称之为体积力是因为它们的力是作用到整个流体而不只是流体的表面）；</p>
<p>&emsp;&emsp;希腊字符$\nu$是流体的运动粘度，它衡量流体的黏滞性。糖蜜之类的流体有非常高的粘度，而像酒精之类的流体有很低的粘度；</p>
<p>&emsp;&emsp;其它一些矢量微积分的符号算子前面已经提到过，不再赘述。</p>
<h3 id="2、动量方程"><a href="#2、动量方程" class="headerlink" title="2、动量方程"></a>2、动量方程</h3><p>&emsp;&emsp;偏微分方程$(2.1)$我们称之为<strong>动量方程</strong>，它本质上就是我们熟悉的牛顿定律$\vec F=m\vec a$的形式，描述了施加在流体上的力是如何影响流体的运动。</p>
<p>&emsp;&emsp;假设我们用粒子系统来模拟流体，每个粒子代表流体的一小滴，每个粒子有各自的质量$m$、体积$V$和速度$\vec u$。为了让整个粒子系统运作起来，我们必须弄清楚每个粒子所承受的力的作用。牛顿第二定律告诉我们：$\vec F=m\vec a$，而根据加速度定义，我们有：</p>
<script type="math/tex; mode=display">
\vec a=\frac{D\vec u}{Dt} \tag {2.3}</script><p>&emsp;&emsp;符号$D$是指<strong>物质导数</strong>，所谓物质导数，就是对流体质点求导数，而且是针对流体质点（在这里就是流体粒子）而不是空间的固定点。因而牛顿第二定律就变成：</p>
<script type="math/tex; mode=display">
m\frac{D\vec u}{Dt}=\vec F \tag {2.4}</script><p>&emsp;&emsp;那么流体粒子承受的力有哪些呢？一个最简单的力就是重力：$m\vec g$。而其他的流体质点（或其他流体粒子）也会对当前的流体粒子产生作用力。流体内部的相互作用力之一便是压力，较大压力的区域会向较低压力区域产生作用力。值得注意的是，我们只关注施加在粒子上的压力的净合力。例如，若施加在粒子上压力在每个方向上都相等，那么它的压力的合力便为0。我们用压力的负梯度（取负是因为方向是由压力大的区域指向压力小的区域）来衡量在当前流体粒子处压力的不平衡性，即取$-∇p$。那么流体粒子所承受的压力就是对$-∇p$在整个流体粒子的体积上进行积分，为了简化，我们简单地将$V$与$-∇p$相乘，故粒子压力部分为$-V∇p$。</p>
<p>&emsp;&emsp;其他的流体相互作用力则是由流体的黏性产生的，我们直观地把这种力理解为尽可能使得粒子以周围区域的平均速度移动的力，也就是使得粒子的速度与周围区域粒子速度的差距最小化。拉普拉斯算子是衡量一个量与之周围区域该量平均值之差的算符，因而$∇\cdot∇\vec u$是当前粒子速度矢量与周围区域平均速度矢量之差。为了计算粘滞力，我们同样对$∇\cdot∇\vec u$在整个粒子体积$V$上进行积分，与前面类似，我们简单取$V∇\cdot∇\vec u$。除此之外，我们还引进一个称为动力粘度系数的物理量，符号为$\mu$。因而粘滞力为$V\mu∇\cdot∇\vec u$。</p>
<p>&emsp;&emsp;把重力、压力和粘滞力综合一起，我们可得：</p>
<script type="math/tex; mode=display">
m\frac{D\vec u}{Dt}=\vec F=m\vec g-V∇p+V\mu∇\cdot∇\vec u \tag {2.5}</script><p>&emsp;&emsp;当粒子系统中的粒子数量趋于无穷大，而每个粒子大小趋于$0$时，会产生一个问题：此时每个粒子的质量$m$和体积$V$变为$0$，此时上式变得没有意义。为此，我们把$(2.5)$式调整一下，两边同除以体积$V$，又因$\rho=m/V$，故有：</p>
<script type="math/tex; mode=display">
\rho\frac{D\vec u}{Dt}=\rho\vec g-∇p+\mu∇\cdot∇\vec u \tag {2.6}</script><p>&emsp;&emsp;两边同除以$\rho$，移项调整：</p>
<script type="math/tex; mode=display">
\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g+\frac\mu\rho∇\cdot∇\vec u \tag {2.7}</script><p>&emsp;&emsp;为了进一步简化，定义运动粘度为$\nu=\mu/\rho$，式$(2.7)$变为：</p>
<script type="math/tex; mode=display">
\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g+\nu∇\cdot∇\vec u \tag {2.8}</script><p>&emsp;&emsp;我们已经快把动量方程推导出来，现在我们要把物质导数$\frac{D\vec u}{Dt}$弄清楚，为此，我们需要了解两种描述方法：<strong>拉格朗日描述</strong>和<strong>欧拉描述</strong>。</p>
<h3 id="3、拉格朗日描述与欧拉描述"><a href="#3、拉格朗日描述与欧拉描述" class="headerlink" title="3、拉格朗日描述与欧拉描述"></a>3、拉格朗日描述与欧拉描述</h3><p>&emsp;&emsp;当我们尝试研究流体或可变形固体的运动的时候，通常有两种方法来描述：<strong>拉格朗日描述</strong>（ Lagrangian viewpoint）、<strong>欧拉描述</strong>（Eulerian viewpoint）。</p>
<p>&emsp;&emsp;拉格朗日描述方法是我们比较熟悉的方法，这种描述方法把物体看成是由类似于粒子系统的形式组成，固体或流体的每个点看作一个独立的粒子，粒子有各自相应的位置$\vec x$和速度$\vec u$。我们可以把粒子理解为组成物体的分子。对于我们通常采用拉格朗日描述法进行建模模拟，即用一系列离散的粒子集来构建，粒子之间通过网格相联系。</p>
<p>&emsp;&emsp;欧拉描述方法则采用了完全不同的角度，它常被用于流体力学中。与拉格朗日描述追踪每个物体粒子的方法不同，欧拉描述关注点是空间中的一个固定点，并考察在这个固定点上流体性质（如密度、速度、温度等）是如何随着时间变化的。流体流动经过这个固定点可能会导致这个固定点的物理性质发生一些变化（如一个温度较高的流体粒子流经这个固定点，后面紧跟着一个温度较低的流体粒子流过固定点，那么这个固定点的温度会降低，但是并没有任何一个流体粒子的温度发生了变化）。</p>
<p>&emsp;&emsp;用天气测量举个简单的例子：拉格朗日描述方法就是你乘坐在一个随风而飘的热气球上，测量周围空气的压力、密度和浑浊度等天气指标；而欧拉描述方法就是你固定在地面上，测量流过的空气的天气指标。</p>
<p>&emsp;&emsp;欧拉描述法似乎看起来带来了一些不必要的复杂度，但是目前大多数的流体模拟器都是基于欧拉描述法，这是因为欧拉描述法相比于拉格朗日描述法有一些不可比拟的优点：欧拉描述法能够更加方便地计算一些物理量的空间导数（例如压力梯度和粘度）；而如果用粒子方法的话（即拉格朗日描述法），那么计算物理量相对于空间位置的变化是比较难的。</p>
<p>&emsp;&emsp;把拉格朗日描述法和欧拉描述法联系起来的关键点就是物质导数。首先从拉格朗日描述法出发，假设有一群粒子，每个粒子都有各自的位置$\vec x$和速度$\vec u$。记$q$为通用的物理量（如密度、速度和温度等），每个粒子有其对应的$q$值。方程$q(t,\vec x)$描述在时间点$t$而位置为$\vec x$的粒子对应的物理量值$q$。则一个粒子的物理量$q$随时间$t$的变化率是多少？这是一个拉格朗日描述角度下的问题，我们取对时间$t$的导数（注意用到了求导链式法则，以及$\frac{\partial q}{\partial \vec x}=∇q$和$\vec u=\frac{d\vec x}{dt}）$：</p>
<script type="math/tex; mode=display">
\frac d{dt}q(t,\vec x)=\frac{\partial q}{\partial t}+∇q\cdot\frac{d\vec x}{dt}=\frac{\partial q}{\partial t}+∇q\cdot\vec u\equiv\frac{Dq}{Dt} \tag {2.9}</script><p>&emsp;&emsp;这就是物质导数。把式$(2.9)$代入式$(2.8)$我们就得到了流体动量方程$(2.1)$。物质导数针对的是流体质点（在这里就是流体粒子）而不是空间的固定点。式$(2.9)$写完整一点就是：</p>
<script type="math/tex; mode=display">
\frac{Dq}{Dt}=\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}+v\frac{\partial q}{\partial y}+w\frac{\partial q}{\partial z} \tag {2.10}</script><p>&emsp;&emsp;对于给定的速度场$\vec u$， 流体的物理性质如何在这个速度场$\vec u$下变化的计算我们称之为<strong>对流</strong>（advection）。一个最简单的对流方程，就是其物理量的物质导数为$0$，如下所示：</p>
<script type="math/tex; mode=display">
\frac{Dq}{Dt}=0\implies\frac{\partial q}{\partial t}+\vec u\cdot ∇q = 0 \tag {2.11}</script><p>&emsp;&emsp;公式$(2.11)$的意义即在拉格朗日视角观察下，每个流体粒子的物理量保持不变。</p>
<h3 id="4、不可压缩性"><a href="#4、不可压缩性" class="headerlink" title="4、不可压缩性"></a>4、不可压缩性</h3><p>&emsp;&emsp;关于流体的压缩性在此不做过多的物理细节描述，只需知道一点：通常情况下流体的体积变化非常小（除开一些极端的情况，而且这些极端情况我们日常生活中较少出现）。可压缩流体的模拟涉及到非常复杂的情况，往往需要昂贵的计算资源开销，为此在计算机流体模拟中我们通常把所有的流体当作是不可压缩的，即它们的体积不会发生变化。</p>
<p>&emsp;&emsp;任取流体的一部分，设其体积为$\Omega$而其边界闭合曲面为$\partial\Omega$，我们可以通过围绕边界曲面$\partial\Omega$对流体速度$\vec  u$在曲面法线方向上的分量进行积分来衡量这块部分流体的体积变化速率：</p>
<script type="math/tex; mode=display">
\frac d{dt}Volume(\Omega)=\int\int_{\partial\Omega}\vec u\cdot n \tag{2.12}</script><p>&emsp;&emsp;对于不可压缩的流体，其体积保持为某个常量，故其体积变化速率为$0$：</p>
<script type="math/tex; mode=display">
\int\int_{\partial\Omega}\vec u\cdot n=0 \tag {2.13}</script><p>&emsp;&emsp;由高斯散度定理，我们可以把式$(2.13)$转换为体积分：</p>
<script type="math/tex; mode=display">
\int\int_{\partial\Omega}\vec u\cdot n=\int\int\int_\Omega∇\cdot \vec u=0 \tag{2.14}</script><p>&emsp;&emsp;式$(13)$应该对任意的$\Omega$成立，意即无论$\Omega$取何值，积分值均为$0$。这种情况下只有令积分函数值取$0$方可成立，即对$0$积分无论$\Omega$取何值结果均为$0$。所以有：</p>
<script type="math/tex; mode=display">
∇\cdot \vec u=0 \tag{2.15}</script><p>&emsp;&emsp;这就是$Navier-Stokes$方程中的不可压缩条件$(2.2)$。满足不可压缩条件的速度场被称为是<strong>无散度</strong>的，即在该速度场下流体体积既不膨胀也不坍缩，而是保持在一个常量。模拟不可压缩流体的关键部分就是使得流体的速度场保持无散度的状态，这也是流体内部压力的来源。</p>
<p>&emsp;&emsp;为了把压力与速度场的散度联系起来，我们在动量方程$(2.1)$两边同时取散度：</p>
<script type="math/tex; mode=display">
∇\cdot\frac{\partial \vec u}{\partial t}+∇\cdot(\vec u\cdot ∇\vec u)+∇\cdot\frac1\rho∇p=∇\cdot(\vec g+\nu∇\cdot∇\vec u) \tag {2.16}</script><p>&emsp;&emsp;对于上式$(2.16)$第一项，我们转变一下求导次序：</p>
<script type="math/tex; mode=display">
\frac {\partial}{\partial t}∇\cdot\vec u \tag {2.17}</script><p>&emsp;&emsp;如果满足流体不可压缩条件，那么式$(2.17)$取值$0$（因为无散度），然后我们调整一下式$(2.16)$可得关于压力的方程：</p>
<script type="math/tex; mode=display">
∇\cdot\frac1\rho∇p=∇\cdot(-\vec u\cdot ∇\vec u+\vec g+\nu∇\cdot∇\vec u) \tag{2.18}</script><h3 id="5、丢弃粘度项"><a href="#5、丢弃粘度项" class="headerlink" title="5、丢弃粘度项"></a>5、丢弃粘度项</h3><p>&emsp;&emsp;在某些流体如蜂蜜、小水珠等的模拟中，粘滞力起着非常重要的作用。但是在大多数流体动画模拟中，粘滞力的影响微乎其微，为此秉持着方程组越简单越好的原则，我们常常丢弃粘度项。当然这也不可避免地带来一些误差，事实上，在计算流体力学中尽可能地减少丢弃粘度项带来的误差是一个非常大的挑战。下面的叙述都是基于丢弃粘度项的前提。</p>
<p>&emsp;&emsp;丢弃了粘度项的$Navier-Stokes$方程被称为<strong>欧拉方程</strong>，而这种理想的流体则是<strong>无粘度</strong>的。丢弃了粘度项的欧拉方程如下：</p>
<script type="math/tex; mode=display">
\frac{D\vec u}{Dt}+\frac1\rho∇p=\vec g \tag {2.19}</script><script type="math/tex; mode=display">
∇\cdot\vec u=0 \tag{2.20}</script><p>&emsp;&emsp;<strong>大多数的流体模拟的计算方程都是欧拉方程。</strong></p>
<h3 id="6、边界条件"><a href="#6、边界条件" class="headerlink" title="6、边界条件"></a>6、边界条件</h3><p>&emsp;&emsp;目前为止我们讨论的都是流体内部的情况，然而边界部分也是流体模拟非常关键的部分。在流体模拟中我们仅仅关注两种边界条件：<strong>固体墙</strong>（solid walls）、<strong>自由面</strong>（free surfaces）。</p>
<p>&emsp;&emsp;<strong>固体墙</strong>顾名思义就是流体与固体接触的边界，用速度来描述很简单：流体既不会流进固体内部也不会从固体内部流出，因此流体在固体墙法线方向上的分量为$0$：</p>
<script type="math/tex; mode=display">
\vec u\cdot n=0 \tag {2.21}</script><p>&emsp;&emsp;当然，上述是固体自身不移动的情况下。通常来说，流体速度在法线方向上的分量与固体的移动速度在法线方向上的分量应该保持一致：</p>
<script type="math/tex; mode=display">
\vec u\cdot n=\vec u_{solid}\cdot n \tag{2.22}</script><p>&emsp;&emsp;上述的两个公式都是仅对流体速度在法线方向上的分量做了限制，对于无粘度的流体，切线方向上的流体速度与固体的移动速度无必然的联系。</p>
<p>&emsp;&emsp;<strong>自由面</strong>是另外一个非常重要的边界条件，它通常就是与另外一种流体相接壤的边界部分。例如在模拟水花四溅时，水流表面不与固体接触的都是自由面（如与空气这种流体接触）。因空气密度远小于水导致空气对水体的仿真影响非常小，为了简化模拟，我们将空气所占的空间设为某个固定大气压的区域，设为$0$是最方便的方案，此时自由面就是压强$p=0$的水体表面。</p>
<p>&emsp;&emsp;在小规模的流体仿真中，自由面的表面张力占据着非常重要的地位。在微观分子层面下，表面张力的存在是因为不同的分子相互吸引产生的力。从几何的角度来解释就是，表面张力就是促使流体的表面积尽可能小的一种力。物理学上，两种不同的流体之间实际上存在着与表面平均曲率成正比的压力骤变：</p>
<script type="math/tex; mode=display">
[p]=\lambda k. \tag {2.23}</script><p>&emsp;&emsp;公式$(2.23)$中的$[p]$记为压力之差。$\lambda$是表面张力系数，可以根据模拟的流体类型查找对应的张力系数（例如空气与水在室温下张力系数为$\lambda \approx 0.073N/m$）。而$k$就是平均曲率，单位为$m^{-1}$。又因为我们常常设空气的压力为$0$，因此水与空气交界的自由面的压力为：</p>
<script type="math/tex; mode=display">
p=\lambda k \tag {2.24}</script><p>​        </p>
<h2 id="三、N-S方程的分步求解"><a href="#三、N-S方程的分步求解" class="headerlink" title="三、N-S方程的分步求解"></a>三、N-S方程的分步求解</h2><p>&emsp;&emsp;有了对以上对$Navier-Stokes$方程的理论支撑，接下来我们就要如何用计算机来对该组偏微分方程进行离散化求解。为了程序的松耦合性以及使计算尽可能地高效、简单，在流体模型领域，我们将流体方程分成几个独立的步骤，然后按顺序先后推进。对于不可压缩的无粘度流体方程（即前面的欧拉方程$(2.19)$和$(2.20)$，我们将其离散化成对流项（advection）如公式$(3.1)$、体积力项（body force）如公式$(3.2)$、压力/不可压缩项如公式$(3.3)$：</p>
<script type="math/tex; mode=display">
\frac{Dq}{Dt}=0 \tag {3.1}</script><script type="math/tex; mode=display">
\frac{\partial \vec u}{\partial t}=\vec g \tag {3.2}</script><script type="math/tex; mode=display">
\begin{cases}
\frac{\partial \vec u}{\partial t}+\frac{1}{\rho}∇p=0\\
∇\cdot\vec u=0
\end{cases} \tag {3.3}</script><p>&emsp;&emsp;需要注意的是，在对流项公式$(3.1)$中我们用了一个通用量的符号$q$是因为我们不仅仅要对流体的速度进行对流，还需要对其他物理量进行对流。我们记对流项公式$(3.1)$的对流计算算法为$advect(\vec u, \Delta t, q)$，即对于给定的时间步长$\Delta t$和速度场$\vec u$，对物理量q进行对流。</p>
<p>&emsp;&emsp;对于体积力项$(3.2)$，我们采用简单的前向欧拉法即可：$\vec u \leftarrow \vec u + g\Delta t$。</p>
<p>&emsp;&emsp;对于压力/不可压缩项$(3.3)$，我们用一个称为$project(\Delta t, \vec u)$的算法，通过$project(\Delta t, \vec u)$计算出正确的压力以确保速度场$\vec u$的无散度性质。欧拉方案不会着重研究具体粒子间的作用力，因而不会正向去求解$\frac{1}{\rho}∇p$，它是利用流体不可压缩的特性，将速度场$\vec u$投影到散度为$0$的空间上，间接地解算了压力项。这种思想相当于，已知一个中间量$\vec u_{temp}$，对这个中间量的唯一一个操作（如正向求解压力$\frac{1}{\rho}∇p$）不可行，但是直到最终量$\vec u_{fianl}$符号的一个性质（散度为$0$），于是只要将$\vec u_{temp}$投影到符合散度为$0$的特性平面上，即可间接地还原正向求解压力的操作，得到最终的速度场$\vec u_{temp}$。</p>
<p>&emsp;&emsp;对流项$advect(\vec u, \Delta t, q)$的输入速度场$\vec u$要确保为无散度的状态，投影项$project(\Delta t, \vec u)$确保了流体体积保持不变，因而投影项输出的速度场必然是无散度的。所以我们只要确保投影项$project(\Delta t, \vec u)$输出的速度场$\vec u$作为对流项$advect(\vec u, \Delta t, q)$的输入即可，这时我们的分步求解流体方程的优势就体现出来了，其伪代码如下所示。</p>
<hr>
<p><strong>算法1 Fluid Simulation($\vec u_n$, $\Delta t$):</strong></p>
<hr>
<p><strong>1:  初始化速度场$\vec u_n$,使得$\vec u_n$无散度 </strong></p>
<p><strong>2:  对于每个时间步$n = 0,1,2,…$</strong></p>
<p><strong>3: &emsp;&emsp;决定一个合理的时间步长$\Delta t = t_{n+1}-t_n$ </strong></p>
<p><strong>4: &emsp;&emsp;对流项计算$\vec u_A=advect(\vec u_n,\Delta t,\vec q)$ </strong></p>
<p><strong>5: &emsp;&emsp;体积力项计算$\vec u_B=\vec u_A+\Delta t\vec g$</strong></p>
<p><strong>6:  &emsp;&emsp;无散度投影$\vec u_{n+1}=project(\Delta t,\vec u_B)$ </strong></p>
<hr>
<h3 id="1、时间步长"><a href="#1、时间步长" class="headerlink" title="1、时间步长"></a>1、时间步长</h3><p>&emsp;&emsp;在流体模拟算法中，确定适当的时间步长是算法的第一步。因为计算流体模拟的最后结果是呈现在屏幕上的，所以$\Delta t$的选取与屏幕的刷新率有重要的关系。若选取的$\Delta t$有$t_n+\Delta t &gt; t_{frame}$，那么必须做一个截断使$\Delta t=t_{frame}-t_n$。此外，流体模拟的三个步骤即对流项、体积力项、无散度投影项对时间步长$\Delta t$的要求不尽相同，要选择一个满足所有要求的最小时间步长能确保计算的收敛性。此外，一方面为了流体模拟的真实性，我们可能需要选取一个足够小的时间步长来复现流体的高质量细节。另一方面，有时高性能的需求又使得我们不能选取太小的时间步长去渲染一帧。假设一帧至少要进行三个时间步的模拟，那么$\Delta t$应该至少设成帧间隔时间的三分之一。</p>
<h3 id="2、网格结构"><a href="#2、网格结构" class="headerlink" title="2、网格结构"></a>2、网格结构</h3><p>&emsp;&emsp;欧拉法的整个流程都是基于网格的，所以合理的网格结构是算法高效的关键点。$Harlow$和$Welch$提出了一种经典的$MAC$（marker and cell）网格结构，许多不可压缩流体模拟的算法都在这个网格结构上呈现出了良好的效率。$MAC$网格是一种交叉排列的网格，不同类型的物理量被存储于网格的不同位置。以二维的网格为例，如图3-1左图所示，流体粒子的压力数据存储于网格的中心点$P_{i,j}$，而速度则沿着笛卡尔坐标被分成了两部分。水平方向的$u$成分被存储在了网格单元竖直边的中心处，例如网格单元$(i,j)$和$(i+1,j)$之间的水平速度记为$u_{i+1/2,j}$。垂直方向的$v$成分则被存储在了网格单元水平面的中心上。这样的存储方案十分有利于估算流体流进/流出某个网格单元的量。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.26/blog/FluidSimulation/1.jpg" width="50%"></div></p>
<center>图3-1 MAC网格,左图二维,右图三维</center>

<p>&emsp;&emsp;扩展到三维的情况，$MAC$网格同样是交错排列的结构网格，如图3-1右图所示。压力数值存储在立方体网格单元的中心，三个速度分量分别被记录在立方体网格单元的三个表面的中心点上。在数值计算时，这样的分配方式使得我们可以准确地采用中心差分法计算压力梯度和速度的散度，同时克服了中心差分法的一个普遍的缺点。一维的情况为例，在网格顶点位置$…,q_{i-1},q_i,q_{i+1}…$上估算量场$q$的导数，为了无偏（所谓无偏，就是不偏向左边或者右边）估计网格顶点$i$处的$\frac{\partial q}{\partial x}$，一种比较自然的方式就是采用一阶中心差分法：</p>
<script type="math/tex; mode=display">
(\frac{\partial q}{\partial x})_i\approx \frac{q_{i+1}-q_{i-1}}{2\Delta x} \tag {3.4}</script><p>&emsp;&emsp;公式$(3.4)$是无偏的，且精确度为$O(\Delta x^2)$。而前向欧拉差分法偏向右边且精确度只有$O(\Delta x)$：</p>
<script type="math/tex; mode=display">
(\frac{\partial q}{\partial x})_i\approx \frac{q_{i+1}-q_i}{\Delta x} \tag {3.5}</script><p>&emsp;&emsp;然而，公式$(3.4)$存在着一个非常严重的问题：网格点$i$的估算导数完全忽略了$q_i$的值。数学上，只有常数函数的一阶导数为零。但是公式$(3.4)$遇到了锯齿函数如$q_i=(-1)^i$时，它错误地将该类函数的导数估算为$0$，这种问题被称为零空间问题（null-space problem）。</p>
<p>&emsp;&emsp;交叉错排的$MAC$网格完美地克服了中心差分法的零空间问题，同时也保持了它的无偏二阶精度。在$MAC$网格上运用中心差分法，网格点$i$处的估算导数公式如下所示：</p>
<script type="math/tex; mode=display">
(\frac{\partial q}{\partial x})_i\approx\frac{q_{i+1/2}-q_{i-1/2}}{\Delta x} \tag {3.6}</script><p>&emsp;&emsp;$MAC$网格确实给流体的压力计算和不可压缩性的处理带来了很大的便利，但与此同时也带来了一些其他方面的麻烦。如果我们要估算某个地方的速度向量，即便采样点恰好在网格点上我们也要做一些插值才能获取相应的速度向量。在网格点处，我们通常采用平均法，以二维为例：</p>
<script type="math/tex; mode=display">
\vec u_{i,j}=(\frac{u_{i-1/2,j}+u_{i+1/2,j}}{2},\frac{v_{i,j-1/2}+v_{i,j+1/2}}{2}),\\
\vec u_{i+1/2,j}=(u_{i+1/2,j},\frac{v_{i,j-1/2}+v_{i,j+1/2}+v_{i+1,j-1/2}+v_{i+1,j+1/2}}{4}),\\
\vec u_{i,j+1/2}=(\frac{u_{i-1/2,j}+u_{i+1/2,j}+u_{i-1/2,j+1}+u_{i+1/2,j+1}}{4},v_{i,j+1/2}).\tag {3.7}</script><p>&emsp;&emsp;最后，在实现中下标索引一般没有浮点数之说，前面直接采用$i+1/2$的记法是为了便于叙述。一般约定如下：</p>
<script type="math/tex; mode=display">
p(i,j,k)=p_{i,j,k},\\
u(i,j,k)=u_{i-1/2,j,k},\\
v(i,j,k)=v_{i,j-1/2,k},\\
w(i,j,k)=w_{i,j,k-1/2}. \tag{3.8}</script><p>&emsp;&emsp;因而对于$nx\times ny\times nz$分辨率的网格，压力数值存储在$nx\times ny\times nz$的数组中，速度的$u$成分存储在$(nx+1)\times ny\times nz$数组中，速度的$v$成分存储在$nx\times (ny+1)\times nz$数组中，速度的$w$成分存储在$nx\times ny\times (nz+1)$数组中。</p>
<h2 id="四、对流算法"><a href="#四、对流算法" class="headerlink" title="四、对流算法"></a>四、对流算法</h2><p>&emsp;&emsp;求解如下所示的对流方程是流体模拟的关键一步：</p>
<script type="math/tex; mode=display">
\frac{Dq}{Dt}=0 \tag {4.1}</script><p>&emsp;&emsp;我们把这个对流数值计算的算法记为：</p>
<script type="math/tex; mode=display">
q^{n+1}=advect(\vec u,\Delta t,q^n) \tag {4.2}</script><p>&emsp;&emsp;公式$(4.2)$中的各个符号含义：</p>
<p>&emsp;&emsp;$\vec u$：在$MAC$网格上的离散化的速度场；</p>
<p>&emsp;&emsp;$\Delta t$：时间步长；</p>
<p>&emsp;&emsp;$q^n$：当前的物理量场$q$（如流体密度、速度、燃烧物浓度等）；</p>
<p>&emsp;&emsp;$q^{n+1}$：经过对流后得到的新的量场。</p>
<p>&emsp;&emsp;在这里要特别注意，输入对流算法的速度场$\vec u$必须是无散度的，否则模拟结果会出现一些奇怪的失真现象。</p>
<h3 id="1、半拉格朗日对流算法（Semi-Lagrangian-Advection）"><a href="#1、半拉格朗日对流算法（Semi-Lagrangian-Advection）" class="headerlink" title="1、半拉格朗日对流算法（Semi-Lagrangian Advection）"></a>1、半拉格朗日对流算法（Semi-Lagrangian Advection）</h3><p>&emsp;&emsp;一维情况下，对流方程$(4.1)$写成偏微分的形式如下：</p>
<script type="math/tex; mode=display">
\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=0 \tag {4.3}</script><p>&emsp;&emsp;分别采用前向欧拉差分法计算对时间的偏导和中心差分法计算对空间的偏导，我们有：</p>
<script type="math/tex; mode=display">
\frac{q^{n+1}_{i}-q^n_i}{\Delta t}+u^n_i\frac{q^n_{i+1}-q^n_{i-1}}{2\Delta x}=0 \tag {4.4}</script><p>&emsp;&emsp;转成以$q^{n+1}_i$为计算目标的显式公式，得：</p>
<script type="math/tex; mode=display">
q^{n+1}_i=q^n_i-\Delta t u^n_i\frac{q^n_{i+1}-q^n_{i-1}}{2\Delta x} \tag {4.5}</script><p>&emsp;&emsp;公式$(4.5)$看起来没什么问题，但是却存在非常严重的漏洞。首先，前向欧拉法被证明是无条件不稳定的空间离散方法：无论取多么小Δ𝑡，随着时间步的推进，累积误差终将发散。即使使用更稳定的时间积分方法来取代前向欧拉方法，解决了时间上的PDE（Partial Differential Equation，偏微分方程）计算，空间上的PDE计算还是会带来重大的麻烦。标准中心差分方法不可避免地会出现的零空间问题，具有高频震荡性质的速度场对空间的导数被错误地计算为$0$或几乎为$0$，低离速度分量被分离出来，从而导致模拟效果中出现许多奇怪的高频摆动和震荡。</p>
<p>&emsp;&emsp;针对这些问题，研究者们提出了一个解然不同的、更加简单和更具物理直观意义的半拉格朗日法。之所以叫半拉格朗日法，是因为这种方法是以拉格朗日视角去解决欧拉视角的对流方程（“半”字的由来）。假设我们的目标是求解网格点$\vec x_G$的在第$n+1$个时间步时关于物理量$q$的新值，记为$q^{n+1}_G$。在拉格朗日的视角下，我们可以寻找在第$n+1$时间步之前，是空间中的哪一个点上的流体粒子在速度场$\vec u$的作用下“流向”了$\vec x_G$，我们记这个粒子在第$n$个时间步时的网格位置为$\vec x_P$，则第$n+1$个时间步时$\vec x_G$的$q^{n+1}_G$即为第$n$个时间步时$\vec x_P$的$q^{n}_P$。如下图4-1为半拉格朗日对流法的示意图。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.26/blog/FluidSimulation/2.png" width="30%"></div></p>
<p><center>图4-1 半拉格朗日对流法</center><br>&emsp;&emsp;半拉格朗日对流法的第一步就是要找出$\vec x_P$，为此我们根据$\vec x_G$做反向的追踪。粒子位置对时间的导数就是速度场：</p>
<script type="math/tex; mode=display">
\frac{d\vec x}{dt}=\vec u(\vec x) \tag {4.6}</script><p>&emsp;&emsp;经过一个时间步长$\Delta t$之后，粒子由$\vec x_P$移动到$\vec x_G$。为了得到$\vec x_P$，最简单的方法就是采用前向欧拉法进行倒推：</p>
<script type="math/tex; mode=display">
\vec x_P=\vec x_G-\Delta t\vec u(\vec x_G) \tag {4.7}</script><p>&emsp;&emsp;然而前向欧拉法只有一阶的精度，若在不改变$\Delta t$的情况下提高精度，我们可以采用高阶的龙格库塔法（Runge-Kutta method）。采用二阶的龙格库塔法如下所示：</p>
<script type="math/tex; mode=display">
\vec x_{mid}=\vec x_G-\frac12\Delta t\vec u(\vec x_G),\\
\vec x_P=\vec x_G-\Delta t\vec u(\vec x_{mid}). \tag {4.7}</script><p>&emsp;&emsp;倒推得到$\Delta  t$之前的网格位置$\vec x_P$一般不会恰好在网格顶点上，为此我们需要做些插值。三维模拟通常采用三线性插值，而二维的则采用双线性插值。</p>
<script type="math/tex; mode=display">
q^{n+1}_G=interpolate(q_n,\vec x_P) \tag {4.8}</script><h3 id="2、边界情况"><a href="#2、边界情况" class="headerlink" title="2、边界情况"></a>2、边界情况</h3><p>&emsp;&emsp;若我们倒推得到的$\vec x_P$仍然在流体的内部，那么做插值是完全没问题的。但若$\vec x_P$在流体的边界之外呢？这种情况的出现的原因通常有两个：一个是$\vec x_P$确确实实在流体的外部且即将流入流体内部，另一个是由前向欧拉法或龙格库塔法的数值计算方法带来的误差导致。</p>
<p>&emsp;&emsp;在一种情况下，我们应该知道当流体流入时其携带的物理量，此时我们将这个外部流入的物理量作为返回值即可。例如，第$n$个时间步时的外部流体以速度$\vec U$和温度$T$在第$n+1$个时间步时注入流体内部$\vec x_G$的位置，那么$\vec T^{n+1}_G$的值就为$T$。</p>
<p>&emsp;&emsp;在第二种由误差导致的情况下，一个适当的策略就是根据边界上的最近点外推出所求得物理量。在模拟某些流体时，外推变得很简单。例如，在模拟烟雾时我们简单地假设烟雾流体外部即空气的速度风场为某个常数$\vec U$（可能为$0$），这样边界上的速度场都取$\vec U$。但还有一些必须根据流体内部的已知量外推出未知量，这时情况就变得比较复杂了。具体如何外推将在后面介绍，目前我们只需要知道大概的步骤：首先寻找边界上的最近点，然后在最近点的领域内插值获取相应的物理量场。</p>
<h3 id="3、时间步长大小"><a href="#3、时间步长大小" class="headerlink" title="3、时间步长大小"></a>3、时间步长大小</h3><p>&emsp;&emsp;对任何一种数值计算方法的主要的考虑点就是它是否稳定。幸运的是，<strong>半拉格朗日对流法已经被证明是一种无条件稳定的算法</strong>：无论$\Delta t$取多大，它永远不会出现数值爆炸的现象。因为每一个新值$q$的确定，都是通过对旧值得插值，无论是线性插值、双线性插值还是三线性插值，$q$的大小都是处于插值点之间，不会得到比原来插值点更大或者更小的值，因而$q$是有上下界的。这使得我们可以尽情地根据所需的模拟质量和模拟效率去调整时间步长。</p>
<p>&emsp;&emsp;但是在实践中，时间步长的大小也不能选得太过极端，否则会产生一些奇观的现象。Foster和Fekiw提出了一个对$\Delta t$的限制：流体粒子在$\Delta t$内的倒推轨迹最多经过某个常数个网格单元为宜，例如5个：</p>
<script type="math/tex; mode=display">
\Delta t \leq \frac{5\Delta x}{u_{max}} \tag {4.9}</script><p>&emsp;&emsp;公式$(4.9)$中，$u_{max}$是速度场的最大值，我们可以简单地取 存储在网格中的最大速度值。一个更鲁棒的方法考虑了体积力（如重力、浮力等）对最大速度的影响：</p>
<script type="math/tex; mode=display">
u_{max}=max(|u^n|)+\Delta t|g| \tag {4.10}</script><p>&emsp;&emsp;将不等式$(4.9)$的最大值带入公式$(4.10)$，我们有：</p>
<script type="math/tex; mode=display">
u_{max}=max(|u^n|)+\frac{5\Delta x}{u_{max}}|g| \tag {4.11}</script><p>&emsp;&emsp;取一个简单的速度上界（简化了公式$(4.11)$），$u_{max}$：</p>
<script type="math/tex; mode=display">
u_{max}=max(|u^n|)+\sqrt{5\Delta xg} \tag {4.12}</script><p>&emsp;&emsp;这样确保了$u_{max}$始终为正，且避免公式$(4.9)$的除$0$错误。</p>
<p>&emsp;&emsp;关于时间步长的讨论离不开$CFL$（以Courant、Friedrichs、Lewy三人的名字命名）条件。$CFL$条件是一个简单而直观的判断计算是否收敛的必要条件。它的直观物理解释就是时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。满足$CFL$条件意味着当$\Delta x$和$\Delta t$趋于取极限$0$时，数值计算所求的解就会收敛到原微分方程的解。</p>
<p>&emsp;&emsp;对于半拉格朗日对流法，其满足$CFL$条件当且仅当在极限情况下，追踪得到的粒子轨迹足够逼近真实的轨迹。足够逼近的意思是经过正确的网格插值能够得到正确的依赖域（即差分格式的依赖域包含了原微分方程的依赖域），追踪的轨迹就会收敛到正确真实的轨迹。</p>
<p>&emsp;&emsp;因而，对于采用标准的显式有限差分法的对流方程求解，为了保证收敛，我们要求$q^{n+1}$的新值是由以当前网格点为中心、以$C\Delta x$（$C$是一个小的整数常量）为半径的邻域范围内插值得到：</p>
<script type="math/tex; mode=display">
\Delta t \leq C\frac{\Delta x}{|\vec u|} \tag {4.13}</script><p>&emsp;&emsp;公式$(4.13)$中的$C$被称为$CFL$数，因而不等式$(4.9)$可以看成是公式$(4.13)$取$CFL$数为$5$得到。</p>
<h3 id="4、数值耗散"><a href="#4、数值耗散" class="headerlink" title="4、数值耗散"></a>4、数值耗散</h3><p>&emsp;&emsp;对流算法在对流获取新的物理量场$q^{n+1}_i$时会进行一些插值操作，插值不可避免地会平滑物理量场，这带来了一些数值耗散。一次两次的数值耗散不会由太大的影响，但是在流体模拟中我们会在每个时间步都进行对流运算，反反复复的平滑操作将数值耗散不断扩大，损失大量的流体细节。</p>
<p>&emsp;&emsp;以一维的对流项计算为例，流体速度为常量$u&gt;0$：</p>
<script type="math/tex; mode=display">
\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=0 \tag {4.14}</script><p>&emsp;&emsp;假设$\Delta t &lt; \frac{\Delta x}{u}$，即单个时间步长内粒子追踪轨迹长度小于单个网格单元的大小。我们的目标点是$x_i$，则倒推得到的粒子位置就落在了$[x_{i-1},x_i]$上的$x_i-\Delta tu$，然后进行线性插值得到$q^{n+1}_i$：</p>
<script type="math/tex; mode=display">
q^{n+1}=\frac{\Delta tu}{\Delta x}q^n_{i-1}+(1-\frac{\Delta tu}{\Delta x})q^n_i \tag {4.15}</script><p>&emsp;&emsp;将公式$(4.15)$整理一下，有：</p>
<script type="math/tex; mode=display">
q^{n+1}_i=q^n_i-\Delta tu\frac{q^n_i-q^n_{i-1}}{\Delta x} \tag {4.16}</script><p>&emsp;&emsp;公式$(4.16)$实际上正好就是采用时间上的前向欧拉差分法和空间上的单向有限差分法的欧拉方案，把$q^n_i$看成是$q^n$关于$x_i$的函数，对$q^n_{i-1}$进行泰勒级数展开：</p>
<script type="math/tex; mode=display">
q^n_{i-1}=q^n_i-(\frac{\partial q}{\partial x})^n_i\Delta x+(\frac{\partial^2q}{\partial x^2})^n_i\frac{\Delta x^2}{2}+O(\Delta x^3) \tag {4.17}</script><p>&emsp;&emsp;将公式$(4.17)$代入公式$(4.16)$，并做一些变量消去，可得：</p>
<script type="math/tex; mode=display">
q^{n+1}_i=q^n_i-\Delta tu(\frac{\partial q}{\partial x})^n_i+\Delta tu\Delta x(\frac{\partial^2q}{\partial x^2})^n_i+O(\Delta x^2) \tag {4.18}</script><p>&emsp;&emsp;在二阶截断误差的情况下，结合公式$(4.18)$和公式$(4.14)$，有：</p>
<script type="math/tex; mode=display">
\frac{\partial q}{\partial t}+u\frac{\partial q}{\partial x}=u\Delta x(\frac{\partial^2q}{\partial x^2}) \tag {4.19}</script><p>&emsp;&emsp;右边就是对流方程计算时引入的额外类似粘度乘上系数$u\Delta x$的项。<strong>这也就是说，当我们采用简单的半拉格朗日法去求解无粘度的对流方程时，模拟的结果却看起来我们像时在模拟有粘度的流体。这就是数值耗散！</strong>当然，当$\Delta x\to 0$时，这个数值耗散系数也会趋于$0$，所以取时间步无穷小时能够得到正确的模拟结果，但这需要耗费巨额的计算资源开销。我们通常模拟的流体大多数都是无粘度的，所以如何减少这个数值耗散是个至关重要的难题。</p>
<p>&emsp;&emsp;一个简单有效的修复数值耗散的方法就是采用更加锐利的插值方法，从而尽可能地减少由插值带来的数值耗散。在一维的情况时，我们采用三次插值（cubic interpolant）如下公式$(4.21)$，而不是简单的一次线性插值$(4.20)$：</p>
<script type="math/tex; mode=display">
q\approx(1-s)x_i+sx_{i+1} \tag {4.20}</script><script type="math/tex; mode=display">
q\approx[-\frac13s+\frac12s^2-\frac16s^3]q_{i-1}+[1-s^2+\frac12(s^3-s)]q_i\\
+[s+\frac12(s^2-s^3)]q_{i+1}+[\frac16(s^3-s)]q_{i+2} \tag {4.21}</script><p>&emsp;&emsp;扩展到二维或者三维就是双三次插值（bicubic interpolation）或三三次插值（tricubic interpolation）。以二维情况为例，我们可以先沿着$x$轴做第一遍的三次插值如公式$(4.22)$，然后再沿着$y$轴做第二遍插值如公式$(4.23)$：</p>
<script type="math/tex; mode=display">
q_{j-1}=w_{-1}(s)q_{i-1,j-1}+w_0(s)+q_{i,j-1}+w_1(s)q_{i+1,j-1}+w_2(s)q_{i+2,j-1},\\
q_{j}=w_{-1}(s)q_{i-1,j}+w_0(s)+q_{i,j}+w_1(s)q_{i+1,j}+w_2(s)q_{i+2,j},\\
q_{j+1}=w_{-1}(s)q_{i-1,j+1}+w_0(s)+q_{i,j+1}+w_1(s)q_{i+1,j+1}+w_2(s)q_{i+2,j+1},\\
q_{j+2}=w_{-1}(s)q_{i-1,j+2}+w_0(s)+q_{i,j+2}+w_1(s)q_{i+1,j+2}+w_2(s)q_{i+2,j+2}. \tag {4.22}</script><script type="math/tex; mode=display">
q=w_{-1}(t)q_{j-1}+w_0(t)q_j+w_1(t)q_{j+1}+w_2(t)q_{j+2} \tag {4.23}</script><p>&emsp;&emsp;当然也可以先沿着$y$轴，然后再沿着$x$轴做插值操作。</p>

        </div>
        
          


  <section class="meta" id="footer-meta">
    <hr>
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-09-12T16:52:00+08:00">
  <a class="notlink">
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>最后更新于 2019年9月12日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Computer-Graphics/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Computer Graphics</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Fluid-Simulation/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Fluid Simulation</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Naiver-Stokes-Equations/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Naiver-Stokes Equations</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Advection/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Advection</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yangwc.com/2019/05/01/fluidSimulation/&title=流体模拟Fluid Simulation：流体模拟基础 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png&summary=本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://yangwc.com/2019/05/01/fluidSimulation/&title=流体模拟Fluid Simulation：流体模拟基础 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png&summary=本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=https://yangwc.com/2019/05/01/fluidSimulation/&title=流体模拟Fluid Simulation：流体模拟基础 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png&summary=本文主要参考文献《FLUID SIMULATION SIGGRAPH 2007 Course Notes》，结合我的理解单纯地讲述一下流体渲染的一些基础知识，本人水平有限，如有错误，欢迎指出。本文只是单纯针对流体模拟领域，可能一些地方不太严谨，但是对于虚拟模拟来说是可行的。即便如此，本文涉及到大量的数学方法。">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                            <h4>
                                <a href="/2019/05/01/SoftRenderer-Math/" rel="prev" title="软渲染器Soft Renderer：3D数学篇">
                                  
                                      软渲染器Soft Renderer：3D数学篇
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Soft-Renderer/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Soft Renderer</a> <a class="tag" href="/tags/3D-Math/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>3D Math</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
        <section id="comments">
          <div id="lv-container" data-id="city" data-uid="MTAyMC80MzkxOS8yMDQ1NQ==">
            <noscript><div><i class="fas fa-exclamation-triangle">&nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。</i></div></noscript>
          </div>
        </section>
      
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

  <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



  <script>
    window.subData = {
      title: '流体模拟Fluid Simulation：流体模拟基础',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content material">
    
      <div class="avatar">
        <fancybox><img class="avatar" src="/image/avator.png"></fancybox>
      </div>
    
    
      <div class="text">
        
          <h2>YangWC</h2>
        
        
          <p>A student from Sun Yat-sen University.</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget toc-wrapper">
    
<header class="material">
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class="content material">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、矢量微积分"><span class="toc-text">一、矢量微积分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、梯度（Gradient）"><span class="toc-text">1、梯度（Gradient）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、散度（Divergence）"><span class="toc-text">2、散度（Divergence）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、旋度（Curl）"><span class="toc-text">3、旋度（Curl）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、拉普拉斯算子（Laplacian）"><span class="toc-text">4、拉普拉斯算子（Laplacian）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、-Naiver-Stokes-偏微分方程组"><span class="toc-text">二、$Naiver-Stokes$偏微分方程组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、符号标记"><span class="toc-text">1、符号标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、动量方程"><span class="toc-text">2、动量方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、拉格朗日描述与欧拉描述"><span class="toc-text">3、拉格朗日描述与欧拉描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、不可压缩性"><span class="toc-text">4、不可压缩性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、丢弃粘度项"><span class="toc-text">5、丢弃粘度项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、边界条件"><span class="toc-text">6、边界条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、N-S方程的分步求解"><span class="toc-text">三、N-S方程的分步求解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、时间步长"><span class="toc-text">1、时间步长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、网格结构"><span class="toc-text">2、网格结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、对流算法"><span class="toc-text">四、对流算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、半拉格朗日对流算法（Semi-Lagrangian-Advection）"><span class="toc-text">1、半拉格朗日对流算法（Semi-Lagrangian Advection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、边界情况"><span class="toc-text">2、边界情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、时间步长大小"><span class="toc-text">3、时间步长大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、数值耗散"><span class="toc-text">4、数值耗散</span></a></li></ol></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class="widget plain">
  
<header class="material">
  <div><i class=" fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;欢迎来到YangWC的博客</div>
  
</header>

  <div class="content material">
    <p>本站会记录自己的一些学习内容，如若有错或者乱码，欢迎指正，感谢!</p>

  </div>
</section>

          
        
      
        
          
          
            <section class="widget grid">
  
<header class="material">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content material">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于博主
        </a></li>
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn" rel="nofollow" href="/categories/" title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/2D-Rendering/" href="/categories/2D-Rendering/"><div class="name">2D Rendering</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Computer-Graphics/" href="/categories/Computer-Graphics/"><div class="name">Computer Graphics</div><div class="badge">(23)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-Simulation/" href="/categories/Fluid-Simulation/"><div class="name">Fluid Simulation</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Image-processing/" href="/categories/Image-processing/"><div class="name">Image processing</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/N-body/" href="/categories/N-body/"><div class="name">N-body</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physically-Based-Rendering/" href="/categories/Physically-Based-Rendering/"><div class="name">Physically Based Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Position-Based-Dynamics/" href="/categories/Position-Based-Dynamics/"><div class="name">Position Based Dynamics</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Ray-Tracer/" href="/categories/Ray-Tracer/"><div class="name">Ray Tracer</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Real-time-Rendering/" href="/categories/Real-time-Rendering/"><div class="name">Real-time Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Soft-Renderer/" href="/categories/Soft-Renderer/"><div class="name">Soft Renderer</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Voxelization/" href="/categories/Voxelization/"><div class="name">Voxelization</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class="widget tagcloud">
    
<header class="material">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn" rel="nofollow" href="/tags/" title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <a href="/tags/2D-Rendering/" style="font-size: 14px; color: #bbb">2D Rendering</a> <a href="/tags/3D-Math/" style="font-size: 14px; color: #bbb">3D Math</a> <a href="/tags/3D-pipeline/" style="font-size: 16px; color: #c9c9c9">3D pipeline</a> <a href="/tags/Advection/" style="font-size: 14px; color: #bbb">Advection</a> <a href="/tags/Computer-Graphics/" style="font-size: 24px; color: #fff">Computer Graphics</a> <a href="/tags/Fluid-Simulation/" style="font-size: 22px; color: #f1f1f1">Fluid Simulation</a> <a href="/tags/Glow-effect/" style="font-size: 14px; color: #bbb">Glow effect</a> <a href="/tags/Image-processing/" style="font-size: 14px; color: #bbb">Image processing</a> <a href="/tags/N-body/" style="font-size: 14px; color: #bbb">N-body</a> <a href="/tags/Naiver-Stokes-Equations/" style="font-size: 14px; color: #bbb">Naiver-Stokes Equations</a> <a href="/tags/Physically-Based-Rendering/" style="font-size: 16px; color: #c9c9c9">Physically Based Rendering</a> <a href="/tags/Position-Based-Dynamics/" style="font-size: 18px; color: #d6d6d6">Position Based Dynamics</a> <a href="/tags/Rasterization/" style="font-size: 14px; color: #bbb">Rasterization</a> <a href="/tags/Ray-Tracer/" style="font-size: 18px; color: #d6d6d6">Ray Tracer</a> <a href="/tags/Real-time-Rendering/" style="font-size: 16px; color: #c9c9c9">Real-time Rendering</a> <a href="/tags/Soft-Renderer/" style="font-size: 20px; color: #e4e4e4">Soft Renderer</a> <a href="/tags/Voxelization/" style="font-size: 14px; color: #bbb">Voxelization</a>
    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
	<script>
		var now = new Date(); 
		function createtime() { 
			var grt= new Date("04/24/2019 18:00:00");//在此处修改你的建站时间
			now.setTime(now.getTime()+250); 
			days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
			hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
			if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
			mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
			seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
			snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
			document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
			document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
		} 
	setInterval("createtime()",250);
   </script>
   
   <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->
	
	
	<script>setLoadingBarProgress(80);</script>
</footer>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>









  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>






  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  
    <!--数字雨背景-->
  <canvas id="canvas" width="1440" height="900" ></canvas>
  <script>
	var s = window.screen;
	var width = canvas.width = s.width;
	var height = canvas.height = s.height;
	var fontSize = 13;
	var colunms = Math.floor(width/fontSize);
	var letters = [];
    for(var i=0;i<colunms;i++){
        letters.push(1);
    }
	var draw = function () {
	    canvas.getContext('2d').fillStyle = "rgba(0,0,0,.08)";//遮盖层
		canvas.getContext('2d').fillRect(0,0,width,height);
		canvas.getContext('2d').font = "700 " + fontSize +"px  微软雅黑";
		letters.map(function(y_pos, index){
		text = String.fromCharCode(34+Math.random()*33);
		x_pos = index * fontSize;
		canvas.getContext('2d').fillText(text, x_pos, y_pos);
		letters[index] = (y_pos > 758 + Math.random() * 1e4) ? 0 : y_pos + 10;
		canvas.getContext('2d').fillStyle='#'+letters[index];
	  });
	};
	setInterval(draw, 33);
  </script>
  
  <!-- 页面点击出现文字 -->
  <script type="text/javascript" src="/js/ClickShowText.js"></script>
  
  <script>setLoadingBarProgress(100);</script>
</body>
</html>
