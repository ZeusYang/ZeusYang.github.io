<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>流体模拟Fluid Simulation：Position Based Fluid | YangWC&#39;s Blog</title>
  
  
  <meta name="description" content="Personal blog website.">
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/logo.ico">
  

  
    <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fdf716664defeee80e01568ddbeb2425";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
  
</head>
<body>
  
  
  <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          YangWC's Blog
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
									<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/" id="home">
									<i class="fas fa-grin fa-fw"></i>&nbsp;博客
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
									<i class="fas fa-tag fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;个人
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-grin fa-fw"></i>&nbsp;博客
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
								<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
								<i class="fas fa-tag fa-fw"></i>&nbsp;标签
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      <div class="l_main">
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/06/04/PositionBasedFluid/">
        流体模拟Fluid Simulation：Position Based Fluid
      </a>
    </h1>
  


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="https://yangwc.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-06-04</p>
  </a>
</div>

          
        
          
            
  
  <div class="new-meta-item category">
    <a href="/categories/Fluid-Simulation/" rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Computer Graphics&nbsp;/&nbsp;Fluid Simulation</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p>本篇文章主要是关于Position Based Dynamics的流体模拟方法，这类方法依旧采用基于拉格朗日的视角，把流体看成由一个一个粒子组成，易于并行化，适用于实时的流体模拟。目前实现的只是CPU版本，考虑在后面利用cuda挪到GPU上做模拟计算。相关的完整代码请看<a href="https://github.com/ZeusYang/PositionBasedFluid" target="_blank" rel="noopener">这里</a>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/header.gif" alt="header"></p>
<a id="more"></a>
<ul>
<li>基于位置动力学的物理模拟</li>
<li>基于位置动力学的流体模拟</li>
<li>流体模拟算法实现</li>
<li>实现效果</li>
<li>参考资料</li>
</ul>
<h1 id="一、基于位置动力学的物理模拟"><a href="#一、基于位置动力学的物理模拟" class="headerlink" title="一、基于位置动力学的物理模拟"></a>一、基于位置动力学的物理模拟</h1><p>&emsp;&emsp;传统的物理模拟方法都是基于力的方法，这类方法通过计算内部力（如流体内部的粘性力、压力）和外部力（如重力和碰撞力）的合力，然后根据牛顿第二定律计算出加速度，最后根据数值计算方法求出物体的速度和位置。这种方法基本上针对每一种动态物体，会由一个独立的求解器，各种求解器按照一定的顺序计算，从而得到模拟的结果，这样会带来大量冗余的工作。基于位置动力学（Position Based Dynamics）的方法将这些物理运动通过约束表达出来，这样只需要一个求解器即可，更加方便地进行物理模拟。</p>
<p>&emsp;&emsp;下图1是基于力和基于位置动力学的物体碰撞更新过程的对比，可以看到基于力的碰撞检测首先在穿透发生时更新物体的速度，然后更新物体的位置。而基于位置动力学的碰撞检测首先只检测是否发生穿透，然后移动位置使之不发生穿透，最后再据此更新物体的速度信息。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/1.jpg" width="60%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/2.jpg" width="60%"></div></p>
<p><center> 图1 两种碰撞更新过程对比 </center></p>
<h2 id="1、基于位置动力学的模拟算法"><a href="#1、基于位置动力学的模拟算法" class="headerlink" title="1、基于位置动力学的模拟算法"></a>1、基于位置动力学的模拟算法</h2><p>&emsp;&emsp;基于位置动力学英文全称为Position Based Dynamics，以下简称为PBD。接下来我们介绍经典的PBD算法。在PBD算法中，运动的物体由$N$个顶点和$M$个约束组成。顶点$i\in [1,…,N]$的质量为$m_i$，位置为$x_i$，速度为$v_i$，每个约束$j\in [1,…,M]$有如下五个性质：</p>
<ul>
<li>约束的基数为$n_j$，即第$j$个约束所影响的顶点数目为$n_j$个；</li>
<li>约束函数$C_j:\ R^{3n_j}\to R$；</li>
<li>受约束影响的顶点索引值集合$\{i_1,…,i_{n_j}\},i_k\in [1,…N]$；</li>
<li>每个约束都有对应的刚度参数$k_j\in [0,1]$，这里我们可以理解为约束的强度；</li>
<li>约束分为两种，一类是等式约束即$C_j(x_{i1},x_{i_2},…,x_{i_{n_j}})=0$，另一类是不等式约束$C_j(x_{i_1},x_{i_2},…,x_{i_{n_j}})\geq 0$。</li>
</ul>
<p>&emsp;&emsp;给定时间步长$\Delta t$，PBD的运动物体模拟的算法伪代码如下所示：</p>
<script type="math/tex; mode=display">
\begin{align}
&1.forall\ \ vertices\ \ i:\\

&2.\ \ \ \ initialize\ \ x_i=x_i^0,v_i=v_i^0,w_i=1/m_i\\

&3.endfor\\

&4.loop\\

&5.\ \ \ \ forall\ \ vertices\ \ i\ \ do\ \  v_i\leftarrow v_i+\Delta tw_if_{ext}(x_i)\\

&6.\ \ \ \ dampVelocities(v_1,...,v_N)\\

&7.\ \ \ \ forall\ \ vertices\ \ i\ \ do\ \ p_i\leftarrow x_i+\Delta t v_i\\

&8.\ \ \ \ forall\ \ vertices\ \ i\ \ do\ \ generateCollisionConstraints(x_i\to p_i)\\

&9.\ \ \ \ loop\ \ solverIterations\ \ times\\

&10.\ \ \ \ \ \ \ \ projectConstraints(C1,...,C_{M+M_{coll}},p_1,...,p_N)\\

&11.\ \ \ endloop\\

&12.\ \ \ forall\ \ vertices\ \ i\\

&13.\ \ \ \ \ \ \ \ v_i\leftarrow (p_i-x_i)\Delta t\\

&14.\ \ \ \ \ \ \ \ x_i\leftarrow p_i\\

&15.\ \ \ endfor\\

&16.\ \ \ velocityUpdate(v1,...,v_N)\\

&17.endloop\\
\end{align}</script><p>&emsp;&emsp;在上面的算法第1步到第3步中，我们首先对顶点的位置、速度和质量倒数进行初始化，其中质量的倒数$w_i=1/m_i$，除了可以避免冗余的除法操作外，还可以使用于静态的物体，对于静态的物体我们设为$w_i=0$，这样在后续的更新中都不会产生位置和速度的变化量。第5步中的$f_{ext}$代表不能转换成约束形式的力（如重力），我们根据$f_{ext}$进行一次数值计算预测在$f_{ext}$的作用下的速度$v_i$。紧接着在第6步中我们添加阻尼的作用，阻尼可以理解为物体在运动中发生了能量耗散，从而导致速度有所衰减。第8行主要是生成碰撞约束，物体会与周围的环境发生碰撞，例如布料落在地板上，水碰上一面墙等，这些碰撞约束在每个时间步长都发生改变，所以每一次都需要重新生成碰撞约束。有了内部约束（如不可压缩流体的密度约束）和外部约束（如流体与地面的碰撞约束）之后，我们需要根据这些约束做一个迭代求解，也就是上面伪代码中的第9行到第11行，这里我们称为<strong>约束投影步骤</strong>。从约束投影步骤我们得到服从给定约束的粒子位置，然后再第12行到第15行更新顶点粒子的速度和位置信息。最后在第16行根据摩擦系数（friction）和恢复系数（restitution）更新速度，如下图2所示。这样，一个完整的PBD物理模拟步骤就完成了。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/3.jpg" width="60%"></div></p>
<p><center> 图2 friction和restitution </center></p>
<h2 id="2、约束投影步骤"><a href="#2、约束投影步骤" class="headerlink" title="2、约束投影步骤"></a>2、约束投影步骤</h2><p>&emsp;&emsp;接下来我们就针对约束投影步骤详细展开相关的内容，约束投影是PBD中的最难理解的核心部分，涉及的数学内容比较多一点。设有一个基数为n（也就是前面提到的$n_j$，受到该约束影响的顶点数目或者说粒子数目）的约束，关联的粒子点为$p_1,…,p_n$，约束函数记为$C$，刚度系数（stiffness）为$k$。记$p=[p_1^T,…,p_n^T]^T$，则等式约束函数表示为：</p>
<script type="math/tex; mode=display">
C(p)=0 \tag {1}</script><p>&emsp;&emsp;我们的目标是计算这样的一个位移偏移量$\Delta p$，使得粒子顶点在$p+\Delta p$处约束条件依然满足，即：</p>
<script type="math/tex; mode=display">
C(p+\Delta p)=0 \tag {2}</script><p>&emsp;&emsp;对约束函数$C$做一阶泰勒展开（或者导数的定义），则可得:</p>
<script type="math/tex; mode=display">
C(p+\Delta p)\approx C(p)+\nabla_pC(p)\cdot\Delta p=0 \tag {3}</script><p>&emsp;&emsp;为了使粒子在$p+\Delta p$处依然满足约束条件，我们要求解方程$(3)$得到$\Delta p$。PBD算法的一个巧妙之处在于它将$\Delta p$的方向限制在约束函数的梯度方向$\nabla_p C(p)$上。如下图3所示，约束$C$所涉及到的粒子位置会形成一个高维空间，下图为该空间中满足不同约束条件的粒子位置形成的二维等值线示意图，其中满足$C$约束条件的是黑色等值线。故当粒子处于下图的黑色点的位置时，不满足约束条件，如果我们沿着点所在的等值线（灰色曲线）移动，此时刚体模态（Rigid body modes）的方向与该等值线相同，新得到的位置仍然在该灰色等值线上，依然不在黑色曲线 $C=0$上，即不满足约束条件。这可以理解为，约束中存在的误差依然没有得到修正。以两个粒子形成的距离约束为例，就好比同时移动了两个粒子或者该约束绕自身旋转，但是存在的误差并没有得到更正。而且这样一来还会引入系统中不存在的一种外力，导致系统动量不守恒。所以，我们希望该点的位移方向与刚体模态方向垂直，从而保证系统动量守恒，即从黑点指向红点的方向$\nabla C$。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/4.jpg" width="60%"></div></p>
<p><center> 图3 约束等值线 </center><br>&emsp;&emsp;因此，我们令位移向量$\Delta p$为约束函数的梯度向量$\nabla_p C$再乘上一个标量缩放系数$\lambda$：</p>
<script type="math/tex; mode=display">
\Delta p=\lambda \nabla_p C(p) \tag {4}</script><p>&emsp;&emsp;其中的标量缩放系数$\lambda$我们称之为拉格朗日乘子（Lagrange multiplier）。联立公式$(3)$和$(4)$我们可得：</p>
<script type="math/tex; mode=display">
\lambda=-\frac{C(p)}{|\nabla_pC(p)|^2} \tag {5}</script><p>&emsp;&emsp;然后将$\lambda$再代入公式$(4)$我们可得$\Delta p$的表达式：</p>
<script type="math/tex; mode=display">
\Delta p=\lambda \nabla_pC(p)=-\frac{C(p)}{|\nabla_pC(p)|^2}\nabla_pC(p) \tag {6}</script><p>&emsp;&emsp;具体到粒子$i$，约束投影后其对应的位移向量为：</p>
<script type="math/tex; mode=display">
\Delta p_i=-s\nabla_{p_i}C(p_1,...,p_n) \tag {7}</script><p>&emsp;&emsp;其中的$s$为如下所示，$s$的值对于约束函数$C$作用范围内的所有点都一样。</p>
<script type="math/tex; mode=display">
s=\frac{C(p_1,...,p_n)}{\Sigma_j|\nabla_{p_j}C(p_1,...,p_n)|^2} \tag {8}</script><p>&emsp;&emsp;前面我们假定所有的粒子质量都相同，现在考虑粒子质量不同的情况。记粒子$i$的质量为$m_i$，其质量的倒数为$w_i=1/m_i$，则公式$(4)$变为：</p>
<script type="math/tex; mode=display">
\Delta p_i=\lambda w_i\nabla_{p_i}C(p) \tag {9}</script><p>&emsp;&emsp;公式$(7)$和公式$(8)$变为：</p>
<script type="math/tex; mode=display">
\Delta p_i=-s w_i\nabla_{p_i}C(p_1,...,p_n) \tag {10}</script><script type="math/tex; mode=display">
s=\frac{C(p_1,...,p_n)}{\Sigma_jw_j|\nabla_{p_j}C(p_1,...,p_n)|^2} \tag {11}</script><p>&emsp;&emsp;为了便于理解，接下来我们举个简单的例子应用约束投影方法。如下图4所示。</p>
<p><div align="center"><img src="assets/5.png" width="60%"></div></p>
<p><center> 图4 简单的约束例子 </center><br>&emsp;&emsp;上面的约束可以表示为$C(p_1,p_2)=|p_1-p_2|-d$，位移向量记为$\Delta p_i$。根据约束投影方法，我们首先约束函数$C(p_1,p_2)$关于$p_1$和$p_2$的梯度，也就是求偏导数。注意到$C(p_1,p_2)=|p_1-p_2|-d=(\sqrt{(p_1-p_2)^2})-d$，我们可以求得以下的梯度向量表达式：</p>
<script type="math/tex; mode=display">
\nabla_{p_1}C(p_1,p_2)=\frac{p_1-p_2}{|p_1-p_2|}\\
\nabla_{p_2}C(p_1,p_2)=-\frac{p_1-p_2}{|p_1-p_2|} \tag {12}</script><p>&emsp;&emsp;注意，上面求到的是一个矢量，也就是我们说的梯度向量。将公式$(12)$代入公式$(11)$可得：</p>
<script type="math/tex; mode=display">
\begin{align}
s=&\frac{C(p_1,...,p_n)}{\Sigma_jw_j|\nabla_{p_j}C(p_1,...,p_n)|^2}\\
=&\frac{|p_1-p_2|-d}{w_1|\nabla_{p_1}C(p_1,p_2)|^2+w_2|\nabla_{p_2}C(p_1,p_2)|^2}\\
=&\frac{|p_1-p_2|-d}{w_1+w_2} \tag {13}
\end{align}</script><p>&emsp;&emsp;最后，将公式$(13)$代入到公式$(10)$，可得约束投影计算得到的位移：</p>
<script type="math/tex; mode=display">
\begin{align}
\Delta p_1=&-\frac{|p_1-p_2|-d}{w_1+w_2}w_1\nabla_{p_1}C(p_1,p_2)\\
=&-\frac{w_1}{w_1+w_2}(|p_1-p_2|-d)\frac{p_1-p_2}{|p_1-p_2|}
\end{align}</script><p>&emsp;&emsp;同理$\Delta p_2$如下所示：</p>
<script type="math/tex; mode=display">
\Delta p_2=+\frac{w_2}{w_1+w_2}(|p_1-p_2|-d)\frac{p_1-p_2}{|p_1-p_2|}</script><p>&emsp;&emsp;前面我们提到每个约束都有对应的刚度系数$k$，令$k’=1-(1-k)^{1/n_s}$去乘$\Delta p$，这里$n_s$迭代之后误差为$\Delta p(1-k’)^{n_s}=\Delta p(1-k)$，与刚度系数成线性关系，而与迭代次数$n_s$无关。下一个时间步的位置如下所示：</p>
<script type="math/tex; mode=display">
p_1^{t+1}=p_1^t+k'\Delta p_1\\
p_2^{t+1}=p_2^t+k'\Delta p_2</script><h2 id="3、约束投影求解器"><a href="#3、约束投影求解器" class="headerlink" title="3、约束投影求解器"></a>3、约束投影求解器</h2><p>&emsp;&emsp;前面的伪代码中我们可以看到约束投影的输入为$M+M_{coll}$个约束和$N个$点的预测位置$p1,…,p_N$，所需要求解的方程组是非线性非对称方程组或不等式组（碰撞约束产生的）。约束投影步骤的主要任务就是修正预测位置使新得到的校正位置满足所有约束。但是一般情况下很难找到一个适当的$\Delta p=[\Delta p_1^T,…,\Delta p_n^T]^T$恰好使得所有的约束都能够同时得到满足，故我们通常采用迭代的方法按顺序依次对约束进行求解。</p>
<p>&emsp;&emsp;我们可以采用非线性高斯-赛德尔（Non-Linear Gauss-Seidel，简称NGS）迭代方法。高斯赛德尔（Gauss-Sedel，简称GS）迭代方法只能求解线性方程组，NGS在依次求解德基础上，加入了约束投影求解这一非线性操作。与雅可比迭代方法（Jacobi method）不同，NGS求解器在一次迭代中对于顶点位置的修正立即被应用到下一个约束求解中，这样的好处就是显著加快了收敛速度。</p>
<p>&emsp;&emsp;但是NGS虽然稳定且容易实现，但是该方法收敛速度依然不是很快，不宜并行化。</p>
<h1 id="二、基于位置动力学的流体模拟"><a href="#二、基于位置动力学的流体模拟" class="headerlink" title="二、基于位置动力学的流体模拟"></a>二、基于位置动力学的流体模拟</h1><p>&emsp;&emsp;前面部分主要介绍了Position Based Dynamics算法相关的内容，接下来我们就看看如何将其PBD算法应用到流体模拟当中，主要是如何针对流体的物理特性构建相应的约束函数。基于位置动力学的流体全称为Position Based Fluid，简称PBF。</p>
<h2 id="1、不可压缩约束"><a href="#1、不可压缩约束" class="headerlink" title="1、不可压缩约束"></a>1、不可压缩约束</h2><p>&emsp;&emsp;在不可压缩性的流体模拟中，我们需要使粒子$i$的密度$\rho_i$尽量与静态的密度$\rho_0$相同，即$\rho_i=\rho_0$。因此，我们需要对每一个流体粒子都施加一个常量密度约束，PBF的常量密度约束如下所示：</p>
<script type="math/tex; mode=display">
C_i(p_1,...,p_n)=\frac{\rho_i}{\rho_0}-1 \tag {14}</script><p>&emsp;&emsp;公式$(14)$中，我们记粒子$i$的位置为$p_i$，$p_1,…,p_n$是与粒子$i$相邻的粒子。可以看到当密度约束$C_i(p_1,…,p_n)=0$时有$\rho_i=\rho_0$，此时流体的体积即不压缩也不膨胀，从而保证了流体的不可压缩条件，这就是公式$(14)$的由来。流体粒子$i$的密度根据SPH（Smoothed Particle Hydrodynamics，光滑<em>粒子</em>流体动力学，简称SPH）方法的计算公式如下所示：</p>
<script type="math/tex; mode=display">
\rho_i=\Sigma_jm_jW(p_i-p_j,h) \tag {15}</script><p>&emsp;&emsp;在公式$(15)$中，$m_j$是邻居粒子$j$的质量，$h$是指定的光滑核半径。$W$函数我们接下来会提到。将公式$(15)$代入公式$(14)$，我们有：</p>
<script type="math/tex; mode=display">
C_i(p_1,...,p_n)=\frac{\Sigma_j m_jW(p_i-p_j,h)}{\rho_0}-1 \tag {16}</script><p>&emsp;&emsp;在公式$(15)$的密度计算中，PBF方法采用了Poly6核函数：</p>
<script type="math/tex; mode=display">
W_{poly6}(r,h)=\frac{315}{64\pi h^9}
\begin{cases}
(h^2-|r|^2)^3\ \ \ \  0\leq|r|\leq h\\
0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise 
\end{cases} \tag {17}</script><p>&emsp;&emsp;但是在计算密度的梯度时，却又采用了Spiky核函数：</p>
<script type="math/tex; mode=display">
W_{spiky}(r,h)=\frac{15}{\pi h^6}
\begin{cases}
(h-|r|)^3\ \ \ \ 0\leq|r|\leq h\\
0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0therwise
\end{cases} \tag {18}</script><p>&emsp;&emsp;对公式$(18)$求关于$r$的导数（注意，$|r|=\sqrt{r^2}$，不能直接对$|r|$求导），从而流体粒子密度的梯度如下所示：</p>
<script type="math/tex; mode=display">
\nabla W_{spiky}(r,h)=-\frac{45}{\pi h^6}
\begin{cases}
(h-|r|)^2\frac{r}{|r|}\ \ \ \ 0\leq|r|\leq h\\
0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise
\end{cases} \tag {19}</script><p>&emsp;&emsp;因此，粒子$i$的约束函数$(16)$是一个关于$p_1,…,p_n$的非线性方程组$C_i(p_1,…,p_n)=0$，所有粒子$i$的约束组成了一个非线性方程组。在PBF方法中，我们只考虑粒子质量相同的情况，故我们可以省去公式$(15)$和公式$(16)$中的质量$m_j$，即：</p>
<script type="math/tex; mode=display">
\rho_i=\Sigma_jW(p_i-p_j,h) \tag {20}</script><script type="math/tex; mode=display">
C_i(p_1,...,p_n)=\frac{\Sigma_j W(p_i-p_j,h)}{\rho_0}-1 \tag {21}</script><p>&emsp;&emsp;然后求约束函数$C_i$关于$p_k$的梯度如下，其中$k\in\{1,2,…,n\}$：</p>
<script type="math/tex; mode=display">
\nabla_{p_k}C_i=\frac1\rho_0\Sigma_j\nabla_{p_k}W(p_i-p_j,h) \tag {22}</script><p>&emsp;&emsp;显然，针对$k$的不同，分为两种情况。当$k=i$也就是粒子本身的时候，连加符号中的$W$均为关于$p_k$的函数；当$k=j$即邻居粒子的时候，只有$W(p_i-p_k,h)$才有意义，其他相对于$p_k$来说都是常量，故导数为0（注意用到了求导的链式法则）：</p>
<script type="math/tex; mode=display">
\nabla_{p_k}C_i=\frac1\rho_0
\begin{cases}
\Sigma_j\nabla_{p_k}W(p_i-p_j,h)\ \ \ \ if\ \ k=i\\
-\nabla_{p_k}W(p_i-p_j,h)\ \ \ \ \ if\ \ k=j
\end{cases} \tag {23}</script><p>&emsp;&emsp;既然求出了约束函数的梯度，我们就把它应用到前面提到的拉格朗日乘子的计算公式中，联立公式$(5)$和公式$(23)$，我们有：</p>
<script type="math/tex; mode=display">
\lambda_i=-\frac{C_i(p_1,...,p_n)}{\Sigma_k|\nabla_{p_k}C_i|^2} \tag {24}</script><h2 id="2、混合约束"><a href="#2、混合约束" class="headerlink" title="2、混合约束"></a>2、混合约束</h2><p>&emsp;&emsp;如果一个约束条件不能被违背，我们称之为硬约束；而能一定程度上被违背的约束称为软约束。在理想的情况下，我们都希望约束始终是硬约束，但是由于误差或者数值方法的不稳定等原因，我们有时不得不向软约束妥协。</p>
<p>&emsp;&emsp;在PBF中，当$|r|=h$，粒子$i$与粒子$j$之间的距离等于光滑核半径时，粒子$i$和粒子$j$处于即将分离的状态。注意观察公式$(19)$的密度梯度计算公式，此时$\nabla W_{spiky}(r,h)=0$。若所有的邻居粒子与粒子$i$都处于这种状态，那么必将导致约束函数的梯度即公式$(22)$取值为0：</p>
<script type="math/tex; mode=display">
\nabla_{p_k}C_i=\frac1\rho_0\Sigma_j\nabla_{p_k}W(p_i-p_j,h) = 0</script><p>&emsp;&emsp;从而导致公式$(24)$中的分母$\Sigma_k|\nabla_{p_k}C_i|^2$为0，出现除零错误，这将导致PBF方法出现潜在的不稳定性。为了解决这个问题，PBF采用混合约束的方法，使密度硬约束转变成软约束。具体的做法就是将根据密度函数求解得到的约束力再加入到原始的约束函数中，这里在PBF的常量密度约束中得到的拉格朗日乘子$\lambda$有类似的作用，故将$\lambda$加入到初始的约束方程（即公式$(3)$）：</p>
<script type="math/tex; mode=display">
C(p+\Delta p)\approx C(p)+\nabla C^T\nabla C \lambda + \epsilon\lambda=0 \tag {25}</script><p>&emsp;&emsp;公式$(25)$中的$\epsilon$是松弛参数，可以由用户指定。引入公式$(25)$后，拉格朗日乘子的计算公式$(24)$就变为：</p>
<script type="math/tex; mode=display">
\lambda_i=-\frac{C_i(p_1,...,p_n)}{\Sigma_k|\nabla_{p_k}C_i|^2+\epsilon} \tag {26}</script><p>&emsp;&emsp;从而可得粒子$i$在经过上述约束投影后对应的位移向量（包括自身密度约束以及邻居粒子密度约束共同作用的结果。注意，这里对应的上面的公式$(4)$，结合公式$(23)$）：</p>
<script type="math/tex; mode=display">
\begin{align}
\Delta p_i&=\lambda_i \nabla_{p_i}C_i+\Sigma_j\lambda_j\nabla_{p_j}C_i\\
&=\frac1\rho_0\Sigma_j\lambda_i\nabla_{p_i}W(r,h)+(-\frac1\rho_0\Sigma_j\lambda_j\nabla_{p_j}W(r,h))\\
&=\frac1\rho_0\Sigma_j\lambda_i\nabla_{p_i}W(r,h)+\frac1\rho_0\Sigma_j\lambda_j\nabla_{p_i}W(r,h)\\
&=\frac{1}{\rho_0}\Sigma_j(\lambda_i+\lambda_j)\nabla_{p_i}W(r,h)
\end{align} \tag {27}</script><h2 id="3、拉伸不稳定性"><a href="#3、拉伸不稳定性" class="headerlink" title="3、拉伸不稳定性"></a>3、拉伸不稳定性</h2><p>&emsp;&emsp;PBF采用SPH的方法来计算流体粒子的密度，但是该方法通常需要30~40个邻居粒子才能使密度求值结果趋于静态密度。在邻居粒子数量较少的情况下，通过该方法计算得到的流体密度低于静态密度，由此会造成流体内部压强为负数，原本粒子间的压力变为吸引力，使得流体粒子凝聚在一起，导致流体表面的模拟效果失真。PBF采用了一种人工排斥力的计算模型，当流体粒子距离过近时该排斥力会使它们分开，避免产生粒子聚集的现象。在公式$(24)$的基础上，加入一个排斥项（repulsive term）$s_{corr}$：</p>
<script type="math/tex; mode=display">
\Delta p_i=\frac1\rho_0\Sigma_j(\lambda_i+\lambda_j+s_{corr})\nabla_{p_i}W(p_i-p_j,h) \tag {28}</script><p>&emsp;&emsp;其中的$s_{corr}$计算方式如下：</p>
<script type="math/tex; mode=display">
s_{corr}=-k(\frac{W(p_i-p_j,h)}{W(\Delta q,h)})^n \tag {29}</script><p>&emsp;&emsp;公式$(29)$中，$\Delta q$表示到粒子$i$的一个固定距离，通常取$|\Delta q|=0.1h,…,0.3h$，$h$即前面提到的光滑核半径。此外，公式中的$k$可以看作表面张力参数，取值$k=0.1$，而$n=4$。公式$(28)$中的排斥项会使得流体粒子的密度稍微低于静态密度，从而产生类似于表面张力的效果，使得流体表面的的粒子分布均匀。通过这个排斥项，我们不再需要硬性规定流体的邻居数量必须在30~40个，进一步提升算法的流体模拟效率。</p>
<h2 id="4、涡轮控制和人工粘性"><a href="#4、涡轮控制和人工粘性" class="headerlink" title="4、涡轮控制和人工粘性"></a>4、涡轮控制和人工粘性</h2><p>&emsp;&emsp;由于数值耗散，PBD的方法会引入额外的阻尼，使得整个系统的能量损耗太快，导致本来应该由的一些涡流细节迅速消失。在这里，PBF通过涡轮控制方法向整个系统重新注入能量：</p>
<script type="math/tex; mode=display">
f_i^{vorticity}=\epsilon (N\times \omega_i) \tag {30}</script><p>&emsp;&emsp;上述的公式中，$N=\frac{\eta}{|\eta|},\ \eta=\nabla|\omega|_i$，而流体粒子的旋度$\omega_i$计算公式如下：</p>
<script type="math/tex; mode=display">
\omega_i=\nabla\times v=\Sigma_j(v_j-v_i)\times \nabla_{p_j}W(p_i-p_j,h) \tag {31}</script><p>&emsp;&emsp;涡轮控制方法的基本思路就是：通过添加一个体积力$f_i^{vorticity}$（在算法的第一步），在旋度粒子（可直观理解为比周围粒子旋转快的粒子，旋度$\omega_i$指向粒子$i$的旋转轴）处加速粒子的旋转运动，通过这种方式来增加系统的旋度细节。公式$(30)$中的$\epsilon$用于控制涡轮控制力的强度。</p>
<p>&emsp;&emsp;最后，PBF方法采用XSPH的粘度方法直接更新速度，从而产生粘性阻尼。人工粘性除了可以增加模拟的数值稳定性，还可以消除非物理的流体振荡。拉格朗日流体模拟方法中，人工粘性本质上会对流体粒子的相对运动产生阻尼作用，使流体的动能转化为热能：</p>
<script type="math/tex; mode=display">
v_i^{new}=v_i+c\Sigma_j(v_i-v_j)\cdot W(p_i-p_j,h) \tag {32}</script><p>&emsp;&emsp;在流体模拟中，我们取公式$(32)$中的$c=0.01$。</p>
<h2 id="5、PBF算法"><a href="#5、PBF算法" class="headerlink" title="5、PBF算法"></a>5、PBF算法</h2><p>&emsp;&emsp;PBF算法的总体框架就是按照前面提到的PBD算法，只是经典PBD算法采用了顺序高斯-赛德尔（Sequential Gauss-Seidel，SGS）迭代求解，而SGS不容易被GPU并行化，因此基于CUDA实现的PBF求解器使用了雅克比（Jacobi）迭代方法并行求解。</p>
<p>&emsp;&emsp;PBF的算法伪代码如下所示：</p>
<script type="math/tex; mode=display">
\begin{align}
&1.\ forall\ \ particles\ \ i\ \ do\\

&2.\ \ \ \ \ apply\ \ force\ \ v_i\leftarrow v_i+\Delta tf_{ext}(x_i)\\

&3.\ \ \ \ \ predict\ \ position\ \ x_i^*\leftarrow x_i+\Delta t v_i\\

&4.\ endfor\\

&5.\ forall\ \ particles\ \ i\ \ do\\

&6.\ \ \ \ \ find\ \ neighboring\ \ particles\ \ N_i(x_i^*)\\

&7.\ endfor\\

&8.\ while\ \ iter\ \ <\ \ solverIterations\ \ do\\

&9.\ \ \ \ \ forall\ \ particles\ \ i\ \ do\\

&10.\ \ \ \ \ \ \ \ calculate\ \ \lambda_i\\\

&11.\ \ \ \ endfor\\

&12.\ \ \ \ forall\ \ particles\ \ i\ \ do\\

&13.\ \ \ \ \ \ \ \ calculate\ \ \Delta p_i\\

&14.\ \ \ \ \ \ \ \ perform\ \ collision\ \ detection\ \ and\ \ response\\

&15.\ \ \ \ endfor\\

&16.\ \ \ \ forall\ \ particles\ \ i\ \ do\\

&17.\ \ \ \ \ \ \ \ update\ \ position\ \ x_i^*\leftarrow x_i^*+\Delta p_i\\

&18.\ \ \ \ endfor\\

&19.endwhile\\

&20.forall\ \ particles\ \ i\ \ do\\

&21.\ \ \ \ update\ \ velocity\ \ v_i\leftarrow\frac1{\Delta t}(x_i^*-x_i)\\

&22.\ \ \ \ apply\ \ vorticity\ \ confinement\ \ and\ \ XSPH\ \ viscosity\\

&23.\ \ \ \ update\ \ position\ \ x_i\leftarrow x_i^*\\

&24.endfor
\end{align}</script><h1 id="三、流体模拟算法实现"><a href="#三、流体模拟算法实现" class="headerlink" title="三、流体模拟算法实现"></a>三、流体模拟算法实现</h1><p>&emsp;&emsp;在前面的理论讨论部分我们没有提到流体与固体边界的交互作用，实际上这对于流体模拟来说是非常重要，一般丰富的流体细节都要通过与刚体、软体以及其他流体的相互作用表现出来，目前我们仅考虑流体与刚体的交互效果。一般做刚体碰撞都是采用的射线与三角形求交，检测是否发生了穿透，然后根据交点修正物体的位置，从而表现出碰撞反弹的效果。这里我们并不采用这种方法，而是采用像流体一样的表示方法，将固体用一个一个粒子表示，流体与刚体的碰撞通过流体粒子与刚体粒子的属性作用间接地表现出来。这种方法非常自然，可以对任意形状的物体做碰撞， 只要将刚体表示成粒子表示，非常适用于在GPU上实现，当然缺点就是增大了内存开销。</p>
<p>&emsp;&emsp;加入了刚体边界粒子，在计算密度、拉格朗日乘子、流体密度约束的时候，我们就需要考虑刚体粒子对流体粒子这些属性的贡献。在计算流体密度时，公式变成如下：</p>
<script type="math/tex; mode=display">
\rho_i=\Sigma_jm_jW(x_i-x_j,h)+\Sigma_k\phi_{b_k}W(x_i-x_k,h) \tag {33}</script><p>&emsp;&emsp;可以看到，除了邻居的流体粒子，还加入了刚体刚体粒子的属性计算，即公式最右边的那一项，其中$\phi_{b_k}$计算如下：</p>
<script type="math/tex; mode=display">
\phi_{b_k}=\rho_0\frac{m_{b_k}}{\Sigma_lm_{b_l}W(x_k-x_l,h)} \tag {34}</script><p>&emsp;&emsp;对于流体粒子，我们可以把$\phi_{b_k}$看成是刚体粒子的质量，对于每一个固体粒子$b_k$，我们可以提前计算好它的$\phi_{b_k}$值，避免每一步的模拟都重新计算。同样地，计算拉格朗日乘子也要考虑刚体粒子的作用：</p>
<script type="math/tex; mode=display">
\lambda_i=-\frac{C_i(p_1,...,p_n)}{\Sigma_k|\nabla_{p_k}C_i|^2+\Sigma_l|\nabla_{p_l}C_i|^2+\epsilon}</script><p>&emsp;&emsp;最后，在做密度约束投影时，加入刚体粒子的贡献：</p>
<script type="math/tex; mode=display">
\Delta p_i=\frac{1}{\rho_0}\Sigma_j(\lambda_i+\lambda_j)\nabla_{p_i}W(r,h)
+\frac{1}{\rho_0}\Sigma_k\lambda_i\nabla_{p_i}W(r,h) \tag {35}</script><p>&emsp;&emsp;因为刚体粒子并没有流体的拉格朗日乘子，所以公式$(35)$中的刚体粒子项没有加上刚体粒子的拉格朗日乘子。接下来就是流体模拟算法的实现细节叙述，多线程库我采用了tbb。</p>
<h2 id="1、三次样条核函数"><a href="#1、三次样条核函数" class="headerlink" title="1、三次样条核函数"></a>1、三次样条核函数</h2><p>&emsp;&emsp;在计算流体密度时及其梯度时，我采用三次样条核函数：</p>
<script type="math/tex; mode=display">
W(r,h)=
\begin{cases}
\frac8{\pi h^3}(6\frac{|r|^3}{h^3}-6\frac{|r|^2}{h^2}+1)\\
\frac{16}{\pi h^3}(1-\frac{|r|}{h})^3 
\end{cases} \tag {36}</script><p>&emsp;&emsp;相应地，其梯度为：</p>
<script type="math/tex; mode=display">
\nabla W(r,h)=
\begin{cases}
\frac{48}{\pi h^3}(3(\frac{|r|}{h})^2-2(\frac{|r|}{h}))\frac{r}{h\cdot|r|}\\
\frac{48}{\pi h^3}(1-\frac{|r|}{h})^2(-\frac{r}{h|r|}) 
\end{cases} \tag {37}</script><p>&emsp;&emsp;故核函数的计算代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">real SPHKernels::poly6WKernel(<span class="keyword">const</span> glm::vec3 &amp; r)</span><br><span class="line">&#123;</span><br><span class="line">	real ret = <span class="number">0.0</span>;</span><br><span class="line">	real rl = glm::length(r);</span><br><span class="line">	real q = rl / m_radius;</span><br><span class="line">	real h3 = m_radius * m_radius * m_radius;</span><br><span class="line">	<span class="keyword">if</span> (q &lt;= <span class="number">0.5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		real q2 = q * q;</span><br><span class="line">		real q3 = q2 * q;</span><br><span class="line">		ret = <span class="number">8.0</span> / (M_PI * h3) * (<span class="number">6.0</span> * q3 - <span class="number">6.0</span> * q2 + <span class="number">1.0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ret = <span class="number">16.0</span> / (M_PI * h3) * <span class="built_in">pow</span>(<span class="number">1</span> - q, <span class="number">3.0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">glm::vec3 SPHKernels::spikyWKernelGrad(<span class="keyword">const</span> glm::vec3 &amp; r)</span><br><span class="line">&#123;</span><br><span class="line">	glm::<span class="function">vec3 <span class="title">ret</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">	real rl = glm::length(r);</span><br><span class="line">	real q = rl / m_radius;</span><br><span class="line">	real h3 = m_radius * m_radius * m_radius;</span><br><span class="line">	<span class="keyword">if</span> (rl &gt; <span class="number">1.0e-6</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> glm::vec3 gradq = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">1.0</span> / (rl * m_radius)) * r;</span><br><span class="line">		<span class="keyword">if</span> (q &lt;= <span class="number">0.5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ret = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">48.0</span> / (M_PI * h3) * q * (<span class="number">3.0</span> * q - <span class="number">2.0</span>)) * gradq;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			real factor = <span class="number">1.0</span> - q;</span><br><span class="line">			ret = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">48.0</span> / (M_PI * h3) * (-factor * factor)) * gradq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、粒子表示"><a href="#2、粒子表示" class="headerlink" title="2、粒子表示"></a>2、粒子表示</h2><p>&emsp;&emsp;在实现时，除了流体粒子，我们还要存储刚体粒子，但是刚体粒子又跟流体粒子稍微有点不同。刚体粒子的属性不需要每次重新计算，为此，我采用的方法是将流体粒子和刚体粒子统一存储，流体粒子在前面部分，刚体粒子在后面部分，这样可以通过索引下标判断当前是哪种粒子。</p>
<p>&emsp;&emsp;对于每一个粒子，我们需要存储它的质量、当前位置、上一次位置、静止时的位置、速度、加速度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticleGroup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt; m_masses;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt; m_invMasses;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_position;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_velocity;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_oldPosition;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_restPosition;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_lastPosition;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; m_acceleration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	.....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3、粒子领域搜索"><a href="#3、粒子领域搜索" class="headerlink" title="3、粒子领域搜索"></a>3、粒子领域搜索</h2><p>&emsp;&emsp;由前面的算法伪代码可以看到，在做流体约束投影之前，我们需要首先搜索每个粒子的邻居粒子。最简单暴力的方法是直接遍历每一个粒子，判断每一个粒子是否与当前的粒子相邻，这种算法的复杂度为$O(n^2)$（即对每一个粒子都要遍历$n$次），随着粒子数量的增多，搜索时间迅速增长。为此，我参考了<a href="https://github.com/InteractiveComputerGraphics/PositionBasedDynamics" target="_blank" rel="noopener">InteractiveComputerGraphics</a>的开源代码，采用一种<strong>空间哈希</strong>的算法，将算法的复杂度降低到$O(n)$。</p>
<p>&emsp;&emsp;每一个粒子都有它的位置向量$(x,y,z)$，我们将空间做一个网格分割，每个网格单元是边长为$e$的立方体，这样可以将整个三维空间都看成由一个一个网格单元的立方体构成（其实就是三维网格），每个单元按照立方体顶点位置最小的那个点做一个编号。那么如何知道每个粒子落在哪个网格呢？只需将粒子的位置向量除以网格单元边长即可，$(x/e,y/e,z/e)$就是粒子所在单元的编号，接下来有两种做法：一种就是根据$(x/e,y/e,z/e)$做一个随机哈希映射得到哈希索引值，将该粒子存储到哈希索引值指向的一个线性表；另一种方法是根据$(x/e,y/e,z/e)$直接按照某一个顺序存储到线性表中。显然前者会产生哈希冲突，故需要考虑冲突处理，这里我直接采用拉链法；而后者需要申请的存储空间依赖于包围盒的大小，而且一般情况下很多的存储空间都是没有粒子的。目前我采用前者的方法。每次我们存储到线性表中的是粒子的下标索引，避免大量的内存拷贝，因为这很耗时。</p>
<p>&emsp;&emsp;将每个粒子映射到一个线性表之后，我们就根据这个线性表获取每个粒子的邻居，此时我们只需查看粒子所在网格周围的$3\times 3\times 3=27$个网格，算法复杂度变为$O(27*n)=O(n)$。可以看到，这个算法思想很简单，而且效率很高。算法分成两个步骤，分别是粒子映射、邻域搜索。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NeighborSearch::neighborhoodSearch(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; particles,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;start, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> real factor = <span class="number">1.0</span> / m_cellGridSize;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> numParticles = particles.size();</span><br><span class="line">	m_neighbors.assign(numParticles, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="comment">// hash mapping.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; numParticles; ++x)</span><br><span class="line">	&#123;</span><br><span class="line">		glm::ivec3 cellPos;</span><br><span class="line">		cellPos.x = <span class="built_in">floor</span>(particles[x].x * factor) + <span class="number">1</span>;</span><br><span class="line">		cellPos.y = <span class="built_in">floor</span>(particles[x].y * factor) + <span class="number">1</span>;</span><br><span class="line">		cellPos.z = <span class="built_in">floor</span>(particles[x].z * factor) + <span class="number">1</span>;</span><br><span class="line">		SpatialCell *&amp;entry = m_spatialMap[&amp;cellPos];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (entry != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (entry-&gt;m_timeStamp != m_currentTimestamp)</span><br><span class="line">			&#123;</span><br><span class="line">				entry-&gt;m_timeStamp = m_currentTimestamp;</span><br><span class="line">				entry-&gt;m_particleIndices.clear();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			SpatialCell *newEntry = <span class="keyword">new</span> SpatialCell();</span><br><span class="line">			newEntry-&gt;m_particleIndices.reserve(m_maxParticlesPerCell);</span><br><span class="line">			newEntry-&gt;m_timeStamp = m_currentTimestamp;</span><br><span class="line">			entry = newEntry;</span><br><span class="line">		&#125;</span><br><span class="line">		entry-&gt;m_particleIndices.push_back(x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// hash lookup.</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> end = start + num;</span><br><span class="line">	parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(start, end, <span class="number">5000</span>),</span><br><span class="line">		[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int</span> cellPos1 = <span class="built_in">floor</span>(particles[x].x * factor);</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int</span> cellPos2 = <span class="built_in">floor</span>(particles[x].y * factor);</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int</span> cellPos3 = <span class="built_in">floor</span>(particles[x].z * factor);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">					&#123;</span><br><span class="line">						glm::ivec3 cellPos(cellPos1 + i, cellPos2 + j, cellPos3 + k);</span><br><span class="line">						SpatialCell * <span class="keyword">const</span> *entry = m_spatialMap.query(&amp;cellPos);</span><br><span class="line">						<span class="keyword">if</span> ((entry != <span class="literal">nullptr</span>) &amp;&amp; (*entry != <span class="literal">nullptr</span>) &amp;&amp;</span><br><span class="line">							((*entry)-&gt;m_timeStamp == m_currentTimestamp))</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> m = <span class="number">0</span>; m &lt; (*entry)-&gt;m_particleIndices.size(); ++m)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index = (*entry)-&gt;m_particleIndices[m];</span><br><span class="line">								<span class="comment">// not consider itself.</span></span><br><span class="line">								<span class="keyword">if</span> (index != x)</span><br><span class="line">								&#123;</span><br><span class="line">									<span class="keyword">const</span> real dist = glm::length(particles[x] - particles[index]);</span><br><span class="line">									<span class="keyword">if</span> (dist &lt; m_radius)</span><br><span class="line">									&#123;</span><br><span class="line">										m_neighbors[x].push_back(index);</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意，对于每个邻居网格的粒子我们还要判断一下目标粒子和当前粒子的距离，超过光滑核函数的半径不视为邻居粒子。采用的哈希映射函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> hashFunction&lt;glm::ivec3*&gt;(glm::ivec3* <span class="keyword">const</span> &amp;key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> p1 = <span class="number">73856093</span> * key-&gt;x;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> p2 = <span class="number">19349663</span> * key-&gt;y;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> p3 = <span class="number">83492791</span> * key-&gt;z;</span><br><span class="line">	<span class="keyword">return</span> p1 + p2 + p3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、密度计算"><a href="#4、密度计算" class="headerlink" title="4、密度计算"></a>4、密度计算</h2><p>&emsp;&emsp;根据前面我们提到的考虑了刚体粒子的密度公式$(33)$，密度计算的代码如下所示。注意neighbors并不包含自己在内，还要在最开始加入自己的密度。比较简单，不再赘述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PositionBasedFluids::computeFluidDensity(</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; particleIndex,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; numFluidParticle,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; position,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt;&amp; mass,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; neighbors,</span><br><span class="line">	<span class="keyword">const</span> real &amp; density0,</span><br><span class="line">	real &amp; density_err,</span><br><span class="line">	real &amp; density)</span><br><span class="line">&#123;</span><br><span class="line">	density = mass[particleIndex] * SPHKernels::getZeroWKenel();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; neighbors.size(); ++x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[x];</span><br><span class="line">		<span class="keyword">if</span> (neighborIndex &lt; numFluidParticle)</span><br><span class="line">		&#123;</span><br><span class="line">			density += mass[neighborIndex] * SPHKernels::poly6WKernel(</span><br><span class="line">				position[particleIndex] - position[neighborIndex]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			density += mass[neighborIndex] * SPHKernels::poly6WKernel(</span><br><span class="line">				position[particleIndex] - position[neighborIndex]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	density_err = <span class="built_in">std</span>::max(density, density0) - density0;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的流体密度计算过程中，将会用到刚体粒子的质量值，也就是前面提到的公式$(34)$，不需要每一步重新生成，只需初始时预先计算好即可。注意公式$(34)$的计算只涉及到刚体粒子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate boundary's properties.</span></span><br><span class="line"><span class="function">NeighborSearch <span class="title">neighborhood</span><span class="params">(nBoundaryParticles, m_sphRadius)</span></span>;</span><br><span class="line">neighborhood.neighborhoodSearch(boundaryParticles, <span class="number">0</span>, nBoundaryParticles);</span><br><span class="line">parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nBoundaryParticles, <span class="number">5000</span>),</span><br><span class="line">	[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;neighbors = neighborhood.getNeighbors(x);</span><br><span class="line">		real delta = SPHKernels::getZeroWKenel();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; neighbors.size(); ++y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[y];</span><br><span class="line">			delta += SPHKernels::poly6WKernel(boundaryParticles[x] </span><br><span class="line">				- boundaryParticles[neighborIndex]);</span><br><span class="line">		&#125;</span><br><span class="line">		delta = m_density0 / delta;</span><br><span class="line">		m_particles.setMass(x + nFluidPartiles, delta);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="5、拉格朗日乘子计算"><a href="#5、拉格朗日乘子计算" class="headerlink" title="5、拉格朗日乘子计算"></a>5、拉格朗日乘子计算</h2><p>&emsp;&emsp;前面我们在讨论PBF的约束时，采用了等式约束，也就是$C_i(p_1,…,p_n)=0$，当不等于0时我们就做约束投影进行位移修正。但当$C_i(p_1,…,p_n)&lt;0$即$\rho_i&lt;\rho_0$时没有必要做约束投影，这是因为当$\rho_i&lt;\rho_0$时，粒子之间距离比较远，从而使得计算出来得密度小于静止密度。直观理解就是只有在粒子靠得比较近的（流体被压缩了）时候才需要将粒子分开，从而使流体表现出不可压缩的特性。如下图所示：</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/6.jpg" width="60%"></div></p>
<p>&emsp;&emsp;所以我们对约束函数做了clamp操作，小于等于0一致当成等于0，具体看下面代码的第12行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PositionBasedFluids::computeLagrangeMultiplier(</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; particleIndex,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; numFluidParticle,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; position,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt;&amp; mass,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; neighbors,</span><br><span class="line">	<span class="keyword">const</span> real &amp; density,</span><br><span class="line">	<span class="keyword">const</span> real &amp; density0,</span><br><span class="line">	real &amp; lambda)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> real eps = <span class="number">1.0e-6</span>;</span><br><span class="line">	<span class="keyword">const</span> real constraint = <span class="built_in">std</span>::max(density / density0 - <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">	<span class="keyword">if</span> (constraint != <span class="number">0.0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		real sum_grad_cj = <span class="number">0.0</span>;</span><br><span class="line">		glm::<span class="function">vec3 <span class="title">grad_ci</span><span class="params">(<span class="number">0.0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; neighbors.size(); ++x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[x];</span><br><span class="line">			<span class="keyword">if</span> (neighborIndex &lt; numFluidParticle)</span><br><span class="line">			&#123;</span><br><span class="line">				glm::vec3 grad_cj = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(+mass[neighborIndex] / density0)</span><br><span class="line">					* SPHKernels::spikyWKernelGrad(position[particleIndex] - position[neighborIndex]);</span><br><span class="line">				sum_grad_cj += <span class="built_in">pow</span>(glm::length(grad_cj), <span class="number">2.0</span>);</span><br><span class="line">				grad_ci += grad_cj;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				glm::vec3 grad_cj = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(+mass[neighborIndex] / density0)</span><br><span class="line">					* SPHKernels::spikyWKernelGrad(position[particleIndex] - position[neighborIndex]);</span><br><span class="line">				sum_grad_cj += <span class="built_in">pow</span>(glm::length(grad_cj), <span class="number">2.0</span>);</span><br><span class="line">				grad_ci += grad_cj;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sum_grad_cj += <span class="built_in">pow</span>(glm::length(grad_ci), <span class="number">2.0</span>);</span><br><span class="line">		lambda = -constraint / (sum_grad_cj + eps);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		lambda = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、密度约束投影"><a href="#6、密度约束投影" class="headerlink" title="6、密度约束投影"></a>6、密度约束投影</h2><p>&emsp;&emsp;对于每一个粒子，我们根据前面计算得到的密度和拉格朗日乘子做约束投影，对应前面的公式$(35)$，密度约束投影得到的是一个用于后面做修正的位置偏移向量，从而使得粒子位移后依然满足约束条件，这就是约束投影的本质。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PositionBasedFluids::solveDensityConstraint(</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; particleIndex,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; numFluidParticle,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; position,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt;&amp; mass,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; neighbors,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;real&gt;&amp; lambda,</span><br><span class="line">	<span class="keyword">const</span> real &amp;sphRadius,</span><br><span class="line">	<span class="keyword">const</span> real &amp;density0,</span><br><span class="line">	glm::vec3 &amp;deltaPos)</span><br><span class="line">&#123;</span><br><span class="line">	deltaPos = glm::vec3(<span class="number">0.0f</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; neighbors.size(); ++x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[x];</span><br><span class="line">		<span class="keyword">if</span> (neighborIndex &lt; numFluidParticle)</span><br><span class="line">		&#123;</span><br><span class="line">			glm::vec3 grad_cj = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mass[neighborIndex] / density0) </span><br><span class="line">				* SPHKernels::spikyWKernelGrad(position[particleIndex] - position[neighborIndex]);</span><br><span class="line">			deltaPos += <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(lambda[particleIndex] + lambda[neighborIndex]) * grad_cj;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			glm::vec3 grad_cj = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mass[neighborIndex] / density0)</span><br><span class="line">				* SPHKernels::spikyWKernelGrad(position[particleIndex] - position[neighborIndex]);</span><br><span class="line">			deltaPos += <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(lambda[particleIndex]) * grad_cj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后我们按照算法伪代码的第8行到第19行的步骤将上述的三个步骤串联起来，迭代方法是雅可比迭代方式，按照先后顺序分别是密度计算、拉格朗日乘子计算、约束投影计算、位置修正。如下所示，在代码的第63行到第71行，我们根据约束投影计算得到的位移偏移量修正当前的粒子位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FluidModelSolver::constraintProjection()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> iter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nFluidParticles = m_lambda.size();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (iter &lt; m_maxIter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// calculate density and lagrange multiplier.</span></span><br><span class="line">		parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">1000</span>),</span><br><span class="line">			[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">			&#123;</span><br><span class="line">				real density_err;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;neighbors = m_neighborSearch-&gt;getNeighbors(x);</span><br><span class="line">				PositionBasedFluids::computeFluidDensity</span><br><span class="line">				(</span><br><span class="line">					x,</span><br><span class="line">					nFluidParticles,</span><br><span class="line">					m_particles.getPositionGroup(),</span><br><span class="line">					m_particles.getMassGroup(),</span><br><span class="line">					neighbors,</span><br><span class="line">					m_density0,</span><br><span class="line">					density_err,</span><br><span class="line">					m_density[x]</span><br><span class="line">				);</span><br><span class="line">				PositionBasedFluids::computeLagrangeMultiplier</span><br><span class="line">				(</span><br><span class="line">					x,</span><br><span class="line">					nFluidParticles,</span><br><span class="line">					m_particles.getPositionGroup(),</span><br><span class="line">					m_particles.getMassGroup(),</span><br><span class="line">					neighbors,</span><br><span class="line">					m_density[x],</span><br><span class="line">					m_density0,</span><br><span class="line">					m_lambda[x]</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// perform density constraint.</span></span><br><span class="line">		parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">1000</span>),</span><br><span class="line">			[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;neighbors = m_neighborSearch-&gt;getNeighbors(x);</span><br><span class="line">				PositionBasedFluids::solveDensityConstraint</span><br><span class="line">				(</span><br><span class="line">					x,</span><br><span class="line">					nFluidParticles,</span><br><span class="line">					m_particles.getPositionGroup(),</span><br><span class="line">					m_particles.getMassGroup(),</span><br><span class="line">					neighbors,</span><br><span class="line">					m_lambda,</span><br><span class="line">					m_sphRadius,</span><br><span class="line">					m_density0,</span><br><span class="line">					m_deltaPos[x]</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// add the delta position to particles' position.</span></span><br><span class="line">		parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">10000</span>),</span><br><span class="line">			[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">			&#123;</span><br><span class="line">				m_particles.getPosition(x) += m_deltaPos[x];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		++iter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、更新粒子速度"><a href="#7、更新粒子速度" class="headerlink" title="7、更新粒子速度"></a>7、更新粒子速度</h2><p>&emsp;&emsp;由前面的步骤我们得到了正确的粒子位置，接下来我们根据前一帧的位置和当前的粒子位置更新每个粒子的速度向量，这样就能得到正确的粒子速度向量。计算速度是直接根据速度的定义进行的，见下面代码里的velocityUpdateFirstOrder函数，注意这种方式计算速度只有一阶精度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// update velocities.</span></span><br><span class="line">	parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">5000</span>),</span><br><span class="line">		[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">		&#123;</span><br><span class="line">			PositionBasedFluids::velocityUpdateFirstOrder(</span><br><span class="line">				m_timeStep,</span><br><span class="line">				m_particles.getMass(x),</span><br><span class="line">				m_particles.getPosition(x),</span><br><span class="line">				m_particles.getOldPosition(x),</span><br><span class="line">				m_particles.getVelocity(x)</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PositionBasedFluids::velocityUpdateFirstOrder(</span><br><span class="line">	<span class="keyword">const</span> real &amp; h, </span><br><span class="line">	<span class="keyword">const</span> real &amp; mass,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; position,</span><br><span class="line">	<span class="keyword">const</span> glm::vec3 &amp; oldPosition,</span><br><span class="line">	glm::vec3 &amp; velocity)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (mass != <span class="number">0.0</span>)</span><br><span class="line">		velocity = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">1.0</span> / h) * (position - oldPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、旋度控制"><a href="#8、旋度控制" class="headerlink" title="8、旋度控制"></a>8、旋度控制</h2><p>&emsp;&emsp;接下来我们给流体加上旋度细节，它的基本思路就是：通过添加一个体积力$f_i^{vorticity}$，在旋度粒子（可直观理解为比周围粒子旋转快的粒子，旋度$\omega_i$指向粒子$i$的旋转轴）处加速粒子的旋转运动，通过这种方式来增加系统的旋度细节。这个我们在前面已经讨论过，旋度控制力的计算方式如下：</p>
<script type="math/tex; mode=display">
f_i^{vorticity}=\epsilon (N\times \omega_i) \\
\omega_i=\nabla\times v=\Sigma_j(v_j-v_i)\times \nabla_{p_j}W(p_i-p_j,h) \\
N=\frac{\eta}{|\eta|},\ \eta=\nabla|\omega|_i</script><p>&emsp;&emsp;关于这方面的内容，论文$[2]$的作者并没有作详细的说明，计算得到的旋度体积力$f_i^{vorticity}$如何作用到流体粒子上。所以我将计算得到的$f_i^{vorticity}$用于更新流体粒子的速度向量，感觉有点不太对劲，暂时先这样。代码见下面，首先计算流体的旋度向量，然后据此计算旋度体积力向量，最后给每个粒子加上在旋度体积力下的速度场偏移。代码不知道哪里有错，$\epsilon$一旦设置得有点大，整个流体就飞溅，很不正常。错误稍后再查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FluidModelSolver::computeVorticityConfinement()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nFluidParticles = m_lambda.size();</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> test = <span class="literal">true</span>;</span><br><span class="line">	glm::<span class="function">vec3 <span class="title">record</span><span class="params">(-FLT_MAX)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt; deltaVelocity(nFluidParticles, glm::vec3(<span class="number">0.0f</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; nFluidParticles; ++x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;neighbors = m_neighborSearch-&gt;getNeighbors(x);</span><br><span class="line">		glm::<span class="function">vec3 <span class="title">N</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">		glm::<span class="function">vec3 <span class="title">curl</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">		glm::<span class="function">vec3 <span class="title">curlX</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">		glm::<span class="function">vec3 <span class="title">curlY</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">		glm::<span class="function">vec3 <span class="title">curlZ</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">		<span class="keyword">const</span> glm::vec3 &amp;velocity_i = m_particles.getVelocity(x);</span><br><span class="line">		<span class="keyword">const</span> glm::vec3 &amp;position_i = m_particles.getPosition(x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; neighbors.size(); ++y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[y];</span><br><span class="line">			<span class="keyword">if</span> (neighborIndex &gt;= nFluidParticles)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">const</span> glm::vec3 velGap = m_particles.getVelocity(neighborIndex) - velocity_i;</span><br><span class="line">			curl += glm::cross(velGap, SPHKernels::spikyWKernelGrad(position_i - </span><br><span class="line">				m_particles.getPosition(neighborIndex)));</span><br><span class="line">			curlX += glm::cross(velGap, SPHKernels::spikyWKernelGrad(position_i + glm::vec3(<span class="number">0.01</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">				- m_particles.getPosition(neighborIndex)));</span><br><span class="line">			curlY += glm::cross(velGap, SPHKernels::spikyWKernelGrad(position_i + glm::vec3(<span class="number">0.0</span>, <span class="number">0.01</span>, <span class="number">0.0</span>)</span><br><span class="line">				- m_particles.getPosition(neighborIndex)));</span><br><span class="line">			curlZ += glm::cross(velGap, SPHKernels::spikyWKernelGrad(position_i + glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.01</span>)</span><br><span class="line">				- m_particles.getPosition(neighborIndex)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (glm::isnan(curl).x || glm::isnan(curl).y || glm::isnan(curl).z)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		real curlLen = glm::length(curl);</span><br><span class="line">		N.x = glm::length(curlX) - curlLen;</span><br><span class="line">		N.y = glm::length(curlY) - curlLen;</span><br><span class="line">		N.z = glm::length(curlZ) - curlLen;</span><br><span class="line">		N = glm::normalize(N);</span><br><span class="line">		<span class="keyword">if</span> (glm::isnan(N).x || glm::isnan(N).y || glm::isnan(N).z)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		glm::vec3 force = <span class="number">0.000010f</span> * glm::cross(N, curl);</span><br><span class="line">		deltaVelocity[x] = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(m_timeMgr-&gt;getTimeStepSize()) * force;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; nFluidParticles; ++x)</span><br><span class="line">	&#123;</span><br><span class="line">		m_particles.getVelocity(x) += deltaVelocity[x];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、流体粘性"><a href="#9、流体粘性" class="headerlink" title="9、流体粘性"></a>9、流体粘性</h2><p>&emsp;&emsp;然后就是人工粘性的计算，计算公式即前面讨论的公式$(32)$，如下所示。</p>
<script type="math/tex; mode=display">
v_i^{new}=v_i+c\Sigma_j(v_i-v_j)\cdot W(p_i-p_j,h)</script><p>&emsp;&emsp;其中的$c$就是流体的粘性系数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FluidModelSolver::computeXSPHViscosity()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nFluidParticles = m_lambda.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; nFluidParticles; ++x)</span><br><span class="line">	&#123;</span><br><span class="line">		glm::vec3 &amp;velocity = m_particles.getVelocity(x);</span><br><span class="line">		<span class="keyword">const</span> glm::vec3 &amp;position = m_particles.getPosition(x);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;neighbors = m_neighborSearch-&gt;getNeighbors(x);</span><br><span class="line">		glm::<span class="function">vec3 <span class="title">sum_value</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; neighbors.size(); ++y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> neighborIndex = neighbors[y];</span><br><span class="line">			<span class="keyword">if</span> (neighborIndex &lt; nFluidParticles)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">const</span> real density_j = m_density[neighborIndex];</span><br><span class="line">				<span class="keyword">const</span> glm::vec3 &amp;position_j = m_particles.getPosition(neighborIndex);</span><br><span class="line">				<span class="keyword">const</span> glm::vec3 &amp;velocity_j = m_particles.getVelocity(neighborIndex);</span><br><span class="line">				glm::vec3 tmp = velocity - velocity_j;</span><br><span class="line">				tmp *= SPHKernels::poly6WKernel(position - position_j) </span><br><span class="line">					* (m_particles.getMass(neighborIndex) / density_j);</span><br><span class="line">				sum_value -= tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sum_value *= m_viscosity;</span><br><span class="line">		m_particles.setVelocity(x, velocity + sum_value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10、流体模拟"><a href="#10、流体模拟" class="headerlink" title="10、流体模拟"></a>10、流体模拟</h2><p>&emsp;&emsp;最后就是将以上的步骤串联起来，构成模拟一帧流体的全部步骤，代码如下所示，对应了前面PBF的伪代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FluidModelSolver::simulate()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nFluidParticles = m_lambda.size();</span><br><span class="line">	<span class="keyword">const</span> real m_timeStep = m_timeMgr-&gt;getTimeStepSize();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gravity acceleration.</span></span><br><span class="line">	clearAccelerations();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update time step size by CFL condition</span></span><br><span class="line">	updateTimeStepSizeCFL(<span class="number">0.0001</span>, <span class="number">0.005</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// predict particles' position and velocity.</span></span><br><span class="line">	parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">5000</span>),</span><br><span class="line">		[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">		&#123;</span><br><span class="line">			m_deltaPos[x] = glm::vec3(<span class="number">0.0</span>);</span><br><span class="line">			m_particles.setLastPosition(x, m_particles.getOldPosition(x));</span><br><span class="line">			m_particles.setOldPosition(x, m_particles.getPosition(x));</span><br><span class="line">			PositionBasedFluids::semiImplicitEuler(</span><br><span class="line">				m_timeStep,</span><br><span class="line">				m_particles.getMass(x),</span><br><span class="line">				m_particles.getPosition(x),</span><br><span class="line">				m_particles.getVelocity(x),</span><br><span class="line">				m_particles.getAcceleration(x));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// search each particle's neighborhood.</span></span><br><span class="line">	m_neighborSearch-&gt;neighborhoodSearch(m_particles.getPositionGroup(),</span><br><span class="line">		<span class="number">0</span>, nFluidParticles);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// perform density constraint.</span></span><br><span class="line">	constraintProjection();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// update velocities.</span></span><br><span class="line">	parallel_for(blocked_range&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>, nFluidParticles, <span class="number">5000</span>),</span><br><span class="line">		[&amp;](blocked_range&lt;<span class="keyword">size_t</span>&gt; &amp;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> x = r.begin(); x != r.end(); ++x)</span><br><span class="line">		&#123;</span><br><span class="line">			PositionBasedFluids::velocityUpdateFirstOrder(</span><br><span class="line">				m_timeStep,</span><br><span class="line">				m_particles.getMass(x),</span><br><span class="line">				m_particles.getPosition(x),</span><br><span class="line">				m_particles.getOldPosition(x),</span><br><span class="line">				m_particles.getVelocity(x)</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// compute viscoity.</span></span><br><span class="line">	computeXSPHViscosity();</span><br><span class="line">	computeVorticityConfinement();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// update time stamp.</span></span><br><span class="line">	m_neighborSearch-&gt;updateTimestamp();</span><br><span class="line">	m_timeMgr-&gt;setTime(m_timeMgr-&gt;getTime() + m_timeStep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、实现效果"><a href="#四、实现效果" class="headerlink" title="四、实现效果"></a>四、实现效果</h1><p>&emsp;&emsp;目前尚未了解流体渲染，所以只是简单地将流体粒子绘制出来，查看模拟的效果如何。绘制API采用了OpenGL的实例化渲染，UI界面则是接用的ImGui库。测试的场景是一个长方体的流体落下来，碰撞到盒子边界。</p>
<p>&emsp;&emsp;这是初始的流体块，长方体形状</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/7.png" width="60%"></div></p>
<p>&emsp;&emsp;然后是容器边界，如下所示，它将流体包含在内，也是采用粒子的形式表示。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/8.png" width="60%"></div></p>
<p>&emsp;&emsp;初始时由于重力加速度的作用，流体将落下来，碰撞到容器边界，然后流体翻滚，最终经过一段时间后趋于平静。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret1.png" width="60%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret2.png" width="60%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret3.png" width="60%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret4.png" width="60%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret5.png" width="60%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret6.png" width="60%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret7.png" width="60%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.12/blog/PositionBasedFluid/ret8.png" width="60%"></div></p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>$[1]$ Müller, Matthias, et al. “Position based dynamics.” Journal of Visual Communication and Image Representation 18.2 (2007): 109-118.</p>
<p>$[2]$ Macklin, Miles, and Matthias Müller. “Position based fluids.” ACM Transactions on Graphics (TOG) 32.4 (2013): 104.</p>
<p>$[3]$ M¨ULLER, M., CHARYPAR, D., AND GROSS, M. 2003. Particlebased fluid simulation for interactive applications. In Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation, Eurographics Association, Aire-la-Ville, Switzerland, Switzerland, SCA ’03, 154–159.</p>
<p>$[4]$ Akinci, Nadir, et al. “Versatile rigid-fluid coupling for incompressible SPH.” ACM Transactions on Graphics (TOG) 31.4 (2012): 62.</p>
<p>$[5]$ <a href="https://zhuanlan.zhihu.com/p/48737753" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/48737753</a></p>
<p>$[6]$ <a href="https://zhuanlan.zhihu.com/p/49536480" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49536480</a></p>

        </div>
        
          


  <section class="meta" id="footer-meta">
    <hr>
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-06-26T09:48:47+08:00">
  <a class="notlink">
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>最后更新于 2019年6月26日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Computer-Graphics/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Computer Graphics</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Fluid-Simulation/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Fluid Simulation</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Position-Based-Dynamics/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Position Based Dynamics</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yangwc.com/2019/06/04/PositionBasedFluid/&title=流体模拟Fluid Simulation：Position Based Fluid | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本篇文章主要是关于Position Based Dynamics的流体模拟方法，这类方法依旧采用基于拉格朗日的视角，把流体看成由一个一个粒子组成，易于并行化，适用于实时的流体模拟。目前实现的只是CPU版本，考虑在后面利用cuda挪到GPU上做模拟计算。相关的完整代码请看这里。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://yangwc.com/2019/06/04/PositionBasedFluid/&title=流体模拟Fluid Simulation：Position Based Fluid | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本篇文章主要是关于Position Based Dynamics的流体模拟方法，这类方法依旧采用基于拉格朗日的视角，把流体看成由一个一个粒子组成，易于并行化，适用于实时的流体模拟。目前实现的只是CPU版本，考虑在后面利用cuda挪到GPU上做模拟计算。相关的完整代码请看这里。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=https://yangwc.com/2019/06/04/PositionBasedFluid/&title=流体模拟Fluid Simulation：Position Based Fluid | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本篇文章主要是关于Position Based Dynamics的流体模拟方法，这类方法依旧采用基于拉格朗日的视角，把流体看成由一个一个粒子组成，易于并行化，适用于实时的流体模拟。目前实现的只是CPU版本，考虑在后面利用cuda挪到GPU上做模拟计算。相关的完整代码请看这里。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                            <h4>
                                <a href="/2019/06/11/Voxelization/" rel="prev" title="体素化Voxelization：基于GPU的三维体素化">
                                  
                                      体素化Voxelization：基于GPU的三维体素化
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Voxelization/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Voxelization</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2019/05/23/RayTracer-Advance/" rel="prev" title="光线追踪器Ray Tracer：进阶篇">
                                    
                                        光线追踪器Ray Tracer：进阶篇
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Ray-Tracer/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Ray Tracer</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
        <section id="comments">
          <div id="lv-container" data-id="city" data-uid="MTAyMC80MzkxOS8yMDQ1NQ==">
            <noscript><div><i class="fas fa-exclamation-triangle">&nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。</i></div></noscript>
          </div>
        </section>
      
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

  <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



  <script>
    window.subData = {
      title: '流体模拟Fluid Simulation：Position Based Fluid',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content material">
    
      <div class="avatar">
        <fancybox><img class="avatar" src="/image/avator.jpg"></fancybox>
      </div>
    
    
      <div class="text">
        
          <h2>YangWC</h2>
        
        
          <p>A student from Sun Yat-sen University.</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget toc-wrapper">
    
<header class="material">
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class="content material">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、基于位置动力学的物理模拟"><span class="toc-text">一、基于位置动力学的物理模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、基于位置动力学的模拟算法"><span class="toc-text">1、基于位置动力学的模拟算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、约束投影步骤"><span class="toc-text">2、约束投影步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、约束投影求解器"><span class="toc-text">3、约束投影求解器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、基于位置动力学的流体模拟"><span class="toc-text">二、基于位置动力学的流体模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、不可压缩约束"><span class="toc-text">1、不可压缩约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、混合约束"><span class="toc-text">2、混合约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、拉伸不稳定性"><span class="toc-text">3、拉伸不稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、涡轮控制和人工粘性"><span class="toc-text">4、涡轮控制和人工粘性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、PBF算法"><span class="toc-text">5、PBF算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、流体模拟算法实现"><span class="toc-text">三、流体模拟算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、三次样条核函数"><span class="toc-text">1、三次样条核函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、粒子表示"><span class="toc-text">2、粒子表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、粒子领域搜索"><span class="toc-text">3、粒子领域搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、密度计算"><span class="toc-text">4、密度计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、拉格朗日乘子计算"><span class="toc-text">5、拉格朗日乘子计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、密度约束投影"><span class="toc-text">6、密度约束投影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、更新粒子速度"><span class="toc-text">7、更新粒子速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、旋度控制"><span class="toc-text">8、旋度控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、流体粘性"><span class="toc-text">9、流体粘性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10、流体模拟"><span class="toc-text">10、流体模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、实现效果"><span class="toc-text">四、实现效果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料："><span class="toc-text">参考资料：</span></a></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class="widget plain">
  
<header class="material">
  <div><i class=" fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;欢迎来到YangWC的博客</div>
  
</header>

  <div class="content material">
    <p>本站会记录自己的一些学习内容，如若有错或者乱码，欢迎指正，感谢!</p>

  </div>
</section>

          
        
      
        
          
          
            <section class="widget grid">
  
<header class="material">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content material">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于博主
        </a></li>
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn" rel="nofollow" href="/categories/" title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/2D-Rendering/" href="/categories/2D-Rendering/"><div class="name">2D Rendering</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Computer-Graphics/" href="/categories/Computer-Graphics/"><div class="name">Computer Graphics</div><div class="badge">(34)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-Simulation/" href="/categories/Fluid-Simulation/"><div class="name">Fluid Simulation</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-simulation/" href="/categories/Fluid-simulation/"><div class="name">Fluid  simulation</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Image-processing/" href="/categories/Image-processing/"><div class="name">Image processing</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/N-body/" href="/categories/N-body/"><div class="name">N-body</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physical-simulation/" href="/categories/Physical-simulation/"><div class="name">Physical simulation</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physically-Based-Rendering/" href="/categories/Physically-Based-Rendering/"><div class="name">Physically Based Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Position-Based-Dynamics/" href="/categories/Position-Based-Dynamics/"><div class="name">Position Based Dynamics</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Ray-Tracer/" href="/categories/Ray-Tracer/"><div class="name">Ray Tracer</div><div class="badge">(10)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Real-time-Rendering/" href="/categories/Real-time-Rendering/"><div class="name">Real-time Rendering</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Soft-Renderer/" href="/categories/Soft-Renderer/"><div class="name">Soft Renderer</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Voxelization/" href="/categories/Voxelization/"><div class="name">Voxelization</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class="widget tagcloud">
    
<header class="material">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn" rel="nofollow" href="/tags/" title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <a href="/tags/2D-Rendering/" style="font-size: 14px; color: #bbb">2D Rendering</a> <a href="/tags/3D-Math/" style="font-size: 14px; color: #bbb">3D Math</a> <a href="/tags/3D-pipeline/" style="font-size: 16px; color: #c9c9c9">3D pipeline</a> <a href="/tags/Advection/" style="font-size: 14px; color: #bbb">Advection</a> <a href="/tags/Computer-Graphics/" style="font-size: 24px; color: #fff">Computer Graphics</a> <a href="/tags/Fluid-Simulation/" style="font-size: 22px; color: #f1f1f1">Fluid Simulation</a> <a href="/tags/Fluid-simulation/" style="font-size: 14px; color: #bbb">Fluid simulation</a> <a href="/tags/Glow-effect/" style="font-size: 14px; color: #bbb">Glow effect</a> <a href="/tags/Image-processing/" style="font-size: 14px; color: #bbb">Image processing</a> <a href="/tags/N-body/" style="font-size: 14px; color: #bbb">N-body</a> <a href="/tags/Naiver-Stokes-Equations/" style="font-size: 14px; color: #bbb">Naiver-Stokes Equations</a> <a href="/tags/Physical-simulation/" style="font-size: 14px; color: #bbb">Physical simulation</a> <a href="/tags/Physically-Based-Rendering/" style="font-size: 16px; color: #c9c9c9">Physically Based Rendering</a> <a href="/tags/Position-Based-Dynamics/" style="font-size: 18px; color: #d6d6d6">Position Based Dynamics</a> <a href="/tags/Rasterization/" style="font-size: 14px; color: #bbb">Rasterization</a> <a href="/tags/Ray-Tracer/" style="font-size: 22px; color: #f1f1f1">Ray Tracer</a> <a href="/tags/Real-time-Rendering/" style="font-size: 20px; color: #e4e4e4">Real-time Rendering</a> <a href="/tags/Soft-Renderer/" style="font-size: 20px; color: #e4e4e4">Soft Renderer</a> <a href="/tags/Voxelization/" style="font-size: 14px; color: #bbb">Voxelization</a>
    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
	<script>
		var now = new Date(); 
		function createtime() { 
			var grt= new Date("04/24/2019 18:00:00");//在此处修改你的建站时间
			now.setTime(now.getTime()+250); 
			days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
			hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
			if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
			mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
			seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
			snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
			document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
			document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
		} 
	setInterval("createtime()",250);
   </script>
   
   <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->
	
	
	<script>setLoadingBarProgress(80);</script>
</footer>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>









  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>






  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  
    <!--数字雨背景-->
  <canvas id="canvas" width="1440" height="900" ></canvas>
  <script>
	var s = window.screen;
	var width = canvas.width = s.width;
	var height = canvas.height = s.height;
	var fontSize = 13;
	var colunms = Math.floor(width/fontSize);
	var letters = [];
    for(var i=0;i<colunms;i++){
        letters.push(1);
    }
	var draw = function () {
	    canvas.getContext('2d').fillStyle = "rgba(0,0,0,.08)";//遮盖层
		canvas.getContext('2d').fillRect(0,0,width,height);
		canvas.getContext('2d').font = "700 " + fontSize +"px  微软雅黑";
		letters.map(function(y_pos, index){
		text = String.fromCharCode(34+Math.random()*33);
		x_pos = index * fontSize;
		canvas.getContext('2d').fillText(text, x_pos, y_pos);
		letters[index] = (y_pos > 758 + Math.random() * 1e4) ? 0 : y_pos + 10;
		canvas.getContext('2d').fillStyle='#'+letters[index];
	  });
	};
	setInterval(draw, 33);
  </script>
  
  <!-- 页面点击出现文字 -->
  <script type="text/javascript" src="/js/ClickShowText.js"></script>
  
  <script>setLoadingBarProgress(100);</script>
</body>
</html>
