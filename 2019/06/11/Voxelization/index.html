<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>体素化Voxelization：基于GPU的三维体素化 | YangWC&#39;s Blog</title>
  
  
  <meta name="description" content="Personal blog website.">
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1//globalImage/logo.ico">
  

  
    <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fdf716664defeee80e01568ddbeb2425";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
  
</head>
<body>
  
  
  <header class="l_header material">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="material"></div>
  </div>

	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          YangWC's Blog
        
      </a>
			<div class="menu navgation">
				<ul class="h-list">
          
  					
  						<li>
								<a class="nav flat-box" href="/" id="home">
									<i class="fas fa-grin fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
									<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
									<i class="fas fa-tag fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
									<i class="fas fa-info-circle fa-fw"></i>&nbsp;关于博主
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
        
          <li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/" id="home">
								<i class="fas fa-grin fa-fw"></i>&nbsp;主页
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/" rel="nofollow" id="archives">
								<i class="fas fa-archive fa-fw"></i>&nbsp;归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/categories/" rel="nofollow" id="categories">
								<i class="fas fa-folder-open fa-fw"></i>&nbsp;分类
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/tags/" rel="nofollow" id="tags">
								<i class="fas fa-tag fa-fw"></i>&nbsp;标签
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/" rel="nofollow" id="about">
								<i class="fas fa-info-circle fa-fw"></i>&nbsp;关于博主
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      <div class="l_main">
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/06/11/Voxelization/">
        体素化Voxelization：基于GPU的三维体素化
      </a>
    </h1>
  


      
      <div class="new-meta-box">
        
          
        
          
            
  <div class="new-meta-item author">
    <a href="http://yoursite.com" rel="nofollow">
      
        <img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png">
      
      <p>WC Yang</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-06-11</p>
  </a>
</div>

          
        
          
            
  
  <div class="new-meta-item category">
    <a href="/categories/Voxelization/" rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Computer Graphics&nbsp;/&nbsp;Position Based Dynamics&nbsp;/&nbsp;Voxelization</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p>本篇文章主要是关于三维网格模型的基于GPU并行的体素化算法，这个算法我是偶然从NVIDIA官网上看到的。基于GPU的体素化算法巧妙地借助了渲染流程的光栅化处理，将整个体素化的过程并行化，速度极快，缺点就是占用的内存较高。相关的完整代码请看<a href="https://github.com/ZeusYang/PositionBasedFluid" target="_blank" rel="noopener">这个链接</a>中的Renderer目录下的Voxelization.h文件和Voxelization.cpp文件。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/header.png" width="70%"></div></p>
<a id="more"></a>
<ul>
<li>体素化</li>
<li>修补裂缝</li>
<li>修补孔洞</li>
<li>参考资料</li>
</ul>
<p>&emsp;&emsp;<strong>在基于位置动力学的物理模拟中，所有要模拟的物体都由一组粒子来表示，每个粒子都是一个给定半径大小的球体，对于固体这类的物体，粒子通常是紧密相连的。为此，为了实现基于位置动力学的物理模拟，我们需要采用一种算法将网格物体的三角网格模型用一个个粒子表示</strong>，这个并不是简单地取网格模型的所有顶点就行，因为我们需要紧密连接的粒子，面片网格模型的顶点通常是稀疏的。这个过程其实就是体素化，三维体素是二维像素的三维扩展，体素的基本单元不再是二维的正方形，而是三维的立方体，立方体的边长决定了体素化的分辨率，通常边长越长，则分辨率越低。将网格体素化后我们得到了一组体素的中心顶点位置，可将其用于后续的基于位置动力学的物理模拟当中。</p>
<p>&emsp;&emsp;目前常用的体素化方法大都是基于CPU的，这类方法通常是将射线与物体求交，根据是奇数个交点还是偶数个交点来判断当前的体素是否在物体的内部。在没有采用特殊的数据结构时，每次求交都要遍历一次网格模型的所有三角形，效率非常低。在采用了八叉树加速之后，速度有所提升，但随着模型的三角形面片数增加，串行的体素化算法耗费的时间越来越长。我没有采用CPU串行的体素化方法，而是采用了基于GPU并行的体素化算法，这个算法我是偶然从NVIDIA官网上看到的。基于GPU的体素化算法巧妙地借助了渲染流程的光栅化处理，将整个体素化的过程并行化，速度极快，缺点就是占用的内存较高。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/1.jpg" width="60%"><br>    <center> 图1 三维体素模型 </center></div></p>
<h1 id="一、体素化"><a href="#一、体素化" class="headerlink" title="一、体素化"></a>一、体素化</h1><p>&emsp;&emsp;基于GPU的三维体素化大致思想就是：首先计算出需要体素化模型的AABB包围盒，然后将模型投影到AABB包围盒的某个平面上，经过渲染管线的光栅化插值操作，我们可以在片元着色器得到每个像素点对应的世界空间的顶点坐标，根据这个顶点坐标标记三维空间数组（这个三维空间数组就是根据体素划分的空间序列）的相应位置，最后在CPU端读出这个三维空间数组，若当前的数组位置有标记，则将该数组位置对应的立方体作为一个体素。可以看到，整个流程思路非常清晰，但是还需要借助一些手段修正算法存在的缺陷，这个在后面会提到。</p>
<p>&emsp;&emsp;首先就是计算网格模型的AABB包围盒，在导入模型时获取$x$、$y$、$z$轴分量的最大值和最小值，从而得到包围盒的最大顶点和最小顶点。这个比较简单，不再赘述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bounding box.</span></span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].x &lt; m_min.x)</span><br><span class="line">	m_min.x = mesh-&gt;mVertices[x].x;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].y &lt; m_min.y)</span><br><span class="line">	m_min.y = mesh-&gt;mVertices[x].y;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].z &lt; m_min.z)</span><br><span class="line">	m_min.z = mesh-&gt;mVertices[x].z;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].x &gt; m_max.x)</span><br><span class="line">	m_max.x = mesh-&gt;mVertices[x].x;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].y &gt; m_max.y)</span><br><span class="line">	m_max.y = mesh-&gt;mVertices[x].y;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;mVertices[x].z &gt; m_max.z)</span><br><span class="line">	m_max.z = mesh-&gt;mVertices[x].z;</span><br></pre></td></tr></table></figure>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/2.png" width="60%"></div></p>
<center> 图2 模型包围盒 </center>


<p>&emsp;&emsp;获取了模型的包围盒之后，我们就需要根据这个包围盒设置我们的观察角度和投影平面，这关系到后面的体素化结果。同时为了保证正确地体素化模型，我们采用的投影方式是<strong>正交投影</strong>。首先我们要选择一个观察方向和投影平面，AABB包围盒有六个面，其中前和后、上和下、左和右的投影结果是一样的，因此实际的选择只有三个平面，分别是前、上、右（或者后、下、左）。显然一个物体投影到这个三个平面上的结果都不一样，目前我们暂时先选择投影到前面这个平面上，摄像机的视线朝向z轴的负方向。注意正确地设置摄像机的位置，否则什么看不到。既然我们选择投影到前面这个平面上，我们就设置摄像机的位置在包围盒前面这个平面的中心再往前一点。同时了为了确保模型全部投影到屏幕上，我们设置的正交投影平面比选定的包围盒平面稍微大一点点。具体代码如下所示：</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/4.png" width="60%"></div></p>
<center> 图3 三个面上的投影结果 </center>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bounding box and resolution.</span></span><br><span class="line">glm::vec3 min, max;</span><br><span class="line">glm::ivec3 resolution;</span><br><span class="line">target-&gt;getAABB(min, max);</span><br><span class="line"></span><br><span class="line">glm::<span class="function">vec3 <span class="title">range</span><span class="params">(max.x - min.x, max.y - min.y, max.z - min.z)</span></span>;</span><br><span class="line">resolution.x = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.x / step);</span><br><span class="line">resolution.y = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.y / step);</span><br><span class="line">resolution.z = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.z / step);</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(resolution.x * resolution.y * resolution.z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// camera</span></span><br><span class="line">glm::vec3 cameraPos;</span><br><span class="line">cameraPos.x = (min.x + max.x) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPos.y = (min.y + max.y) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPos.z = max.z + <span class="number">0.2f</span>;</span><br><span class="line">FPSCamera::<span class="function">ptr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> FPSCamera(cameraPos))</span></span>;</span><br><span class="line">camera-&gt;lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>));</span><br><span class="line">camera-&gt;setOrthographicProject(-range.x * <span class="number">0.51</span>, +range.x * <span class="number">0.51</span>, -range.y * <span class="number">0.51</span>, +range.y * <span class="number">0.51</span>, <span class="number">0.1</span>, range.z * <span class="number">1.2f</span> + <span class="number">0.2f</span>);</span><br></pre></td></tr></table></figure>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/3.png" width="60%"></div></p>
<center> 图4 包围盒投影平面 </center>


<p>&emsp;&emsp;设置好投影矩阵和视图矩阵之后，我们需要申请一个着色器可写的缓冲，这个缓冲的大小等于AABB包围盒的分辨率，在片元着色器阶段我们需要根据当前片元的世界空间位置对这个缓冲做标记，表示该缓冲位置上有一个体素。我们采用OpenGL的GL_SHADER_STORAGE_BUFFER，这是一个着色器可读写的缓冲类型。申请缓冲之后，将缓冲全部初始化为0。然后将需要体素化的网格模型送入渲染管线进行渲染。在片元着色器中，将每个片元的世界空间位置对应的缓冲位置加1。最后在CPU端读出缓冲内容，缓冲值大于0时，则表示该位置有一个体素。CPU端的整个流程代码如下所示。这里需要特别注意的是，我们应该关闭深度测试和背面剔除，保证模型的全面三角形都进入片元着色器，确保所有的三角形不被剔除，从而使得全部的三角形都被处理，最后得到正确的体素化结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Voxelization::voxelize(Drawable* target, <span class="keyword">const</span> <span class="keyword">float</span> &amp; step, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;glm::vec3&gt;&amp; ret)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// shader</span></span><br><span class="line">	ShaderMgr::ptr shaderMgr = ShaderMgr::getSingleton();</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> voxelizeCount = shaderMgr-&gt;loadShader(<span class="string">"voxelizeCount"</span>,</span><br><span class="line">		<span class="string">"./glsl/voxelizeCount.vert"</span>, <span class="string">"./glsl/voxelizeCount.frag"</span>);</span><br><span class="line">	Shader::ptr shader = shaderMgr-&gt;getShader(voxelizeCount);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// bounding box and resolution.</span></span><br><span class="line">	glm::vec3 min, max;</span><br><span class="line">	glm::ivec3 resolution;</span><br><span class="line">	target-&gt;getAABB(min, max);</span><br><span class="line"></span><br><span class="line">	glm::<span class="function">vec3 <span class="title">range</span><span class="params">(max.x - min.x, max.y - min.y, max.z - min.z)</span></span>;</span><br><span class="line">	resolution.x = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.x / step) + <span class="number">1</span>;</span><br><span class="line">	resolution.y = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.y / step) + <span class="number">1</span>;</span><br><span class="line">	resolution.z = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(range.z / step) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(resolution.x * resolution.y * resolution.z);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// camera</span></span><br><span class="line">	glm::vec3 cameraPos;</span><br><span class="line">	cameraPos.x = (min.x + max.x) * <span class="number">0.5f</span>;</span><br><span class="line">	cameraPos.y = (min.y + max.y) * <span class="number">0.5f</span>;</span><br><span class="line">	cameraPos.z = max.z + <span class="number">0.2f</span>;</span><br><span class="line">	FPSCamera::<span class="function">ptr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> FPSCamera(cameraPos))</span></span>;</span><br><span class="line">	camera-&gt;lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>));</span><br><span class="line">	camera-&gt;setOrthographicProject(-range.x * <span class="number">0.51</span>, +range.x * <span class="number">0.51</span>, -range.y * <span class="number">0.51</span>, +range.y * <span class="number">0.51</span>, <span class="number">0.1</span>, range.z * <span class="number">1.2f</span> + <span class="number">0.2f</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// polygon mode.</span></span><br><span class="line">	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</span><br><span class="line">	glDisable(GL_CULL_FACE);</span><br><span class="line">	glDisable(GL_DEPTH_TEST);</span><br><span class="line">	glClearColor(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate ssbo.</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;m_cntBuffer);</span><br><span class="line">	glBindBuffer(GL_SHADER_STORAGE_BUFFER, m_cntBuffer);</span><br><span class="line">	glBufferData(GL_SHADER_STORAGE_BUFFER, length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="literal">nullptr</span>, GL_STATIC_DRAW);</span><br><span class="line">	glBindBufferBase(GL_SHADER_STORAGE_BUFFER, <span class="number">0</span>, m_cntBuffer);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// bind shader and ssbo.</span></span><br><span class="line">	shader-&gt;bind();</span><br><span class="line">	shader-&gt;setVec3(<span class="string">"boxMin"</span>, min);</span><br><span class="line">	shader-&gt;setFloat(<span class="string">"step"</span>, step);</span><br><span class="line">	shader-&gt;setVec3(<span class="string">"resolution"</span>, resolution);</span><br><span class="line">	<span class="keyword">int</span> *writePtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(glMapBuffer(GL_SHADER_STORAGE_BUFFER, GL_WRITE_ONLY));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; length; ++x)</span><br><span class="line">	&#123;</span><br><span class="line">		writePtr[x] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!glUnmapBuffer(GL_SHADER_STORAGE_BUFFER))</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"unMap error\n"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// draw and count.</span></span><br><span class="line">	target-&gt;render(camera, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, shader);</span><br><span class="line">	glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get count buffer.</span></span><br><span class="line">	glBindBuffer(GL_SHADER_STORAGE_BUFFER, m_cntBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *readPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(glMapBuffer(GL_SHADER_STORAGE_BUFFER, GL_READ_ONLY));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (readPtr != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; length; ++x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*(readPtr + x) != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> iy = x / (resolution.x * resolution.z);</span><br><span class="line">				<span class="keyword">int</span> iz = (x - iy * resolution.x * resolution.z) / (resolution.x);</span><br><span class="line">				<span class="keyword">int</span> ix = x - iy * resolution.x * resolution.z - iz * resolution.x;</span><br><span class="line">				ret.push_back(min + glm::vec3(ix * step, iy * step, iz * step));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr error!\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glUnmapBuffer(m_cntBuffer);</span><br><span class="line">	glBindBuffer(GL_SHADER_STORAGE_BUFFER, <span class="number">0</span>);</span><br><span class="line">	glDeleteBuffers(<span class="number">1</span>, &amp;m_cntBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来就需要在着色器中做一些操作。首先是顶点着色器，在顶点着色器中并没有什么复杂的操作，我们需要将当前的顶点位置传到片元着色器，借助渲染管线的光栅化功能，从而在片元着色器中得到每个片元对应的世界空间位置。下面顶点着色器的代码，其余部分乘上视图矩阵和投影矩阵就不说了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FragPos = position;</span><br><span class="line">	gl_Position = projectMatrix * viewMatrix * vec4(position,<span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;中间经过光栅化处理，我们在片元着色器得到每个片元的世界空间坐标。根据这个世界空间的坐标去索引计数缓冲，注意这里采用了GLSL的原子操作函数atmoicAdd，避免GPU线程之间的写冲突。缓冲下标索引的计算基本就是根据体素的大小和包围盒来确定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line"></span><br><span class="line">in vec3 FragPos;</span><br><span class="line"></span><br><span class="line">layout (std430, binding = <span class="number">0</span>) buffer CountBuffer&#123;</span><br><span class="line">    <span class="keyword">int</span> cnts[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> step;</span><br><span class="line">uniform vec3 boxMin;</span><br><span class="line">uniform vec3 resolution;</span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="keyword">int</span>((FragPos.x - boxMin.x)/step);</span><br><span class="line">	<span class="keyword">int</span> y = <span class="keyword">int</span>((FragPos.y - boxMin.y)/step);</span><br><span class="line">	<span class="keyword">int</span> z = <span class="keyword">int</span>((FragPos.z - boxMin.z)/step);</span><br><span class="line">	<span class="keyword">int</span> index = <span class="keyword">int</span>(y * (resolution.z * resolution.x) + z * resolution.x + x);</span><br><span class="line">	atomicAdd(cnts[index], <span class="number">1</span>);</span><br><span class="line">	color = vec4(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后下面就是我实现的体素化效果，每个体素用一个立方体绘制，当然也可以用球体绘制。看起来颇有游戏《我的世界》的风格。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/7.png" width="60%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/6.png" width="60%"></div></p>
<h1 id="二、修补裂缝"><a href="#二、修补裂缝" class="headerlink" title="二、修补裂缝"></a>二、修补裂缝</h1><p>&emsp;&emsp;上面的实现效果看起来貌似非常不错，但是却存在一个非常严重的问题。前面我们在选择投影平面的时候固定投影在了z轴方向的包围盒平面，这是问题产生的根源。因为模型的每个三角形面片在每个包围盒投影面上的投影结果都不同，若当前的三角形与选取的投影面垂直，那么三角形投影到平面上的将是一条直线，这丢失了很多信息，从而导致裂缝的产生。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/8.jpg" width="80%"></div></p>
<center> 图5 不同投影平面的体素化结果 </center>



<p>&emsp;&emsp;图5中，左图选取的投影面是摄像机在右边，朝向坐标，这时光栅化得到的结果很好，因而体素化的结果也很好。但是右边的这张图选取的投影面是摄像机在上面，朝向下边，这时光栅化得到的几何面片较少，很多相邻的位置都被投影到了一个片元像素，一些地方没有被体素化，从而导致了裂缝的产生！下面是我实现的程序产生的裂缝，选取的投影方向是z轴方向，下图中的红框部分的几何面片几乎平行于xz平面，从而导致投影光栅化产生的是一个被“压缩“的结果。由于裂缝非常明显且几乎必然会产生（因为通常模型都很复杂，三角形面片朝向很随机），因此有必要采取一些措施来修补这些裂缝。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/10.png" width="60%"></div></p>
<center> 图6 根据前面步骤产生的裂缝 </center>
&emsp;&emsp;如前面的图3所示，每个三角形面片在不同包围盒投影面上的投影结果不同，根据三角形的朝向不同，投影到平面上的三角形大小也各不相同。裂缝产生的原因就是因为投影到平面上的三角形面积被”压缩“了，因此我们需要选取一个投影方向，在该投影方向上三角形的投影面积最大，这样就能够确保所有的三角形面片被充分地体素化，从而使得裂缝小时。

<div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/11.png" width="80%">
<center> 图7 分别投影到包围盒的右、上、前平面上 </center>

<p>&emsp;&emsp;因此，我们首先创建三个投影摄像机，将物体分别投影到沿着$x$、$y$、$z$轴的平面上，如图7所示，用以后面着色器中根据三角形的投影面积做选择。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cameras</span></span><br><span class="line"><span class="keyword">float</span> offset = <span class="number">0.2f</span>;</span><br><span class="line">glm::vec3 cameraPosZ, cameraPosX, cameraPosY;</span><br><span class="line"><span class="comment">// looking along z axis.</span></span><br><span class="line">cameraPosZ.x = (min.x + max.x) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPosZ.y = (min.y + max.y) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPosZ.z = max.z + offset;</span><br><span class="line">FPSCamera::<span class="function">ptr <span class="title">cameraZ</span><span class="params">(<span class="keyword">new</span> FPSCamera(cameraPosZ))</span></span>;</span><br><span class="line">cameraZ-&gt;lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>), Camera3D::LocalUp);</span><br><span class="line">cameraZ-&gt;setOrthographicProject(-range.x * <span class="number">0.51</span>, +range.x * <span class="number">0.51</span>, -range.y * <span class="number">0.51</span>,</span><br><span class="line">	+range.y * <span class="number">0.51</span>, <span class="number">0.1</span>, range.z * <span class="number">1.2f</span> + offset);</span><br><span class="line"><span class="comment">// looking along x axis.</span></span><br><span class="line">cameraPosX.x = max.x + offset;</span><br><span class="line">cameraPosX.y = (min.y + max.y) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPosX.z = (min.z + max.z) * <span class="number">0.5f</span>;</span><br><span class="line">FPSCamera::<span class="function">ptr <span class="title">cameraX</span><span class="params">(<span class="keyword">new</span> FPSCamera(cameraPosX))</span></span>;</span><br><span class="line">cameraX-&gt;lookAt(glm::vec3(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), Camera3D::LocalUp);</span><br><span class="line">cameraX-&gt;setOrthographicProject(-range.z * <span class="number">0.51</span>, +range.z * <span class="number">0.51</span>, -range.y * <span class="number">0.51</span>,</span><br><span class="line">	+range.y * <span class="number">0.51</span>, <span class="number">0.1</span>, range.x * <span class="number">1.2f</span> + offset);</span><br><span class="line"><span class="comment">// looking along y axis.</span></span><br><span class="line">cameraPosY.x = (min.x + max.x) * <span class="number">0.5f</span>;</span><br><span class="line">cameraPosY.y = max.y + offset;</span><br><span class="line">cameraPosY.z = (min.z + max.z) * <span class="number">0.5f</span>;</span><br><span class="line">FPSCamera::<span class="function">ptr <span class="title">cameraY</span><span class="params">(<span class="keyword">new</span> FPSCamera(cameraPosY))</span></span>;</span><br><span class="line">cameraY-&gt;lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>), glm::vec3(<span class="number">0</span>, <span class="number">1.0</span>, <span class="number">0.001</span>));</span><br><span class="line">cameraY-&gt;setOrthographicProject(-range.x * <span class="number">0.51</span>, +range.x * <span class="number">0.51</span>, -range.z * <span class="number">0.51</span>,</span><br><span class="line">	+range.z * <span class="number">0.51</span>, <span class="number">0.1</span>, range.y * <span class="number">1.2f</span> + offset);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">shader-&gt;setMat4(<span class="string">"viewProject[0]"</span>, cameraX-&gt;getProjectMatrix() * cameraX-&gt;getViewMatrix());</span><br><span class="line">shader-&gt;setMat4(<span class="string">"viewProject[1]"</span>, cameraY-&gt;getProjectMatrix() * cameraY-&gt;getViewMatrix());</span><br><span class="line">shader-&gt;setMat4(<span class="string">"viewProject[2]"</span>, cameraZ-&gt;getProjectMatrix() * cameraZ-&gt;getViewMatrix());</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来我们将用到<strong>几何着色器</strong>，几何着色器阶段在顶点着色器之后、光栅化之前，它根据给定的输入图元和输出图元进行相关的几何图元操作，正好我们可以接用它来根据三角形的投影面积选择采用哪一个投影相机。这里有一个技巧，直观上我们说是根据三角形的投影面积来渲染采用哪个投影相机，实际上没有必要真正地去计算三角形的投影面积，<strong>我们可以直接根据当前三角形的世界空间法线朝向来决定投影方向</strong>。举个例子，当法线向量的x分量比其余两个分量大时，则当前的三角形肯定投影到x轴方向的投影平面上的面积更大。<strong>更深入的理解：设法线向量为$n=(nx,ny,nz)$，我们将法线向量$n$与$(1,0,0)$、$(0,1,0)$、$(0,0,1)$分别做点乘，结果为$nx$、$ny$、$nz$，而法线向量分别与该三个基向量点乘的意义为法线向量在$x$、$y$、$z$轴上的投影值，该值越大则三角形投影到该平面上的面积也越大。所以，我们直接根据最大的法线分量来选择采用哪个投影相机</strong>。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">selectViewProject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec3 p1 = gl_in[<span class="number">1</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">	vec3 p2 = gl_in[<span class="number">2</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">	vec3 faceNormal = cross(p1, p2);</span><br><span class="line">	<span class="keyword">float</span> nDX = <span class="built_in">abs</span>(faceNormal.x);</span><br><span class="line">	<span class="keyword">float</span> nDY = <span class="built_in">abs</span>(faceNormal.y);</span><br><span class="line">	<span class="keyword">float</span> nDZ = <span class="built_in">abs</span>(faceNormal.z);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( nDX &gt; nDY &amp;&amp; nDX &gt; nDZ )</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( nDY &gt; nDX &amp;&amp; nDY &gt; nDZ  )</span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后我们将上述的代码应用到我们的几何着色器中，因为视图投影过程挪到了几何着色器阶段，所以顶点着色器直接输入顶点的位置，不做任何变换。几何着色器设置输入图元为三角形，输出图元为最大顶点数为3的三角形带，设置一个viewProject的uniform数组。通过几何着色器，我们对模型的每个三角形面片都做了一个投影选择的处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vertex shader</span></span><br><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	gl_Position = vec4(position, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// geometry shader</span></span><br><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (triangles) in;</span><br><span class="line">layout (triangle_strip, max_vertices = <span class="number">3</span>) out;</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 viewProject[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">selectViewProject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec3 p1 = gl_in[<span class="number">1</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">	vec3 p2 = gl_in[<span class="number">2</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">	vec3 faceNormal = cross(p1, p2);</span><br><span class="line">	<span class="keyword">float</span> nDX = <span class="built_in">abs</span>(faceNormal.x);</span><br><span class="line">	<span class="keyword">float</span> nDY = <span class="built_in">abs</span>(faceNormal.y);</span><br><span class="line">	<span class="keyword">float</span> nDZ = <span class="built_in">abs</span>(faceNormal.z);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( nDX &gt; nDY &amp;&amp; nDX &gt; nDZ )</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( nDY &gt; nDX &amp;&amp; nDY &gt; nDZ  )</span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	uint projectIndex = selectViewProject();</span><br><span class="line">	FragPos = gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">	gl_Position = viewProject[projectIndex] * gl_in[<span class="number">0</span>].gl_Position;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">	FragPos = gl_in[<span class="number">1</span>].gl_Position.xyz;</span><br><span class="line">	gl_Position = viewProject[projectIndex] * gl_in[<span class="number">1</span>].gl_Position;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">	FragPos = gl_in[<span class="number">2</span>].gl_Position.xyz;</span><br><span class="line">	gl_Position = viewProject[projectIndex] * gl_in[<span class="number">2</span>].gl_Position;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">    EndPrimitive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最终，我们成功的修补了体素的裂缝，如下图所示，先前的裂缝已经填上了体素。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/12.png" width="60%"></div></p>
<center> 图8 成功修补裂缝 </center>


<h1 id="三、修补孔洞"><a href="#三、修补孔洞" class="headerlink" title="三、修补孔洞"></a>三、修补孔洞</h1><p>&emsp;&emsp;然而，通过前面2部分的处理，另外一个问题出现了。由于模型的每个三角形都是各自根据在每个平面上的投影面积来选择投影相机，这意味着两个相邻的三角形片面可能选取了不同投影相机，使得三角形面片之间因为体素化投影平面的不同而产生过渡问题，从而出现孔洞，即有些部分没有被体素化到。如下图9所示。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/13.png" width="60%"></div></p>
<center> 图9 体素孔洞 </center>

<p>&emsp;&emsp;孔洞的产生根源于光栅化处理，一个像素是否作为当前图元的光栅片元，是通过判断当前图元是否覆盖了该像素中心来完成的。对于那些没有覆盖像素中心的片元，不作为该图元的光栅片元送入片元着色器做进一步的处理，因而模型的一些部分可能会被丢失，从而造成孔洞。为了解决这个问题，我们将在几何着色器中实现一种被称为<strong>保守光栅化</strong>（Conservative Rasterization）的算法，依旧在几何着色器中实现。</p>
<p>&emsp;&emsp;通常的硬件光栅化，都是默认只取那些中心被图元覆盖的像素单元。而保守光栅化则将所有被图元覆盖（无论是否覆盖到像素单元的中心点）的像素单元都作为光栅化的片元，从而确保图元覆盖的所有区域都被光栅化，故名思意，这就是“保守”一词的由来。如下图10所示，通常情况下硬件默认的光栅片元是绿色部分，边缘红色部分的片元没有被光栅化，导致我们的体素化结果出现孔洞。为了修补体素化的孔洞，我们必须使得被图元哪怕一点点覆盖到的像素（就是下图中的红色部分）都作为当前图元的光栅化结果，这个过程就是保守光栅化算法。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/14.png" width="60%"></div></p>
<center> 图10 保守光栅化 </center>


<p>&emsp;&emsp;那么怎么实现保守光栅化算法，使得上面的红色部分也被光栅化到呢？<strong>一个简单直观的思路就是手动扩充三角形图元面片。如上图10所示，里面的三角形是最初的我们要光栅化的三角形，为了使得边缘红色的像素也包含进来，我们扩张最初的三角形得到外面的那个三角形，这个三角形比原来的三角形稍微大一点，此时若将该扩大的三角形送入硬件默认的光栅化单元进行处理，则红色像素也被当作光栅片元，从而达到了我们的目的。</strong>注意，这里三角形的扩大程度非常关键，上面的扩大的三角形将我们不需要的像素单元也包含了进来，即黄色像素部分，我们将通过计算三角形的包围盒来剔除那些黄色像素单元，剔除像素部分我们将在片元着色器中实现。下图11是我实现的保守光栅化（图右）效果，图左是默认光栅化的效果。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/20.jpg" width="80%"></div></p>
<center> 图11 默认的光栅化和保守光栅化对比 </center>


<p>&emsp;&emsp;扩大三角形和剔除像素整个过程都是在裁剪空间中进行的，也就是经过摄像机空间变换和投影变换之后。故而三角形的包围盒只需二维即可，然后需要适当地扩大一点，以免剔除红色的像素片元。一个裁剪空间的三角形包围盒计算如下所示，我们采用GLSL的vec4存储包围盒的最小顶点和最大顶点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">calcAABB</span><span class="params">(vec4 pos[<span class="number">3</span>], vec2 pixelDiagonal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec4 aabb;</span><br><span class="line">	aabb.xy = min(pos[<span class="number">2</span>].xy, min(pos[<span class="number">1</span>].xy, pos[<span class="number">0</span>].xy));</span><br><span class="line">	aabb.zw = max(pos[<span class="number">2</span>].xy, max(pos[<span class="number">1</span>].xy, pos[<span class="number">0</span>].xy));</span><br><span class="line">	<span class="comment">// enlarge by half-pixel</span></span><br><span class="line">	aabb.xy -= pixelDiagonal;</span><br><span class="line">	aabb.zw += pixelDiagonal;</span><br><span class="line">	<span class="keyword">return</span> aabb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来对于给定的三角形的三个顶点，我们要适当地扩大三角形。总体的思路就是：<strong>首先计算三角形的三条边与原点构成的齐次空间的平面，然后适当挪动这三个平面，接着就计算偏移后的这三个齐次平面的交线，最后计算三条交线与三角形平面的交点，从而得到扩大后的三角形的三个顶点。</strong>整个计算过程都是在裁剪空间中进行的，所以我们忽略顶点的$z$分量，但是上面又提到了齐次平面一词，我们采用一个齐次平面来描述三角形边的线段。所谓齐次平面，就是我们把顶点的齐次分量$w$和$x$、$y$分量合并一起来表示一条线段，直观来看，这就是一个齐次空间的平面，但实际上就是一段二维空间的直线。如下所示：</p>
<script type="math/tex; mode=display">
Ax_c+By_c+Cw_c=0 \tag {1}</script><p>&emsp;&emsp;公式$(1)$就是一个齐次空间的过原点的平面方程，但是它实际上就是一个二维空间的直线方程。这是因为我们采用的都是正交投影，正交投影并没有透视除法之类的处理，因为正交投影都是线性变换，故而$w_c=1$，所以公式$(1)$表示的过原点的齐次空间的平面方程就是如下所示的二维直线方程：</p>
<script type="math/tex; mode=display">
Ax_c+By_c+C=0 \tag {2}</script><p>&emsp;&emsp;之所以采用齐次空间的平面方程，是为了方便我们的计算。首先我们根据三角形的三条边计算三个齐次空间的平面，我们已知该齐次空间的平面过原点，平面方程的$(A,B,C)$就是该平面的法线向量，我们直接做叉乘计算可得平面的法线，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vec3 edgePlanes[<span class="number">3</span>];</span><br><span class="line">edgePlanes[<span class="number">0</span>] = cross(pos[<span class="number">0</span>].xyw - pos[<span class="number">2</span>].xyw, pos[<span class="number">2</span>].xyw);</span><br><span class="line">edgePlanes[<span class="number">1</span>] = cross(pos[<span class="number">1</span>].xyw - pos[<span class="number">0</span>].xyw, pos[<span class="number">0</span>].xyw);</span><br><span class="line">edgePlanes[<span class="number">2</span>] = cross(pos[<span class="number">2</span>].xyw - pos[<span class="number">1</span>].xyw, pos[<span class="number">1</span>].xyw);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后对这三个平面分别进行偏移。直观上来说，我们分别令三角形的三条边在其法线的方向上挪一段距离，这个距离由像素单元格的大小（即下面的halfPixel）在法线方向的投影决定，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edgePlanes[<span class="number">0</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">0</span>].xy));</span><br><span class="line">edgePlanes[<span class="number">1</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">1</span>].xy)); </span><br><span class="line">edgePlanes[<span class="number">2</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">2</span>].xy));</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接着计算三个齐次平面的交线向量，这个不难理解，两个平面的交线必然垂直于这两个平面的法线向量，因而交线向量可由这两个平面的法线向量做叉乘得到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vec3 intersection[<span class="number">3</span>];</span><br><span class="line">intersection[<span class="number">0</span>] = cross(edgePlanes[<span class="number">0</span>], edgePlanes[<span class="number">1</span>]);</span><br><span class="line">intersection[<span class="number">1</span>] = cross(edgePlanes[<span class="number">1</span>], edgePlanes[<span class="number">2</span>]);</span><br><span class="line">intersection[<span class="number">2</span>] = cross(edgePlanes[<span class="number">2</span>], edgePlanes[<span class="number">0</span>]);</span><br><span class="line">intersection[<span class="number">0</span>] /= intersection[<span class="number">0</span>].z;</span><br><span class="line">intersection[<span class="number">1</span>] /= intersection[<span class="number">1</span>].z;</span><br><span class="line">intersection[<span class="number">2</span>] /= intersection[<span class="number">2</span>].z;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后我们根据上面的三条射线向量与初试三角形所在的平面求交点，从而得到最终扩大后的三角形的三个顶点。由于我们是正交投影，所以上面求到的三条射线向量的$x$分量和$y$分量就是扩大三角形顶点的$x$分量和$y$分量，即交点的$x$、$y$已知，需要求$z$值。一个三维平面方程如下所示，从直观的几何意义上来说，$(A,B,C)$就是平面的法线向量，$D$就是原点到平面的直线距离。</p>
<script type="math/tex; mode=display">
Ax+By+Cz+D=0 \tag {3}</script><p>&emsp;&emsp;已知初始三角形的三个点，我们可以求出它的法线向量，然后原点到平面的直线距离就等于平面上的点在法线向量方向上的投影长度，这里要特别注意符号，具体看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec4 trianglePlane;</span><br><span class="line">trianglePlane.xyz = normalize(cross(pos[<span class="number">1</span>].xyz - pos[<span class="number">0</span>].xyz, pos[<span class="number">2</span>].xyz-pos[<span class="number">0</span>].xyz));</span><br><span class="line">trianglePlane.w   = -dot(pos[<span class="number">0</span>].xyz, trianglePlane.xyz);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后还需要提一点的是，我们要确保输入的三角形的顶点环绕顺序都是逆时针方向，这个逆时针方向是针对当前的相机投影方向。对于背向的面片，我们要做一个纠正的过程。判断是否是背向面片很简单，只需通过计算三角形法线向量与$(0,0,1)$做点乘，判断其符号即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// change winding, otherwise there are artifacts for the back faces.</span></span><br><span class="line"><span class="keyword">if</span> (dot(trianglePlane.xyz, vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)) &lt; <span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 vertexTemp = pos[<span class="number">2</span>];</span><br><span class="line">    pos[<span class="number">2</span>] = pos[<span class="number">1</span>];</span><br><span class="line">    pos[<span class="number">1</span>] = vertexTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;已知交点的$x$和$y$，我们代入平面方程$(3)$求得$z$值。</p>
<script type="math/tex; mode=display">
z=-\frac{Ax+By+D}{C} \tag {4}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate dilated triangle vertices</span></span><br><span class="line"><span class="keyword">float</span> z[<span class="number">3</span>];</span><br><span class="line">z[<span class="number">0</span>] = -(intersection[<span class="number">0</span>].x * trianglePlane.x + intersection[<span class="number">0</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">z[<span class="number">1</span>] = -(intersection[<span class="number">1</span>].x * trianglePlane.x + intersection[<span class="number">1</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">z[<span class="number">2</span>] = -(intersection[<span class="number">2</span>].x * trianglePlane.x + intersection[<span class="number">2</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">pos[<span class="number">0</span>].xyz = vec3(intersection[<span class="number">0</span>].xy, z[<span class="number">0</span>]);</span><br><span class="line">pos[<span class="number">1</span>].xyz = vec3(intersection[<span class="number">1</span>].xy, z[<span class="number">1</span>]);</span><br><span class="line">pos[<span class="number">2</span>].xyz = vec3(intersection[<span class="number">2</span>].xy, z[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最终，我们求得到扩大后的三角形的三个顶点，我们还需要对三个顶点做逆视图投影变换，将裁剪空间的顶点变换到世界空间，得到扩大后的三角形的世界坐标，因为我们最终目的是根据世界空间坐标做体素化的处理。与此同时，我们还将在裁剪空间的扩大三角形的顶点传到片元着色器，因为我们要剔除不必要的片元。以下是保守光栅化算法的几何着色器代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (triangles) in;</span><br><span class="line">layout (triangle_strip, max_vertices = <span class="number">3</span>) out;</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line">out vec3 ProjectPos;</span><br><span class="line">out vec4 BoundingBox;</span><br><span class="line"></span><br><span class="line">uniform vec2 halfPixel[<span class="number">3</span>];</span><br><span class="line">uniform mat4 viewProject[<span class="number">3</span>];</span><br><span class="line">uniform mat4 viewProjectInverse[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">selectViewProject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec3 p1 = gl_in[<span class="number">1</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">	vec3 p2 = gl_in[<span class="number">2</span>].gl_Position.xyz - gl_in[<span class="number">0</span>].gl_Position.xyz;</span><br><span class="line">	vec3 faceNormal = cross(p1, p2);</span><br><span class="line">	<span class="keyword">float</span> nDX = <span class="built_in">abs</span>(faceNormal.x);</span><br><span class="line">	<span class="keyword">float</span> nDY = <span class="built_in">abs</span>(faceNormal.y);</span><br><span class="line">	<span class="keyword">float</span> nDZ = <span class="built_in">abs</span>(faceNormal.z);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( nDX &gt; nDY &amp;&amp; nDX &gt; nDZ )</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( nDY &gt; nDX &amp;&amp; nDY &gt; nDZ  )</span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">vec4 <span class="title">calcAABB</span><span class="params">(vec4 pos[<span class="number">3</span>], vec2 pixelDiagonal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec4 aabb;</span><br><span class="line">	aabb.xy = min(pos[<span class="number">2</span>].xy, min(pos[<span class="number">1</span>].xy, pos[<span class="number">0</span>].xy));</span><br><span class="line">	aabb.zw = max(pos[<span class="number">2</span>].xy, max(pos[<span class="number">1</span>].xy, pos[<span class="number">0</span>].xy));</span><br><span class="line">	<span class="comment">// enlarge by half-pixel</span></span><br><span class="line">	aabb.xy -= pixelDiagonal;</span><br><span class="line">	aabb.zw += pixelDiagonal;</span><br><span class="line">	<span class="keyword">return</span> aabb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	uint projectIndex = selectViewProject();</span><br><span class="line">	vec4 pos[<span class="number">3</span>] = vec4[<span class="number">3</span>]</span><br><span class="line">	(</span><br><span class="line">		viewProject[projectIndex] * gl_in[<span class="number">0</span>].gl_Position,</span><br><span class="line">		viewProject[projectIndex] * gl_in[<span class="number">1</span>].gl_Position,</span><br><span class="line">		viewProject[projectIndex] * gl_in[<span class="number">2</span>].gl_Position</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	vec4 trianglePlane;</span><br><span class="line">	trianglePlane.xyz = normalize(cross(pos[<span class="number">1</span>].xyz - pos[<span class="number">0</span>].xyz, pos[<span class="number">2</span>].xyz - pos[<span class="number">0</span>].xyz));</span><br><span class="line">	trianglePlane.w   = -dot(pos[<span class="number">0</span>].xyz, trianglePlane.xyz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change winding, otherwise there are artifacts for the back faces.</span></span><br><span class="line">    <span class="keyword">if</span> (dot(trianglePlane.xyz, vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)) &lt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vec4 vertexTemp = pos[<span class="number">2</span>];</span><br><span class="line">        pos[<span class="number">2</span>] = pos[<span class="number">1</span>];</span><br><span class="line">        pos[<span class="number">1</span>] = vertexTemp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(trianglePlane.z == <span class="number">0.0f</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	BoundingBox = calcAABB(pos, halfPixel[projectIndex]);</span><br><span class="line"></span><br><span class="line">	vec3 edgePlanes[<span class="number">3</span>];</span><br><span class="line">	edgePlanes[<span class="number">0</span>] = cross(pos[<span class="number">0</span>].xyw - pos[<span class="number">2</span>].xyw, pos[<span class="number">2</span>].xyw);</span><br><span class="line">	edgePlanes[<span class="number">1</span>] = cross(pos[<span class="number">1</span>].xyw - pos[<span class="number">0</span>].xyw, pos[<span class="number">0</span>].xyw);</span><br><span class="line">	edgePlanes[<span class="number">2</span>] = cross(pos[<span class="number">2</span>].xyw - pos[<span class="number">1</span>].xyw, pos[<span class="number">1</span>].xyw);</span><br><span class="line">	edgePlanes[<span class="number">0</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">0</span>].xy));</span><br><span class="line">	edgePlanes[<span class="number">1</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">1</span>].xy)); </span><br><span class="line">	edgePlanes[<span class="number">2</span>].z -= dot(halfPixel[projectIndex], <span class="built_in">abs</span>(edgePlanes[<span class="number">2</span>].xy));</span><br><span class="line"></span><br><span class="line">	vec3 intersection[<span class="number">3</span>];</span><br><span class="line">	intersection[<span class="number">0</span>] = cross(edgePlanes[<span class="number">0</span>], edgePlanes[<span class="number">1</span>]);</span><br><span class="line">	intersection[<span class="number">1</span>] = cross(edgePlanes[<span class="number">1</span>], edgePlanes[<span class="number">2</span>]);</span><br><span class="line">	intersection[<span class="number">2</span>] = cross(edgePlanes[<span class="number">2</span>], edgePlanes[<span class="number">0</span>]);</span><br><span class="line">	intersection[<span class="number">0</span>] /= intersection[<span class="number">0</span>].z;</span><br><span class="line">	intersection[<span class="number">1</span>] /= intersection[<span class="number">1</span>].z;</span><br><span class="line">	intersection[<span class="number">2</span>] /= intersection[<span class="number">2</span>].z;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// calculate dilated triangle vertices</span></span><br><span class="line">	<span class="keyword">float</span> z[<span class="number">3</span>];</span><br><span class="line">	z[<span class="number">0</span>] = -(intersection[<span class="number">0</span>].x * trianglePlane.x + intersection[<span class="number">0</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">	z[<span class="number">1</span>] = -(intersection[<span class="number">1</span>].x * trianglePlane.x + intersection[<span class="number">1</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">	z[<span class="number">2</span>] = -(intersection[<span class="number">2</span>].x * trianglePlane.x + intersection[<span class="number">2</span>].y * trianglePlane.y + trianglePlane.w) / trianglePlane.z;</span><br><span class="line">	pos[<span class="number">0</span>].xyz = vec3(intersection[<span class="number">0</span>].xy, z[<span class="number">0</span>]);</span><br><span class="line">	pos[<span class="number">1</span>].xyz = vec3(intersection[<span class="number">1</span>].xy, z[<span class="number">1</span>]);</span><br><span class="line">	pos[<span class="number">2</span>].xyz = vec3(intersection[<span class="number">2</span>].xy, z[<span class="number">2</span>]);</span><br><span class="line">	</span><br><span class="line">	vec4 voxelPos;</span><br><span class="line"></span><br><span class="line">	ProjectPos = pos[<span class="number">0</span>].xyz;</span><br><span class="line">	gl_Position = pos[<span class="number">0</span>];</span><br><span class="line">	voxelPos = viewProjectInverse[projectIndex] * gl_Position;</span><br><span class="line">	FragPos = voxelPos.xyz;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">	ProjectPos = pos[<span class="number">1</span>].xyz;</span><br><span class="line">	gl_Position = pos[<span class="number">1</span>];</span><br><span class="line">	voxelPos = viewProjectInverse[projectIndex] * gl_Position;</span><br><span class="line">	FragPos = voxelPos.xyz;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">	ProjectPos = pos[<span class="number">2</span>].xyz;</span><br><span class="line">	gl_Position = pos[<span class="number">2</span>];</span><br><span class="line">	voxelPos = viewProjectInverse[projectIndex] * gl_Position;</span><br><span class="line">	FragPos = voxelPos.xyz;</span><br><span class="line">    EmitVertex();</span><br><span class="line"></span><br><span class="line">    EndPrimitive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后的最后，我们还需要在片元着色器剔除无关的片元，具体原因我已经在前面说了，如果不做这一步的剔除操作，将出现如下图12所示的情况。在片元着色器中，我们根据传入的三角形包围盒与当前的片元位置判断是否需要丢弃该片元。具体看下面代码的第19行、第20行。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/15.png" width="60%"></div></p>
<center> 图12 保守光栅化出现的边边角角 </center>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line"></span><br><span class="line">in vec3 FragPos;</span><br><span class="line">in vec3 ProjectPos;</span><br><span class="line">in vec4 BoundingBox;</span><br><span class="line"></span><br><span class="line">layout (std430, binding = <span class="number">0</span>) buffer CountBuffer&#123;</span><br><span class="line">    <span class="keyword">int</span> cnts[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">bool</span> conservate;</span><br><span class="line">uniform <span class="keyword">float</span> step;</span><br><span class="line">uniform vec3 boxMin;</span><br><span class="line">uniform vec3 resolution;</span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ProjectPos.x &lt; BoundingBox.x || ProjectPos.y &lt; BoundingBox.y || ProjectPos.x &gt; BoundingBox.z || ProjectPos.y &gt; BoundingBox.w)</span><br><span class="line">		discard;</span><br><span class="line"></span><br><span class="line">	uint x = uint((FragPos.x - boxMin.x)/step);</span><br><span class="line">	uint y = uint((FragPos.y - boxMin.y)/step);</span><br><span class="line">	uint z = uint((FragPos.z - boxMin.z)/step);</span><br><span class="line">	uint index = uint(y * (resolution.z * resolution.x) + z * resolution.x + x);</span><br><span class="line">	atomicAdd(cnts[index], <span class="number">1</span>);</span><br><span class="line">	color = vec4(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最终，修复了孔洞的效果的如下图，可以看到，对比前面的图9，孔洞基本都被“补”上了。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/16.jpg" width="90%"></div></p>
<center> 图13 保守光栅化出现的边边角角 </center>


<p>&emsp;&emsp;下面就是一些模型的体素化效果。</p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/17.png" width="90%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/18.png" width="90%"></div></p>
<p><div align="center"><img src="https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.13/blog/Voxelization/19.png" width="90%"></div></p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>$[1]$ <a href="https://developer.nvidia.com/content/basics-gpu-voxelization" target="_blank" rel="noopener">The Basics of GPU Voxelization</a></p>
<p>$[2]$ <a href="https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter42.html" target="_blank" rel="noopener">《GPU Gems 2》： Chapter 42. Conservative Rasterization</a></p>
<p>$[3]$ <a href="https://blog.csdn.net/xiewenzhao123/article/details/79875855" target="_blank" rel="noopener">https://blog.csdn.net/xiewenzhao123/article/details/79875855</a></p>
</div>
        </div>
        
          


  <section class="meta" id="footer-meta">
    <hr>
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-06-20T12:58:59+08:00">
  <a class="notlink">
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>最后更新于 2019年6月20日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Computer-Graphics/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Computer Graphics</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Voxelization/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Voxelization</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/06/11/Voxelization/&title=体素化Voxelization：基于GPU的三维体素化 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png&summary=本篇文章主要是关于三维网格模型的基于GPU并行的体素化算法，这个算法我是偶然从NVIDIA官网上看到的。基于GPU的体素化算法巧妙地借助了渲染流程的光栅化处理，将整个体素化的过程并行化，速度极快，缺点就是占用的内存较高。相关的完整代码请看这个链接中的Renderer目录下的Voxelization.h文件和Voxelization.cpp文件。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2019/06/11/Voxelization/&title=体素化Voxelization：基于GPU的三维体素化 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png&summary=本篇文章主要是关于三维网格模型的基于GPU并行的体素化算法，这个算法我是偶然从NVIDIA官网上看到的。基于GPU的体素化算法巧妙地借助了渲染流程的光栅化处理，将整个体素化的过程并行化，速度极快，缺点就是占用的内存较高。相关的完整代码请看这个链接中的Renderer目录下的Voxelization.h文件和Voxelization.cpp文件。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/06/11/Voxelization/&title=体素化Voxelization：基于GPU的三维体素化 | YangWC's Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-yangwc.com@1.1.21/blog/2DLighting/header.png&summary=本篇文章主要是关于三维网格模型的基于GPU并行的体素化算法，这个算法我是偶然从NVIDIA官网上看到的。基于GPU的体素化算法巧妙地借助了渲染流程的光栅化处理，将整个体素化的过程并行化，速度极快，缺点就是占用的内存较高。相关的完整代码请看这个链接中的Renderer目录下的Voxelization.h文件和Voxelization.cpp文件。
">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                            <h4>
                                <a href="/2019/06/20/NbodySimulation/" rel="prev" title="多体问题N-body：基于CUDA的快速N-body模拟">
                                  
                                      多体问题N-body：基于CUDA的快速N-body模拟
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/N-body/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>N-body</a> <a class="tag" href="/tags/Glow-effect/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Glow effect</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2019/06/04/PositionBasedFluid/" rel="prev" title="流体模拟Fluid Simulation：Position Based Fluid">
                                    
                                        流体模拟Fluid Simulation：Position Based Fluid
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Computer-Graphics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Computer Graphics</a> <a class="tag" href="/tags/Fluid-Simulation/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Fluid Simulation</a> <a class="tag" href="/tags/Position-Based-Dynamics/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i>Position Based Dynamics</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
        <section id="comments">
          <div id="lv-container" data-id="city" data-uid="MTAyMC80MzkxOS8yMDQ1NQ==">
            <noscript><div><i class="fas fa-exclamation-triangle">&nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。</i></div></noscript>
          </div>
        </section>
      
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

  <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



  <script>
    window.subData = {
      title: '体素化Voxelization：基于GPU的三维体素化',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
    
    
      
        
          
          
            <section class="widget author">
  <div class="content material">
    
      <div class="avatar">
        <fancybox><img class="avatar" src="/image/avator.png"></fancybox>
      </div>
    
    
      <div class="text">
        
          <h2>YangWC</h2>
        
        
          <p>A student from Sun Yat-sen University.</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget toc-wrapper">
    
<header class="material">
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class="content material">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、体素化"><span class="toc-text">一、体素化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、修补裂缝"><span class="toc-text">二、修补裂缝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、修补孔洞"><span class="toc-text">三、修补孔洞</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料："><span class="toc-text">参考资料：</span></a></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class="widget plain">
  
<header class="material">
  <div><i class=" fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;欢迎来到YangWC的博客</div>
  
</header>

  <div class="content material">
    <p>本站会记录自己的一些学习内容，如若有错，欢迎指正，感谢!</p>

  </div>
</section>

          
        
      
        
          
          
            <section class="widget grid">
  
<header class="material">
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class="content material">
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/" id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于博主
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class="widget category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn" rel="nofollow" href="/categories/" title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/2D-Rendering/" href="/categories/2D-Rendering/"><div class="name">2D Rendering</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Computer-Graphics/" href="/categories/Computer-Graphics/"><div class="name">Computer Graphics</div><div class="badge">(20)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Fluid-Simulation/" href="/categories/Fluid-Simulation/"><div class="name">Fluid Simulation</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/N-body/" href="/categories/N-body/"><div class="name">N-body</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Physically-Based-Rendering/" href="/categories/Physically-Based-Rendering/"><div class="name">Physically Based Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Position-Based-Dynamics/" href="/categories/Position-Based-Dynamics/"><div class="name">Position Based Dynamics</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Ray-Tracer/" href="/categories/Ray-Tracer/"><div class="name">Ray Tracer</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Real-time-Rendering/" href="/categories/Real-time-Rendering/"><div class="name">Real-time Rendering</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Soft-Renderer/" href="/categories/Soft-Renderer/"><div class="name">Soft Renderer</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Voxelization/" href="/categories/Voxelization/"><div class="name">Voxelization</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class="widget tagcloud">
    
<header class="material">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn" rel="nofollow" href="/tags/" title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class="content material">
      <a href="/tags/2D-Rendering/" style="font-size: 14px; color: #bbb">2D Rendering</a> <a href="/tags/3D-Math/" style="font-size: 14px; color: #bbb">3D Math</a> <a href="/tags/3D-pipeline/" style="font-size: 16px; color: #c9c9c9">3D pipeline</a> <a href="/tags/Advection/" style="font-size: 14px; color: #bbb">Advection</a> <a href="/tags/Computer-Graphics/" style="font-size: 24px; color: #fff">Computer Graphics</a> <a href="/tags/Fluid-Simulation/" style="font-size: 22px; color: #f1f1f1">Fluid Simulation</a> <a href="/tags/Glow-effect/" style="font-size: 14px; color: #bbb">Glow effect</a> <a href="/tags/N-body/" style="font-size: 14px; color: #bbb">N-body</a> <a href="/tags/Naiver-Stokes-Equations/" style="font-size: 14px; color: #bbb">Naiver-Stokes Equations</a> <a href="/tags/Physically-Based-Rendering/" style="font-size: 16px; color: #c9c9c9">Physically Based Rendering</a> <a href="/tags/Position-Based-Dynamics/" style="font-size: 18px; color: #d6d6d6">Position Based Dynamics</a> <a href="/tags/Rasterization/" style="font-size: 14px; color: #bbb">Rasterization</a> <a href="/tags/Ray-Tracer/" style="font-size: 16px; color: #c9c9c9">Ray Tracer</a> <a href="/tags/Real-time-Rendering/" style="font-size: 16px; color: #c9c9c9">Real-time Rendering</a> <a href="/tags/Soft-Renderer/" style="font-size: 20px; color: #e4e4e4">Soft Renderer</a> <a href="/tags/Voxelization/" style="font-size: 14px; color: #bbb">Voxelization</a>
    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:1579148717@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ZeusYang" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://blog.csdn.net/qq_31615919" class="social fas fa-code-branch flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
	<script>
		var now = new Date(); 
		function createtime() { 
			var grt= new Date("04/24/2019 18:00:00");//在此处修改你的建站时间
			now.setTime(now.getTime()+250); 
			days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
			hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
			if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
			mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
			seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
			snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
			document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
			document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
		} 
	setInterval("createtime()",250);
   </script>
   
   <!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->
	
	
	<script>setLoadingBarProgress(80);</script>
</footer>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>









  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>






  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.4.19/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  
    <!--数字雨背景-->
  <canvas id="canvas" width="1440" height="900" ></canvas>
  <script>
	var s = window.screen;
	var width = canvas.width = s.width;
	var height = canvas.height = s.height;
	var fontSize = 13;
	var colunms = Math.floor(width/fontSize);
	var letters = [];
    for(var i=0;i<colunms;i++){
        letters.push(1);
    }
	var draw = function () {
	    canvas.getContext('2d').fillStyle = "rgba(0,0,0,.08)";//遮盖层
		canvas.getContext('2d').fillRect(0,0,width,height);
		canvas.getContext('2d').font = "700 " + fontSize +"px  微软雅黑";
		letters.map(function(y_pos, index){
		text = String.fromCharCode(34+Math.random()*33);
		x_pos = index * fontSize;
		canvas.getContext('2d').fillText(text, x_pos, y_pos);
		letters[index] = (y_pos > 758 + Math.random() * 1e4) ? 0 : y_pos + 10;
		canvas.getContext('2d').fillStyle='#'+letters[index];
	  });
	};
	setInterval(draw, 33);
  </script>
  
  <!-- 页面点击出现文字 -->
  <script type="text/javascript" src="/js/ClickShowText.js"></script>
  
  <script>setLoadingBarProgress(100);</script>
</body>
</html>
